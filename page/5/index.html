<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"the-rings.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
<meta property="og:type" content="website">
<meta property="og:title" content="免逸">
<meta property="og:url" content="https://the-rings.github.io/page/5/index.html">
<meta property="og:site_name" content="免逸">
<meta property="og:description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="The Rings">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://the-rings.github.io/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>免逸</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">免逸</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">下一代web开发是什么样的？下一代类报表系统是什么样的？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">The Rings</p>
  <div class="site-description" itemprop="description">软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/10/05/professional-dictionary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/05/professional-dictionary/" class="post-title-link" itemprop="url">专业词汇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-05 09:32:58" itemprop="dateCreated datePublished" datetime="2021-10-05T09:32:58+08:00">2021-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%8D%E6%B1%87/" itemprop="url" rel="index"><span itemprop="name">词汇</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>inference 推断 n.</p>
</blockquote>
<p>Lambda expressions include a form of type inference in Java.<br>Lambda表达式包含一种类型推导.</p>
<blockquote>
<p>assign 指派 v.</p>
</blockquote>
<p><code>Shape s = new Circle();</code>  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.<br>这里翻译为”指派”, <code>s</code>被指派(指定)了一个类型Shape.</p>
<blockquote>
<p>oriented 导向的，定向的adj.</p>
</blockquote>
<blockquote>
<p>object-oriented [计]面向对象的adj.</p>
</blockquote>
<blockquote>
<p>Connector 端口，连接头n.</p>
</blockquote>
<blockquote>
<p>Configure 配置v.</p>
</blockquote>
<blockquote>
<p>Specified 指定的adj.</p>
</blockquote>
<blockquote>
<p>Deploy 部署v.</p>
</blockquote>
<blockquote>
<p>Undeploy 卸载v.</p>
</blockquote>
<blockquote>
<p>Expire 终止v.</p>
</blockquote>
<blockquote>
<p>Session 学期，一段时间n.</p>
</blockquote>
<blockquote>
<p>Dynamic 动态的adj.</p>
</blockquote>
<blockquote>
<p>Module 组件，单元，模块n.</p>
</blockquote>
<blockquote>
<p>Directory 路径n.</p>
</blockquote>
<blockquote>
<p>Descriptor 描述符n.</p>
</blockquote>
<blockquote>
<p>Install 安装v.</p>
</blockquote>
<blockquote>
<p>Synchronize 使同步v.</p>
</blockquote>
<blockquote>
<p>Meta 元，meta语言n.</p>
</blockquote>
<blockquote>
<p>Charset 字符集n.</p>
</blockquote>
<blockquote>
<p>Charater 字符n.</p>
</blockquote>
<blockquote>
<p>Flush 冲洗v.</p>
</blockquote>
<blockquote>
<p>Mapping 映射n.</p>
</blockquote>
<blockquote>
<p>Protocol 协议n.</p>
</blockquote>
<blockquote>
<p>Generic 普通的；一般的adj.</p>
</blockquote>
<blockquote>
<p>Initialize 初始化v.</p>
</blockquote>
<blockquote>
<p>Sequence 一系列, 列表n.</p>
</blockquote>
<blockquote>
<p>In addition to 除….之外</p>
</blockquote>
<blockquote>
<p>Thread 线n.</p>
</blockquote>
<blockquote>
<p>Timeout 超时，过期n.</p>
</blockquote>
<blockquote>
<p>Summary 摘要n.</p>
</blockquote>
<blockquote>
<p>Contain 容纳，限制v.</p>
</blockquote>
<blockquote>
<p>Subclass 子类n.</p>
</blockquote>
<blockquote>
<p>Declare 声明v.</p>
</blockquote>
<blockquote>
<p>Dispatch 派遣，发送v.</p>
</blockquote>
<blockquote>
<p>Additional 附加的，额外的adj.</p>
</blockquote>
<blockquote>
<p>Stream 流n.   </p>
</blockquote>
<blockquote>
<p>Input stream输入流</p>
</blockquote>
<blockquote>
<p>Encode 编码v.</p>
</blockquote>
<blockquote>
<p>URL 统一资源定位符</p>
</blockquote>
<blockquote>
<p>URI 统一资源标识符</p>
</blockquote>
<blockquote>
<p>Invalidate 使销毁，使作废v.</p>
</blockquote>
<blockquote>
<p>Layer 层n.</p>
</blockquote>
<blockquote>
<p>Prefix 前缀n.</p>
</blockquote>
<blockquote>
<p>Tag标签 n.</p>
</blockquote>
<blockquote>
<p>Wrapper 包装用品n.</p>
</blockquote>
<blockquote>
<p>Filter 过滤器n.</p>
</blockquote>
<blockquote>
<p>Chain 链条n.</p>
</blockquote>
<blockquote>
<p>Notation 记号；表示法；记法n.</p>
</blockquote>
<blockquote>
<p>Serialize　使连载v.</p>
</blockquote>
<blockquote>
<p>Plugins 插件n.</p>
</blockquote>
<blockquote>
<p>Validate 使生效v.</p>
</blockquote>
<blockquote>
<p>Panel 面板；仪表盘n.</p>
</blockquote>
<blockquote>
<p>Literal 字面上的；文字的adj.  </p>
</blockquote>
<blockquote>
<p>Constant 不变的adj. 常量，恒量；n.</p>
</blockquote>
<blockquote>
<p>Mutable 可变的adj.</p>
</blockquote>
<blockquote>
<p>Specified 指定的；规定的adj.</p>
</blockquote>
<blockquote>
<p>Collapsible 可折叠的，可收缩的adj.</p>
</blockquote>
<blockquote>
<p>Icon 图标[计]；象征；偶像adj.</p>
</blockquote>
<blockquote>
<p>Combo 组合物n.</p>
</blockquote>
<blockquote>
<p>Handler 处理器n.</p>
</blockquote>
<blockquote>
<p>Grid 格子，网格n.</p>
</blockquote>
<blockquote>
<p>Validate 使生效；证实v.</p>
</blockquote>
<blockquote>
<p>Required 必须的adj.</p>
</blockquote>
<blockquote>
<p>Parse 解析v.   从语法上分析n.</p>
</blockquote>
<blockquote>
<p>Separator 分隔符n.</p>
</blockquote>
<blockquote>
<p>Interrupt 中断n.</p>
</blockquote>
<blockquote>
<p>Runnable 可捕捉的，可猎取的 adj.</p>
</blockquote>
<blockquote>
<p>Daemon 守护神，[计]守护线程n.</p>
</blockquote>
<blockquote>
<p>Priority 优先级，优先权，优先顺序n.</p>
</blockquote>
<blockquote>
<p>Notify 通知，报告v.</p>
</blockquote>
<blockquote>
<p>Invoke引起v.</p>
</blockquote>
<blockquote>
<p>Split 分裂，分离v.</p>
</blockquote>
<blockquote>
<p>Deprecated 过时的adj.</p>
</blockquote>
<blockquote>
<p>Suppress禁止，压制v.</p>
</blockquote>
<blockquote>
<p>Retention 保持力，保存期限n.</p>
</blockquote>
<blockquote>
<p>Annotation 注解，注释n.</p>
</blockquote>
<blockquote>
<p>Nickname 昵称，绰号n.</p>
</blockquote>
<blockquote>
<p>Invocation [计]调用；（法律的）实施；祈祷n.</p>
</blockquote>
<blockquote>
<p>Template 样板，模板n.</p>
</blockquote>
<blockquote>
<p>Intersect 交叉，相交v.</p>
</blockquote>
<blockquote>
<p>Minus 减号，减去n.</p>
</blockquote>
<blockquote>
<p>Increment 增加v.</p>
</blockquote>
<blockquote>
<p>Validate 使..生效，确认；v.</p>
</blockquote>
<blockquote>
<p>Encapsulation 包装，封装n.</p>
</blockquote>
<blockquote>
<p>Polymorphism 多态性n.</p>
</blockquote>
<blockquote>
<p>Catalog 目录n.</p>
</blockquote>
<blockquote>
<p>Detached 游离的，分离的；adj.</p>
</blockquote>
<blockquote>
<p>Persistent 持久的；adj.</p>
</blockquote>
<blockquote>
<p>Transient 瞬时的；adj.</p>
</blockquote>
<blockquote>
<p>Dependency 从属n.</p>
</blockquote>
<blockquote>
<p>Injection 注射n.</p>
</blockquote>
<blockquote>
<p>Component 成分，组件n.</p>
</blockquote>
<blockquote>
<p>Schema [计]模式，范式n.</p>
</blockquote>
<blockquote>
<p>Scheme 计划n.</p>
</blockquote>
<blockquote>
<p>Suffix 后缀，下标n.</p>
</blockquote>
<blockquote>
<p>Mechanism 机制，原理n.</p>
</blockquote>
<blockquote>
<p>Facet 面，方面n.</p>
</blockquote>
<blockquote>
<p>Validation 确认，批准，生效n.</p>
</blockquote>
<blockquote>
<p>Duplicate 复制v.</p>
</blockquote>
<blockquote>
<p>Invalid 无效的adj.</p>
</blockquote>
<blockquote>
<p>Submission 投降，提交n.</p>
</blockquote>
<blockquote>
<p>Alias 别名n.</p>
</blockquote>
<blockquote>
<p>Argument 参数n.</p>
</blockquote>
<blockquote>
<p>Requirements 需求，要求n.</p>
</blockquote>
<blockquote>
<p>Neglect 疏忽，忽视vt.</p>
</blockquote>
<blockquote>
<p>Term 术语n.</p>
</blockquote>
<blockquote>
<p>Allocate 分配vt.</p>
</blockquote>
<blockquote>
<p>Validate 验证，确认（表现为一般的检查）vt.</p>
</blockquote>
<blockquote>
<p>Compile 编译vt.</p>
</blockquote>
<blockquote>
<p>Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.</p>
</blockquote>
<blockquote>
<p>Repository 仓库，资源库，版本库n.</p>
</blockquote>
<blockquote>
<p>Plugins 插件，外挂n.</p>
</blockquote>
<blockquote>
<p>Procedure [计算机]过程 n.</p>
</blockquote>
<blockquote>
<p>Retain 保持vt.</p>
</blockquote>
<blockquote>
<p>Clause 从句 n.</p>
</blockquote>
<blockquote>
<p>Via 通过 n.f</p>
</blockquote>
<blockquote>
<p>Along with 连同，以及，和……一起</p>
</blockquote>
<blockquote>
<p>Excluding 除……之外，不包括 prep.</p>
</blockquote>
<blockquote>
<p>Standalone 单独的，独立的adj.</p>
</blockquote>
<blockquote>
<p>Cluster 集群，簇n.</p>
</blockquote>
<blockquote>
<p>Aggregation 集成，聚集n.</p>
</blockquote>
<blockquote>
<p>Excerpt 摘录，摘要n.</p>
</blockquote>
<blockquote>
<p>Integration 整合，集成n.</p>
</blockquote>
<blockquote>
<p>Expectation 期待，盼望n.</p>
</blockquote>
<blockquote>
<p>Composite 合成的adj. 使合成vt.</p>
</blockquote>
<blockquote>
<p>Interaction 相互作用，相互影响n.</p>
</blockquote>
<blockquote>
<p>Doubt 怀疑，不信n.vt.</p>
</blockquote>
<blockquote>
<p>Field 字段，域n.</p>
</blockquote>
<blockquote>
<p>Intermediate 起媒介作用vi. 中间的adj. 媒介n.</p>
</blockquote>
<blockquote>
<p>Authorization 授权，认可n.</p>
</blockquote>
<blockquote>
<p>Demarcation 界限，划分n.</p>
</blockquote>
<blockquote>
<p>Conscious 意识到的adj.</p>
</blockquote>
<blockquote>
<p>Retrieve 检索vt.</p>
</blockquote>
<blockquote>
<p>Traverse 穿过，横越；[计]遍历vt.</p>
</blockquote>
<blockquote>
<p>Breadth 宽度，广度n.</p>
</blockquote>
<blockquote>
<p>Breadth First广度优先n.</p>
</blockquote>
<blockquote>
<p>Evaluate 评价，评估vt.</p>
</blockquote>
<blockquote>
<p>Perform 执行，机器运转，表演vt.</p>
</blockquote>
<blockquote>
<p>Depth 深度n.</p>
</blockquote>
<blockquote>
<p>Instantiate 实例化vt.</p>
</blockquote>
<blockquote>
<p>Custom 习惯，惯例，风俗n.</p>
</blockquote>
<blockquote>
<p>In this case 在这种情况下，在这个案例中</p>
</blockquote>
<blockquote>
<p>Descent 下降n.</p>
</blockquote>
<blockquote>
<p>Descendant 子孙，下降</p>
</blockquote>
<blockquote>
<p>Mutable 可变的，不定的adj.</p>
</blockquote>
<blockquote>
<p>Immutable 不可变的adj.</p>
</blockquote>
<blockquote>
<p>Expand 扩张，使膨胀vt.</p>
</blockquote>
<blockquote>
<p>In term of 根据</p>
</blockquote>
<blockquote>
<p>Explanation 说明，解释n.</p>
</blockquote>
<blockquote>
<p>Regardless of 不管，不顾</p>
</blockquote>
<blockquote>
<p>Latter 后者n.</p>
</blockquote>
<blockquote>
<p>Prune 剪枝n.</p>
</blockquote>
<blockquote>
<p>Fluent 流动的adj.</p>
</blockquote>
<blockquote>
<p>Manual 手工的，手动的adj.</p>
</blockquote>
<blockquote>
<p>Notification 通知，通告n.</p>
</blockquote>
<blockquote>
<p>Entity 实体n.</p>
</blockquote>
<blockquote>
<p>Whereas 然而，反之n.</p>
</blockquote>
<blockquote>
<p>In case 万一</p>
</blockquote>
<blockquote>
<p>Persist 坚持，固执vi.</p>
</blockquote>
<blockquote>
<p>Snapshot 快照n.</p>
</blockquote>
<blockquote>
<p>Assert 断言n.</p>
</blockquote>
<blockquote>
<p>Quote 引号n.</p>
</blockquote>
<blockquote>
<p>Coroutine 协同程序n.</p>
</blockquote>
<blockquote>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/10/01/spring-aop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/01/spring-aop/" class="post-title-link" itemprop="url">Spring AOP原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-01 19:07:03" itemprop="dateCreated datePublished" datetime="2021-10-01T19:07:03+08:00">2021-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><p>对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, <strong>但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题</strong>. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.</p>
<ul>
<li>静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的横切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.</li>
<li>动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.</li>
</ul>
<h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><p>首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.</p>
<h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.</p>
<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:</p>
<ul>
<li>Before Advice, 在Joinpoint位置之前执行的Advice类型</li>
<li>After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等</li>
<li>Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.</li>
<li>Introduction</li>
</ul>
<h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>Aspect是对以上三者进行封装的AOP概念.</p>
<p>我们可以在Spring源码中看到对应关键词<code>org.springframework.aop.config.ConfigBeanDefinitionParser</code>，这个类主要用来解析xml中定义的<code>&lt;aop:config&gt;</code>等标签，以下是部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT = <span class="string">&quot;aspect&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION = <span class="string">&quot;expression&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT = <span class="string">&quot;pointcut&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_BEAN_NAME = <span class="string">&quot;adviceBeanName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVISOR = <span class="string">&quot;advisor&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_REF = <span class="string">&quot;advice-ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_REF = <span class="string">&quot;pointcut-ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REF = <span class="string">&quot;ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE = <span class="string">&quot;before&quot;</span>;</span><br><span class="line">    <span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>AOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现.</p>
<h3 id="JDK动态代理与CGLIB-基于ASM"><a href="#JDK动态代理与CGLIB-基于ASM" class="headerlink" title="JDK动态代理与CGLIB(基于ASM)"></a>JDK动态代理与CGLIB(基于ASM)</h3><a href="/2021/08/01/pattern-proxy-and-dynamic/" title="动态代理">动态代理</a>，这里不在赘述.
<p>结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.<br>动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应接口的类使用, 如果某个类没有实现任何接口, 就无法使用动态代理机制为其生成相应的动态代理对象.</p>
<p>使用CGLIB动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB(基于ASM)可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.<br>通常我们会直接使用<code>net.sf.cglib.proxy.MethodInterceptor</code>接口(扩展了net.sf.cglib.proxy.Callback接口): </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Requestable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCtrlInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">           TimeOfDay startTime = <span class="keyword">new</span> TiemOfDay(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">           TimeOfDay endTime = <span class="keyword">new</span> TiemOfDay(<span class="number">5</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">           TiemOfDay currentTime = <span class="keyword">new</span> TimeDay();</span><br><span class="line">           <span class="keyword">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;Service is not available now.&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> proxy.invokeSuper(object, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(Requestable.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> RequestCtrlInterceptor());</span><br><span class="line"></span><br><span class="line">Requestable proxy = (Requestable) enhancer.create();</span><br><span class="line">proxy.request();</span><br></pre></td></tr></table></figure>
<p>这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor</p>
<p>对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:</p>
<ul>
<li>Spring AOP设计理念是，简单而强大</li>
<li>对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的</li>
<li>如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)</li>
</ul>
<p>对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">    ClassFilter getClassFilter;</span><br><span class="line">    MethodMatcher getMethodMatcher;</span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>见名知意, 不是重点, 不再赘述</p>
<p>对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.<br>Spring中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: <code>org.aopalliance.intercept.MethodInterceptor</code>, 该接口定义如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.intercept;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts calls on an interface on its way to the target. These</span></span><br><span class="line"><span class="comment"> * are nested &quot;on top&quot; of the target.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">	 * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">	 * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;;</span></span><br><span class="line"><span class="comment">	 * might be intercepted by the interceptor</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Throwable if the interceptors or the target object</span></span><br><span class="line"><span class="comment">	 * throws an exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.</p>
<p>接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_DISCOUNT_RATIO = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处”短路”.</p>
</blockquote>
<p>我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;discountInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...DiscountMethodInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**<a href="/2021/11/02/pattern-chain-of-responsibility/" title="责任链模式">责任链模式</a>**</p>
<h2 id="SpringAOP的织入"><a href="#SpringAOP的织入" class="headerlink" title="SpringAOP的织入"></a>SpringAOP的织入</h2><p>AspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用<code>org.springframework.aop.ProxyFactory</code>, 在Spring AOP中这是最基本的织入器.</p>
<p>总的思路是: <strong>Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象</strong>. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.</p>
<p>使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory weaver = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> Executable());</span><br><span class="line">NameMatchMethodPointcutAdvisor advisor = <span class="keyword">new</span> NameMathMethodPointcutAdvisor();</span><br><span class="line">advisor.setMappedName(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">advisor.setAdvice(<span class="keyword">new</span> RequestCtrlInterceptor());</span><br><span class="line">weaver.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">weaver.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Requestable proxyObject = (Requestable) weaver.getProxy();</span><br><span class="line">proxyObject.request();</span><br><span class="line">System.out.println(proxyObject.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// class ...Requestable$$EnhancerByCGLIB$$9e62fc83</span></span><br><span class="line"><span class="comment">// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是&quot;$Proxy0&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了<code>proxyTargetClass</code>的属性为<code>true</code>, 强制其采用基于类的代理, 即使目标类确实是基于接口的.</p>
<h3 id="探索ProxyFactory本质"><a href="#探索ProxyFactory本质" class="headerlink" title="探索ProxyFactory本质"></a>探索ProxyFactory本质</h3><p>先来看一下类之间的关系</p>
<img  src=http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OezwgK7Zo92KKH5KF0BrissH6ksfAjOr7_NAbLRcrCoCzbv6zkpAzXkJtakGM4KHH1BlWboAMT8Ag4S0X99iCwde6ASLmu94hTpS3NmFBKA51YLwsSlRXQH-CIbVNCtxJ6ZsvDXoWcUCcrvfWf_Sbsexz8cP9DllTipAQIiRwv-fph9i2XMWfO3qFTUyJOOAjQbFKnBZqT7hx_6j0I8ejiO5luiXEh4pz7RZCCFv9y7ruwUIPgvtQ1UsJm0>

<p>其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.</p>
<p>AopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an &#123;<span class="doctag">@link</span> AopProxy&#125; for the given AOP configuration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> config the AOP configuration in the form of an</span></span><br><span class="line"><span class="comment">	 * AdvisedSupport object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the corresponding AOP proxy</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AopConfigException if the configuration is invalid</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(config.isOptimize || config.isProxyTargetClass() || ...) &#123;</span><br><span class="line">    <span class="comment">// 创建Cglib2AopProxy实例, 返回</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建JdkDynamicAopProxy实例, 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下内容定格在177页《Spring揭秘》, 关于AOP的剩余内容以后在补充.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/09/28/spring-boot-startup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/28/spring-boot-startup/" class="post-title-link" itemprop="url">SpringBoot启动简要流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-28 18:43:05" itemprop="dateCreated datePublished" datetime="2021-09-28T18:43:05+08:00">2021-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>SpringBoot的启动过程就是SpringApplication实例化并运行run方法的过程，最终返回ConfigurableApplicationContext实例。 ConfigurableApplicationContext继承了ApplicationContext。</p>
<ol>
<li>获取监听器，启动事件监听</li>
<li>获取命令行参数，准备项目环境</li>
<li>打印Banner</li>
<li>初始化ApplicationContext(对于Web应用返回AnnotationConfigServletWebServerApplicationContext)</li>
<li>prepareContext</li>
<li>刷新上下文(refreshContext)</li>
<li>afterRefresh, 三个方法完整的建立Context</li>
<li>向监听器发出执行结束的通知，返回ConfigurableApplicationContext</li>
</ol>
<p>附上run方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);                                                 <span class="comment">// [1]</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); <span class="comment">// [2]</span></span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		Banner printedBanner = printBanner(environment);                                                             <span class="comment">// [3]</span></span><br><span class="line">		context = createApplicationContext();                                                                        <span class="comment">// [4]</span></span><br><span class="line">		context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);      <span class="comment">// [5]</span></span><br><span class="line">		refreshContext(context);                                                                                     <span class="comment">// [6]</span></span><br><span class="line">		afterRefresh(context, applicationArguments);                                                                 <span class="comment">// [7]</span></span><br><span class="line">		Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context, timeTakenToStartup);                                                              <span class="comment">// [8]</span></span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">		listeners.ready(context, timeTakenToReady);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/09/28/spring-ioc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/28/spring-ioc/" class="post-title-link" itemprop="url">Spring IoC基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-28 15:08:10" itemprop="dateCreated datePublished" datetime="2021-09-28T15:08:10+08:00">2021-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/IoC/" itemprop="url" rel="index"><span itemprop="name">IoC</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InterfaceItem orderItem;</span><br><span class="line">    <span class="keyword">private</span> InterfaceAddress orderAddress;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) &#123;</span><br><span class="line">        <span class="keyword">this</span>.orderItem = orderItem;</span><br><span class="line">        <span class="keyword">this</span>.orderAddress = orderAddress;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">persistOrderData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> AmazonOrderItem implements InterfaceItem &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> AmazonOrderAddress implements InterfaceItem &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IoC是如何诞生的"><a href="#IoC是如何诞生的" class="headerlink" title="IoC是如何诞生的"></a>IoC是如何诞生的</h2><p>IoC中文被翻译为”控制反转”, 一直都让我一头雾水, 软件工程师取名总是带着一种”我提出了一个改变世界的概念”的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.<br>得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, …), 这些obj_n都是通过new得到的.<br>当人们把很多项目放在一起比较发现, 这些”new操作”, 其实是一种高级别的相似, 那么就可以”抽出它们像的部分”, 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象”主动”送过来, 而不是我们自己去new, 所以就是”控制反转”.<br>达到的目的就是”依赖注入”, 将依赖对象注入到被注入对象中.<br>注入的方式有三种, 构造器注入(推荐), setter注入(推荐), Field注入(不推荐)<br>整个IoC的过程可以简化为：加载解析XML &gt; 封装BeanDefination &gt; 实例化 &gt; 放到容器中 &gt; 从容器中Get</p>
<h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p><strong>通常被大家称为IoC容器</strong>. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.<br>既然是容器，那么容器使用什么数据结构存储呢？必然是Map，Map的key的类型可以是String/Class，储存的value首先得是Object，另外Spring还设计了BeanFactory和BeanDefination等类型<br><strong>Spring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.</strong><br>Spring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有<code>@Configuration</code>, <code>@Component</code>, <code>@Service</code>等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.</p>
<p>很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了,依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;amazonOrderItem&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderAddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;amazonOrderAddress&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;amazonOrderItem&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..impl.AmazonOrderItem&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;amazonOrderAddress&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..impl.AmazonOrderAddress&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>org.springframework.beans.factory.BeanFactory</code>是Spring IoC中最重要类，注释中的第一句话：<em>The root interface for accessing a Spring bean container.</em><br>BeanFactory接口，部分源码。其中注释中有句话很重要，<em>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> * This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanNameAware&#x27;s &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanClassLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanFactoryAware&#x27;s &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EnvironmentAware&#x27;s &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EmbeddedValueResolverAware&#x27;s &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ResourceLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationEventPublisherAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;MessageSourceAware&#x27;s &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationContextAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ServletContextAware&#x27;s &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom &#123;<span class="doctag">@code</span> init-method&#125; definition</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;DisposableBean&#x27;s &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom &#123;<span class="doctag">@code</span> destroy-method&#125; definition</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其中<code>prototype</code>, <code>singleton</code>是Spring Bean的scope的两个范围，其次还有<code>request</code>和<code>session</code>，这两个用的少</p>
<ul>
<li>prototype, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方</li>
<li>singleton，即单例，全局只有一个对象，这是Spring默认的scope</li>
</ul>
</blockquote>
<p>在拥有了BeanFactory之后, 我们将”生产图纸”交给BeanFactory, 让其为我们生产一个业务对象即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFacotry(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;YOUR_XML_PATH&quot;</span>));</span><br><span class="line">Order order = (Order) container.getBean(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">order.persistOrderData();</span><br></pre></td></tr></table></figure>
<p>或者使用ApplicationContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext container = <span class="keyword">new</span> ClassPathXmlApplication(<span class="string">&quot;YOUR_XML_PATH&quot;</span>);</span><br><span class="line">Order order = (Order) container.getBean(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">order.persistOrderData();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：不仅仅是XML这种格式，.json/.properties/.yml都可以当作配置文件来定义Bean，只要做好规范（接口）即可，对应<code>org.springframework.beans.factory.support.BeanDefinitionReader</code>接口，不同类型的配置文件就有了规范<br>XML定义的Bean最终被“翻译”为<code>BeanDefinition</code>的一个个的实例，将这些BeanDefinition进行实例化流程中，Spring加入了很多可扩展的地方，比如：PostProcessor</p>
</blockquote>
<ul>
<li>BeanFactoryPostProcessor，增强（修改）BeanDefination信息，在xml生成BeanDefinition阶段起作用</li>
<li>BeanPostProcessor，增强（修改）Bean信息，在Bean实例化阶段起作用</li>
<li>等等</li>
</ul>
<p>接下来，明确两个概念，一个是Instantiate（实例化），一个是Initialize（初始化），对应Python中的<code>__new__()</code>和<code>__init__()</code></p>
<ul>
<li>Instantiate，是调用构造方法，在堆中开辟一个内存空间，属性赋默认值。</li>
<li>Initialize，是调用init-method，为对象赋值，比如在XML中定义Bean的时候，指定init-method</li>
</ul>
<h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p>实现了FactoryBean接口的类，将作为一个Bean放入SpringIOC容器中，然后在某个地方调用FactoryBean.getObject()方法来进行对象的实例化。FactoryBean是Spring框架的一个扩展，方便用户自己灵活进行Bean的创建</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>这里额外介绍一下工厂模式. 在强调面向接口编程的同时, 有一点需要注意: <strong>虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合</strong>, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BarInterface barInterface;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们应该避免这样做</span></span><br><span class="line">        <span class="comment">// instance = new BarInterfaceImpl();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以上类Foo是由我们自定义的, 我们可以在其上<code>@Component</code>或者<code>@Service</code>纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BarInterface barInterface;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态工厂</span></span><br><span class="line">        <span class="comment">// barInterface = BarInterfaceFactory.getInterface()</span></span><br><span class="line">        <span class="comment">// 抽象工厂</span></span><br><span class="line">        <span class="comment">// barInterface = new BarInterfaceFactory().getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: &quot;解除耦合&quot;.</span></span><br></pre></td></tr></table></figure>
<p>在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...Foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;barInterface&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...StaticBarInterfaceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>factory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.</p>
<h2 id="容器背后的秘密"><a href="#容器背后的秘密" class="headerlink" title="容器背后的秘密"></a>容器背后的秘密</h2><p>Spring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段</p>
<blockquote>
<p>容器启动阶段: 加载配置 &gt; 分析配置信息 &gt; 装备到BeanDefinition &gt; 其他后处理 …</p>
</blockquote>
<ul>
<li>容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory<blockquote>
<p>Bean实例化阶段: 实例化对象 &gt; 装配依赖 &gt; 生命周期回调 &gt; 对象其他处理 &gt; 注册回调接口 …</p>
</blockquote>
</li>
<li>所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段</li>
</ul>
<p>第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.</p>
<blockquote>
<p>注：<a href="/2021/08/01/pattern-proxy-and-dynamic/" title="结合源码分析IOC容器的启动过程">结合源码分析IOC容器的启动过程</a></p>
</blockquote>
<h3 id="图纸装配"><a href="#图纸装配" class="headerlink" title="图纸装配"></a>图纸装配</h3><p>“图纸装配”从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -&gt; 将文件中的占位符替换 -&gt; 文件中的字符串进行类型装换<br>Spring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: </p>
<ul>
<li>PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.</li>
<li>CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.</li>
</ul>
<blockquote>
<p>插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer &gt; CustomEditorConfigurer &gt; …等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.</p>
</blockquote>
<h3 id="生产产品"><a href="#生产产品" class="headerlink" title="生产产品"></a>生产产品</h3><p>容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. </p>
<h4 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候, 采用”策略模式(Strategy Pattern)”来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.</p>
<p>按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object order = Class.forName(<span class="string">&quot;package.name.Order&quot;</span>).newInstance();</span><br><span class="line">Object orderItem = Class.forName(<span class="string">&quot;package.name.AmazonOrderItem&quot;</span>).newInstance();</span><br><span class="line">Object orderAddress = Class.forName(<span class="string">&quot;package.name.AmazonOrderAddress&quot;</span>).newInstace();</span><br><span class="line"></span><br><span class="line">BeanWrapper newOrder = <span class="keyword">new</span> BeanWrapperImpl(order);</span><br><span class="line">newOrder.setPropertyValue(<span class="string">&quot;newOrderItem&quot;</span>, orderItem);</span><br><span class="line">newOrder.setPropertyValue(<span class="string">&quot;newOrderAddress&quot;</span>, orderAddress);</span><br><span class="line"></span><br><span class="line">assertTrue(newOrder.getWrappedInstance() <span class="keyword">instanceof</span> Order);</span><br><span class="line">assertSame(order, newOrder.getWrappedInstance());</span><br><span class="line">assertSame(orderItem, newOrder.getPropertyValue(<span class="string">&quot;newOrderItem&quot;</span>));</span><br><span class="line">assertSame(orderAddress, newOrder.getPropertyValue(<span class="string">&quot;newOrderAddress&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperImpl</span> <span class="keyword">extends</span> <span class="title">AbstractNestablePropertyAccessor</span> <span class="keyword">implements</span> <span class="title">BeanWrapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapperImpl</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(object);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNestablePropertyAccessor</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyAccessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	Object wrappedObject;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getWrappedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Assert.state(<span class="keyword">this</span>.wrappedObject != <span class="keyword">null</span>, <span class="string">&quot;No wrapped object&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.wrappedObject;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractNestablePropertyAccessor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		registerDefaultEditors();</span><br><span class="line">		setWrappedInstance(object);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWrappedInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		setWrappedInstance(object, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWrappedInstance</span><span class="params">(Object object, <span class="meta">@Nullable</span> String nestedPath, <span class="meta">@Nullable</span> Object rootObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.wrappedObject = ObjectUtils.unwrapOptional(object);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, <span class="meta">@Nullable</span> Object value)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// ... 这里用了很多反射的方法.</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. </p>
<h4 id="给实例注入依赖对象"><a href="#给实例注入依赖对象" class="headerlink" title="给实例注入依赖对象"></a>给实例注入依赖对象</h4><p>上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.<br>比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.</p>
<h4 id="对实例进行前-后-置处理"><a href="#对实例进行前-后-置处理" class="headerlink" title="对实例进行前(后)置处理"></a>对实例进行前(后)置处理</h4><p>现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor.<br>BeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class="line"><span class="comment"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class="line"><span class="comment"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class="line"><span class="comment"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class="line"><span class="comment"> * applying to all beans created through this factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class="line"><span class="comment"> * or the like will implement &#123;<span class="doctag">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class="line"><span class="comment"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class="line"><span class="comment"> * implement &#123;<span class="doctag">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 10.10.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DestructionAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#addBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns the given &#123;<span class="doctag">@code</span> bean&#125; as-is.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class="line"><span class="comment">	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class="line"><span class="comment">	 * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class="line"><span class="comment">	 * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class="line"><span class="comment">	 * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns the given &#123;<span class="doctag">@code</span> bean&#125; as-is.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.</p>
<h4 id="InitialzingBean和init-method"><a href="#InitialzingBean和init-method" class="headerlink" title="InitialzingBean和init-method"></a>InitialzingBean和init-method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to be implemented by beans that need to react once all their properties</span></span><br><span class="line"><span class="comment"> * have been set by a &#123;<span class="doctag">@link</span> BeanFactory&#125;: e.g. to perform custom initialization,</span></span><br><span class="line"><span class="comment"> * or merely to check that all mandatory properties have been set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An alternative to implementing &#123;<span class="doctag">@code</span> InitializingBean&#125; is specifying a custom</span></span><br><span class="line"><span class="comment"> * init method, for example in an XML bean definition. For a list of all bean</span></span><br><span class="line"><span class="comment"> * lifecycle methods, see the &#123;<span class="doctag">@link</span> BeanFactory BeanFactory javadocs&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoked by the containing &#123;<span class="doctag">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class="line"><span class="comment">	 * and satisfied &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, &#123;<span class="doctag">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class="line"><span class="comment">	 * configuration and final initialization when all bean properties have been set.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class="line"><span class="comment">	 * essential property) or if initialization fails for any other reason</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InitializingBean的作用在于, 对象实例化调用过”BeanPostProcessor的前置处理”方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态.<br>但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的<code>&lt;bean&gt;</code>标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.</p>
<blockquote>
<p>到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.</p>
</blockquote>
<h4 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h4><p>同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在<code>&lt;bean&gt;</code>里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.</p>
<blockquote>
<p>容器不会去管理, scope为prototype类型的bean实例.</p>
</blockquote>
<h2 id="使用注解代替XML"><a href="#使用注解代替XML" class="headerlink" title="使用注解代替XML"></a>使用注解代替XML</h2><p>在XML配置成功的基础上, 引入了注解来减少冗余操作.<br><code>@Autowired</code>四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. <code>@Autowired</code>是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.</p>
<p>有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的<code>@Autowired</code>. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给<code>@Autowired</code>锁标注的属性或方法. 伪代码如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object[] beans = ...;</span><br><span class="line"><span class="keyword">for</span> (Objec bean: beans) &#123;</span><br><span class="line">    <span class="keyword">if</span>(autowiredExistsOnField(bean))&#123;</span><br><span class="line">        Field f = getQulifiedField(bean);</span><br><span class="line">        setAccessiableIfNeccessary(f);</span><br><span class="line">        f.set(getBeanByTypeFromContainer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(autowiredExistsOnMethod(bean)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前的<code>@Autowired</code>标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. <code>@Qualifier</code>实际上是byName自动绑定的注解版.</p>
<h4 id="classpath-scanning"><a href="#classpath-scanning" class="headerlink" title="classpath-scanning"></a>classpath-scanning</h4><p>到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了”一套代码, 一处定义”的理念, 要将革命进行彻底. classpath-scanning的诞生!<br>使用相应的注解(<code>@Component</code>, <code>@Service</code>, <code>@Configuration</code>)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器.<br>classpath-scanning由<code>&lt;context:component-scan&gt;</code>决定. <code>&lt;context:component-scan&gt;</code>默认扫描的注解时<code>@Component</code>. 其中, 在@Component语义的基础上细化后又有了<code>@Repository</code>, <code>@Service</code>/<code>@Controller</code>, 他们同样都会被扫描. <code>@Component</code>的语义更宽泛, 而<code>@Service</code>以及<code>@Repository</code>等更具体. 另外, 对于服务层类定义来说, 使用<code>@Service</code>标注它, 比<code>@Component</code>更加确切.</p>
<p>学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/08/22/serialization-deserialization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/22/serialization-deserialization/" class="post-title-link" itemprop="url">序列化和反序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-22 16:22:51" itemprop="dateCreated datePublished" datetime="2021-08-22T16:22:51+08:00">2021-08-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>序列化： 将数据结构或对象转换成二进制串的过程<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>
<h1 id="Java-Serialization"><a href="#Java-Serialization" class="headerlink" title="Java Serialization"></a>Java Serialization</h1><p>Serialization is the conversion of the state of an object into a byte stream; deserialization does the opposite.<br>Stated differently, serialization is the conversion of <strong>a Java object into a static stream (sequence) of bytes</strong> which can then be saved to a database or transferred over a network.</p>
<p>if further, reference:<br><a target="_blank" rel="noopener" href="https://snyk.io/blog/serialization-and-deserialization-in-java/">https://snyk.io/blog/serialization-and-deserialization-in-java/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/08/12/java-reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/12/java-reflection/" class="post-title-link" itemprop="url">Java反射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 17:46:37" itemprop="dateCreated datePublished" datetime="2021-08-12T17:46:37+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
<footer><strong>Oracle</strong></footer></blockquote>


<h1 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h1><p>简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members. Python对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。</p>
<p>反射应用的三种形式，总结起来分别是：</p>
<ol>
<li>运行时得到类的信息</li>
<li>类型转换</li>
<li>instanceof</li>
</ol>
<p>Java中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass方法，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。</p>
<p>以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。</p>
<p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<h2 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h2><p>Java创建对象有两种方式，一个是new，一个是反射<br>反射创建对象，第一步是获取Class，第二步获取构造器，第三步构造器newInstance()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;xxx.xxx&quot;</span>);</span><br><span class="line">Constructor ctor = class.getConstructor();</span><br><span class="line">clazz obj = ctor.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其中获取到Class有三种方式：</p>
<ul>
<li>Class.forName(“xxx.xxx”)</li>
<li>对象.getClass</li>
<li>类.Class<br>这三种方式没有性能区别<br><code>Class.forName(...).getContructor()</code>只能获取到<code>Member.PUBLIC</code>的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是<code>Member.PUBLIC</code>那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊</li>
</ul>
</blockquote>
<h2 id="Method-Invoke"><a href="#Method-Invoke" class="headerlink" title="Method Invoke"></a>Method Invoke</h2><p>在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the underlying method represented by this &#123;<span class="doctag">@code</span> Method&#125;</span></span><br><span class="line"><span class="comment"> * object, on the specified object with the specified parameters.</span></span><br><span class="line"><span class="comment"> * Individual parameters are automatically unwrapped to match</span></span><br><span class="line"><span class="comment"> * primitive formal parameters, and both primitive and reference</span></span><br><span class="line"><span class="comment"> * parameters are subject to method invocation conversions as</span></span><br><span class="line"><span class="comment"> * necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is static, then the specified &#123;<span class="doctag">@code</span> obj&#125;</span></span><br><span class="line"><span class="comment"> * argument is ignored. It may be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the number of formal parameters required by the underlying method is</span></span><br><span class="line"><span class="comment"> * 0, the supplied &#123;<span class="doctag">@code</span> args&#125; array may be of length 0 or null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is an instance method, it is invoked</span></span><br><span class="line"><span class="comment"> * using dynamic method lookup as documented in The Java Language</span></span><br><span class="line"><span class="comment"> * Specification, Second Edition, section 15.12.4.4; in particular,</span></span><br><span class="line"><span class="comment"> * overriding based on the runtime type of the target object will occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is static, the class that declared</span></span><br><span class="line"><span class="comment"> * the method is initialized if it has not already been initialized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the method completes normally, the value it returns is</span></span><br><span class="line"><span class="comment"> * returned to the caller of invoke; if the value has a primitive</span></span><br><span class="line"><span class="comment"> * type, it is first appropriately wrapped in an object. However,</span></span><br><span class="line"><span class="comment"> * if the value has the type of an array of a primitive type, the</span></span><br><span class="line"><span class="comment"> * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in</span></span><br><span class="line"><span class="comment"> * other words, an array of primitive type is returned.  If the</span></span><br><span class="line"><span class="comment"> * underlying method return type is void, the invocation returns</span></span><br><span class="line"><span class="comment"> * null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  the object the underlying method is invoked from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the arguments used for the method call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of dispatching the method represented by</span></span><br><span class="line"><span class="comment"> * this object on &#123;<span class="doctag">@code</span> obj&#125; with parameters</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> args&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalAccessException    if this &#123;<span class="doctag">@code</span> Method&#125; object</span></span><br><span class="line"><span class="comment"> *              is enforcing Java language access control and the underlying</span></span><br><span class="line"><span class="comment"> *              method is inaccessible.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalArgumentException  if the method is an</span></span><br><span class="line"><span class="comment"> *              instance method and the specified object argument</span></span><br><span class="line"><span class="comment"> *              is not an instance of the class or interface</span></span><br><span class="line"><span class="comment"> *              declaring the underlying method (or of a subclass</span></span><br><span class="line"><span class="comment"> *              or implementor thereof); if the number of actual</span></span><br><span class="line"><span class="comment"> *              and formal parameters differ; if an unwrapping</span></span><br><span class="line"><span class="comment"> *              conversion for primitive arguments fails; or if,</span></span><br><span class="line"><span class="comment"> *              after possible unwrapping, a parameter value</span></span><br><span class="line"><span class="comment"> *              cannot be converted to the corresponding formal</span></span><br><span class="line"><span class="comment"> *              parameter type by a method invocation conversion.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> InvocationTargetException if the underlying method</span></span><br><span class="line"><span class="comment"> *              throws an exception.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> NullPointerException      if the specified object is null</span></span><br><span class="line"><span class="comment"> *              and the method is an instance method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> ExceptionInInitializerError if the initialization</span></span><br><span class="line"><span class="comment"> * provoked by this method fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。</p>
<p>MethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/08/04/java-functional-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/04/java-functional-programming/" class="post-title-link" itemprop="url">Java函数式编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-04 11:10:25" itemprop="dateCreated datePublished" datetime="2021-08-04T11:10:25+08:00">2021-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做.<br>这正是我们在函数式编程中所看到的的.</p>
<p>函数是Java支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。<br>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。<br>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>像Java、Python对函数式编程提供部分支持。由于允许使用变量，因此，他们不是纯函数式编程语言。Haskell是一种纯函数式变成语言。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>从概念上来说, Lambda表达式, 生产的是函数, 而不是类<br>但是在JVM上, everything is a class, 但是经过各种幕后操作之后, <strong>使得Lambda看起来像函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IntCall</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntCallImpl</span> <span class="keyword">implements</span> <span class="title">IntCall</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arg * call(arg - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalPrograming</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> IntCall fact;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 传统方法实现 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntCallImpl intCall = <span class="keyword">new</span> IntCallImpl();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;oldApproach --&gt; &quot;</span> + intCall.call(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 函数式编程实现 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionalApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.</span></span><br><span class="line">    fact = n -&gt; n == <span class="number">0</span> ? <span class="number">1</span> : n * fact.call(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;functionalApproach --&gt; &quot;</span> + fact.call(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anonymousInnerClassApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntCall fact = IntCallImpl::call</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionalPrograming.oldApproach();</span><br><span class="line">    FunctionalPrograming.functionalApproach();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mehtod-References"><a href="#Mehtod-References" class="headerlink" title="Mehtod References"></a>Mehtod References</h1><p>方法引用的语法:</p>
<blockquote><p>A method reference is a class name or an object name, follow by a ::, then the name of the method </p>
</blockquote>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;X::f&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MarkString0</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MarkString1</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">make</span><span class="params">(X x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundMethodReferences</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// MarkString0 n = X::f                             [1]</span></span><br><span class="line">      X x = <span class="keyword">new</span> X();</span><br><span class="line">      MarkString0 n = x::f;   <span class="comment">// method references        [2]</span></span><br><span class="line">      System.out.println(n.make());</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      MarkString1 m = X::f;   <span class="comment">//unbound method references [3]</span></span><br><span class="line">      System.out.println(m.make(<span class="keyword">new</span> X()));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以<code>[2]</code>可以赋值成功, <code>[1]</code>不能. <code>[1]</code>这种方式, <code>class X</code>和<code>interface MarkString0</code>中都没有可以创建<code>X</code>的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References</p>
<h2 id="Unbound-Method-References"><a href="#Unbound-Method-References" class="headerlink" title="Unbound Method References"></a>Unbound Method References</h2><p>对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">This</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">three</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">four</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s, <span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call2</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreeArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call3</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiUnbound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TwoArgs twoargs = This::two;</span><br><span class="line">    ThreeArgs threeargs = This::three;</span><br><span class="line">    This athis = <span class="keyword">new</span> This();</span><br><span class="line">    twoargs.call2(athis, <span class="number">11</span>, <span class="number">3.14</span>);</span><br><span class="line">    threeargs.call3(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age = -<span class="number">1</span>; <span class="comment">// For &quot;unknown&quot;</span></span><br><span class="line">  Dog() &#123; name = <span class="string">&quot;stray&quot;</span>; &#125;</span><br><span class="line">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class="line">  Dog(String nm, <span class="keyword">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MakeNoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make1Arg</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make2Args</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorReference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MakeNoArgs mna = Dog::<span class="keyword">new</span>; <span class="comment">// [1]</span></span><br><span class="line">    Make1Arg m1a = Dog::<span class="keyword">new</span>;   <span class="comment">// [2]</span></span><br><span class="line">    Make2Args m2a = Dog::<span class="keyword">new</span>;  <span class="comment">// [3]</span></span><br><span class="line">    Dog dn = mna.make();</span><br><span class="line">    Dog d1 = m1a.make(<span class="string">&quot;Comet&quot;</span>);</span><br><span class="line">    Dog d2 = m2a.make(<span class="string">&quot;Ralph&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。</p>
<p>注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; x.toString()</span><br></pre></td></tr></table></figure>
<p>编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>
<p><strong>必须当Lambda表达式被指派给某个接口, 才能确定其类型</strong>. 比如: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FunctionalNoAnn</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@FunctionalInterface</span></span><br><span class="line"><span class="comment">interface NotFunctional &#123;</span></span><br><span class="line"><span class="comment">  String goodbye(String arg);</span></span><br><span class="line"><span class="comment">  String hello(String arg);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">产生错误信息:</span></span><br><span class="line"><span class="comment">NotFunctional is not a functional interface</span></span><br><span class="line"><span class="comment">multiple non-overriding abstract methods</span></span><br><span class="line"><span class="comment">found in interface NotFunctional</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">goodbye</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye, &quot;</span> + arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionalAnnotation fa =</span><br><span class="line">      <span class="keyword">new</span> FunctionalAnnotation();</span><br><span class="line">    Functional f = fa::goodbye;</span><br><span class="line">    FunctionalNoAnn fna = fa::goodbye;</span><br><span class="line">    <span class="comment">// Functional fac = fa; // Incompatible</span></span><br><span class="line">    Functional fl = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">    FunctionalNoAnn fnal = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中, <code>@FunctionalInterface</code>是一个可选注解, 没有也行.<br>通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释</p>
<blockquote><p>Look closely at what happens in the definitions of <code>f</code> and <code>fna</code>. Functional and<br>FunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.<br>First, this is only a method and not a class. Second, it’s not even a method of a class<br>that implements one of those interfaces. This is a bit of magic that was added to Java<br>8: if you assign a method reference or a lambda expression to a functional interface<br>(and the types fit), Java will adapt your assignment to the target interface. <strong>Under<br>the covers, the compiler wraps your method reference or lambda expression in an<br>instance of a class that implements the target interface.</strong></p>
<p>A @FunctionalInterface is also called a Single Abstract Method (SAM) type.</p>
<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>


<p>如果将Lambda表达式作为参数传入, 看流式编程中, <code>Stream.of(...).map((x, y) -&gt; x + y))</code>, 其中map方法接收了一个表达式. 查看其源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后, 再查看Function接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function  方法输入的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function 方法输出的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Function也可以看出其中只有一个抽象方法<code>apply</code>, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型<code>&lt;T, R&gt; </code>与之对应.</p>
<p>那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code>是为了检测, 以限制所注释的接口中只能有一个抽象方法.</p>
<p>在<code>java.util.function</code>中还有很多函数式接口, 这里就不在列举了.</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>其实就是生成函数的函数, 比如返回一个Lambda表达式.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, String&gt; <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s -&gt; s.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><p>一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure2</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeFun方法返回的IntSupplier将i和x进行了”close over”, 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.</p>
<p>此时, 考虑如下情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure3</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在编译时, x++ 和 i++ 都会报错</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; x++ + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Variable used in lambda expression should be final or effectively final</em><br>Lambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. </p>
<p>那么, 为什么呢?<br>考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    lambda(x, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      x++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.</p>
<h4 id="闭包的结论"><a href="#闭包的结论" class="headerlink" title="闭包的结论"></a>闭包的结论</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一切正常, 因为i是成员, 非局部.</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.</p>
<p>解释的更加仔细一点, 写了一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TargetInterface</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">apply</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">connect</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data + <span class="string">&quot;&lt;---&gt;&quot;</span> + data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferencesNature</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line">    TargetInterface t = tool::connect;</span><br><span class="line">    System.out.println(t.apply(<span class="string">&quot;you&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下这个示例反应了运行时生成字节码的伪代码, <code>$Example1</code>在目标接口和类之间搭建了一个桥梁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 示例: 自动生成的类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> $<span class="title">Example1</span> <span class="keyword">implements</span> <span class="title">TargetInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Tool tool;</span><br><span class="line">  $Example1(Tool tool) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tool = tool;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tool.connect(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与Method Reference是一样的(省略main方法声明)</span></span><br><span class="line">$Example1 example1 = <span class="keyword">new</span> $Example1(<span class="keyword">new</span> Tool());</span><br><span class="line">example1.apply(<span class="string">&quot;you&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时<code>Tool</code>类和<code>$Example1</code>都生成了, 所以Lambda和Method References是本质是一样的.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/08/01/pattern-proxy-and-dynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/01/pattern-proxy-and-dynamic/" class="post-title-link" itemprop="url">Java动态代理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-01 09:23:05" itemprop="dateCreated datePublished" datetime="2021-08-01T09:23:05+08:00">2021-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Pattern/" itemprop="url" rel="index"><span itemprop="name">Pattern</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Static-Proxy"><a href="#Static-Proxy" class="headerlink" title="Static Proxy"></a>Static Proxy</h1><p>一个代理机制，可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是<strong>直接</strong>发生的，而是通过代理完成。<strong>通过代理可以让调用者与实现者之间解耦。</strong></p>
<p>在代理模式中, 通常有这几种抽象概念：</p>
<ul>
<li>ISubject 该接口是对被访问资源的抽象</li>
<li>SubjectImpl 被访问资源的具体实现</li>
<li>SubjectProxy 被访问资源的代理实现</li>
<li>Client 访问者<br>SubjectImpl不会出现在SubjectProxy类中，取而代之的是ISubject被注入到SubjectProxy中，作为一个“桥梁”，就满足了调用者和实现者的解耦</li>
</ul>
<blockquote>
<p>没有代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ISubject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        String url = ...;</span><br><span class="line">        subject.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>增加了代理之后</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    ISubject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISubject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubjectProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="comment">// add pre-process logic if neccessary</span></span><br><span class="line">        String res = subject.request(url);</span><br><span class="line">        <span class="comment">// add post process logic if neccessary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Proxy:&quot;</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String url = ...;</span><br><span class="line">        <span class="comment">// 不直接使用SubjectImpl去调用，而是通过proxy去调用</span></span><br><span class="line">        ISubject proxy = SubjectProxy.getProxy();</span><br><span class="line">        proxy.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.</p>
<h1 id="Dynamic-Proxy"><a href="#Dynamic-Proxy" class="headerlink" title="Dynamic Proxy"></a>Dynamic Proxy</h1><p>如果接口和方法很多，那么我们要手写很多（静态）代理类，通过观察研究这些代理类，我们抽象出一个<strong>高阶代理类</strong>，这个类要有这样几种行为：</p>
<ul>
<li>public static Class<?> **getProxyClass**(ClassLoader loader, Class<?>… interfaces)</li>
<li>public static Object <strong>newProxyInstance</strong>(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
<li>public static InvocationHandler <strong>getInvocationHandler</strong>(Object proxy)<br>而动态代理的巧妙之处在于，可以在程序的运行期间，动态的生成不同的代理类且加载这个代理类再实例化，来完成相同的工作。<br>所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象. 在执行代码的过程中，动态生成了代理类 Class 的字节码byte[]，然后通过defineClass0 加载到JVM中，简要代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance</span><br><span class="line">    ProxyClassFactory.apply</span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>动态代理机制的实现，需要Proxy类和InvocationHandler接口. Proxy类是Java提供的，如果要利用动态代理处理业务，我们要做的就是写一个类实现InvocationHandler，比如，使用动态代理实现一个”request服务时间控制”功能:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCtrlInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestCtrlInvocationHandler</span><span class="params">(Objec target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Objec <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName.equal(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">            TimeOfDay startTime = <span class="keyword">new</span> TiemOfDay(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            TimeOfDay endTime = <span class="keyword">new</span> TiemOfDay(<span class="number">5</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">            TiemOfDay currentTime = <span class="keyword">new</span> TimeDay();</span><br><span class="line">            <span class="keyword">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Service is not available now.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;ISubject.class&#125;, <span class="keyword">new</span> RequestCtrlInvocationHandler(<span class="keyword">new</span> ISubjectImpl()));</span><br><span class="line">        <span class="comment">// 这里不增加doSomething方法了, 简单演示一下调用</span></span><br><span class="line">        String url = ...;</span><br><span class="line">        subject.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        handler.invoke(<span class="keyword">this</span>, ISubject.class.getMethod(<span class="string">&quot;request&quot;</span>, String.class), <span class="keyword">new</span> Object[]&#123;url&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的动态代理实现方式有两种：JDK原生实现和Cglib开源实现。日常业务能够使用jdk动态代理编码的场景非常少。Spring在5.X之前默认的动态代理实现一直是JDK动态代理。但是从5.X开始，Spring就开始默认使用Cglib来作为动态代理实现。并且SpringBoot从2.X开始也转向了Cglib动态代理实现。我们可以在源码中找到对应的线索，SpringAOP的顶级接口<code>org.springframework.aop.framework.AopProxy</code>，这个接口只有两个实现类</p>
<ul>
<li>CglibAopProxy</li>
<li>JdkDynamicAopProxy</li>
</ul>
<h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><ol>
<li>为什么要用 InvocationHandler？因为sun.misc.ProxyGenerator 在生成 Proxy 字节码 byte[]时，自然希望具体的方法实现是一个模式化的code，这样才方便自动生成代码。所以<strong>将差异化的逻辑转移到了InvocationHandler中</strong>。</li>
<li>为什么JDK动态代理只支持Interface的代理？如果只有SubjectImpl没有ISubject的话，就失去了代理模式的意义，不能通过ISubject将SubjectProxy和SubjectImpl解耦。</li>
</ol>
<h1 id="JDK动态代理分析"><a href="#JDK动态代理分析" class="headerlink" title="JDK动态代理分析"></a>JDK动态代理分析</h1><p>有必要动态代理的源码扒出来加固上边的分析过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** parameter types of a proxy class constructor */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler.class &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a cache of proxy classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">     * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment">     * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BiFunction</span>&lt;<span class="title">ClassLoader</span>, <span class="title">Class</span>&lt;?&gt;[], <span class="title">Class</span>&lt;?&gt;&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中这个newProxyInstance方法要注重说一下，大概分为四步：</p>
</blockquote>
<ul>
<li>第一步，先进行权限检测<code>checkProxyAccess</code>，主要是借助于<code>System.getSecurityManager().checkxxxPermission(...)</code>，其中权限主要涉及：文件，socket等</li>
<li>第二步，生产代理对象, <code>getProxyClass0(loader, intfs)</code>根据传入<code>newProxyInstance(...)</code>的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据<code>ProxyClassFactory</code>生产出一个代理对象，<code>ProxyClassFactory</code>是一个静态内部类, 其中代理对象的生成过程，主要涉及<code>apply(..)</code>中的<code>ProxyGenerator.generateProxyClass(proxyName...)</code>行(以下附上了<code>ProxyGenerator</code>的部分源码)，当我打开<code>generateProxyClass</code>方法的源码才恍然大悟，<code>generateClassFile()</code>在内存中生成一个class类(文件一般不保存, 类名一般叫做<code>$Proxy0</code>)，来定义代理类.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，根据第二步生成的代理类，调用<code>cl.getConstructor(&#123; InvocationHandler.class &#125;)</code>, 相当于调用了代理类的构造方法, 在通过构造器调用<code>cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))</code>，最终强制转换ISubject对象。</li>
<li>第四步，当代理对象调用<code>ISubject</code>的<code>request</code>时，首先进入<code>RequestCtrlInvocationHandler</code>的invoke方法，在该方法的最后，通过method.invoke(…)来真正调用<code>ISubjectImpl.request</code></li>
</ul>
<h1 id="Cglib动态代理分析"><a href="#Cglib动态代理分析" class="headerlink" title="Cglib动态代理分析"></a>Cglib动态代理分析</h1><p>JDK动态代理必须让SubjectImpl实现某个接口，也就是基于接口代理（interface-based proxies），有局限性。</p>
<blockquote>
<p>注：CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。<br>CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
</blockquote>
<p>如果可以生成一个子类继承SubjectImpl，子类重写父类的方法，将子类注入代理类中，通过子类调用父类的方法来实现代理，这就是Cglib动态代理（subclass-based proxies）。<br>使用SpringBoot时，如果Subject实现了某个接口就会使用JDK动态代理，如果实现任何接口就会使用CGLIB动态代理。我们可以在启动类上<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>进行全局配置。<br>Spring框架中的Cglib动态代理，源码在org.springframework.cglib.proxy包下，也有对应的Proxy类和InvocationHandler接口。<br>这里我们只需要Subject类，代理它的request方法，在运行期间生成的代理类也就是子类，部分反编译的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$5889<span class="title">ab8</span> <span class="keyword">extends</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">SpringProxy</span>, <span class="title">Advised</span>, <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line">  <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$request$<span class="number">0</span>$Method;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$request$<span class="number">0</span>$Proxy;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK229() &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    Class var0 = Class.forName(<span class="string">&quot;com.xxx.xxx.Subject$$EnhancerBySpringCGLIB$$5889ab8&quot;</span>);</span><br><span class="line">    Class var1;</span><br><span class="line">    Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)).getDeclaredMethods());</span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line">    CGLIB$request$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;request&quot;</span>, <span class="string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.ficc.numtalk.scheduled.Subject&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">    CGLIB$request$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()V&quot;</span>, <span class="string">&quot;request&quot;</span>, <span class="string">&quot;CGLIB$request$0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">      <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$request$<span class="number">0</span>$Method, CGLIB$emptyArgs, CGLIB$request$<span class="number">0</span>$Proxy);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.request();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error | RuntimeException var1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/07/24/java-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/24/java-annotation/" class="post-title-link" itemprop="url">Java注解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-24 10:31:14" itemprop="dateCreated datePublished" datetime="2021-07-24T10:31:14+08:00">2021-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.<br>定义注解的语法看起来就像在定义一个接口.</p>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><p>定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。</p>
<p>注解不支持继承.</p>
<p>有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在哪个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:<br>有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。</p>
<p>那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：</p>
<img  src=http://www.plantuml.com/plantuml/svg/BOsn2WCn34DtVuN6TWdNDPbkA5tl5qnYsi3X5CUbtD_NXHEI9l4qdSs9CexnCSoeAgYZII4oUGjxniOs1QmDTtMnGWXbf9JAkS7trNV1PLKTpjw7OhDHPSwkp-iVlohlnqbvY8gnnqN6RLd2aVWJRJy0>

<p>在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。</p>
<h2 id="Using-javac-to-Process-Annotations"><a href="#Using-javac-to-Process-Annotations" class="headerlink" title="Using javac to Process Annotations"></a>Using javac to Process Annotations</h2><p>自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。</p>
<p>如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到<code>Annotation Processor</code>, 具体的做法是继承AbstractProcessor, 然后实现其process方法.</p>
<p>Annotation Processor机制是什么？.<br>如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。</p>
<h2 id="Runtime-Annotations-Processing"><a href="#Runtime-Annotations-Processing" class="headerlink" title="Runtime Annotations Processing"></a>Runtime Annotations Processing</h2><p>在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。</p>
<p>比如，通过自定义注解@Query(…)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criteria.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> com.lee.annotation.Query;</span><br><span class="line"><span class="keyword">import</span> com.lee.config.mybatis.SimpleQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guomaoqing907</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryHelpForMybatis</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, Q&gt; <span class="function">SimpleQueryWrapper&lt;T&gt; <span class="title">getQueryCondition</span><span class="params">(Q query)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleQueryWrapper&lt;T&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;SimpleQueryWrapper&lt;T&gt;&gt;();</span><br><span class="line">    SimpleQueryWrapper&lt;T&gt; qw = <span class="keyword">new</span> SimpleQueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (query == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> qw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Field&gt; fields = getAllFields(query.getClass(), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> accessible = field.isAccessible();</span><br><span class="line">        <span class="comment">// 设置对象的访问权限，保证对private的属性的访</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Query q = field.getAnnotation(Query.class);</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String propName = q.propName();</span><br><span class="line">          String joinName = q.joinName();</span><br><span class="line">          <span class="comment">// 不支持join表的条件，需要在具体查询接口处另作处理</span></span><br><span class="line">          <span class="keyword">if</span> (!isBlank(joinName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          String blurry = q.blurry();</span><br><span class="line">          String attributeName = isBlank(propName) ? field.getName() : propName;</span><br><span class="line">          <span class="keyword">boolean</span> sortType = q.sortType();</span><br><span class="line">          Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">          Object val = field.get(query);</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtil.isNull(val) || <span class="string">&quot;&quot;</span>.equals(val) || ObjectUtil.isEmpty(val)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 模糊多字段</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectUtil.isNotEmpty(blurry)) &#123;</span><br><span class="line">            String[] blurrys = blurry.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            List&lt;SimpleQueryWrapper&lt;T&gt;&gt; conditionChain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> 如何实现 (a like &#x27;..&#x27; or b like &#x27;..&#x27; or c like &#x27;..&#x27;) and d = &#x27;..&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> (String s : blurrys) &#123;</span><br><span class="line">              qw.or().like(s, val.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">switch</span> (q.type()) &#123;</span><br><span class="line">            <span class="keyword">case</span> EQUAL:</span><br><span class="line">              qw.eq(attributeName, val);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREATER_THAN:</span><br><span class="line">              qw.and(obj -&gt; obj.ge(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LESS_THAN:</span><br><span class="line">              qw.and(obj -&gt; obj.le(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LESS_THAN_NQ:</span><br><span class="line">              qw.and(obj -&gt; obj.lt(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> INNER_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.like(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.likeLeft(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.likeRight(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IN:</span><br><span class="line">              List valList = (ArrayList) val;</span><br><span class="line">              Object[] objArray = valList.toArray();</span><br><span class="line">              qw.and(obj -&gt; obj.in(attributeName, objArray));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_EQUAL:</span><br><span class="line">              qw.and(obj -&gt; obj.ne(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_NULL:</span><br><span class="line">              qw.and(obj -&gt; obj.isNotNull(attributeName));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IS_NULL:</span><br><span class="line">              qw.and(obj -&gt; obj.isNull(attributeName));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BETWEEN:</span><br><span class="line">              List&lt;Object&gt; between = <span class="keyword">new</span> ArrayList&lt;&gt;((List&lt;Object&gt;) val);</span><br><span class="line">              qw.and(obj -&gt; obj.between(attributeName, between.get(<span class="number">0</span>), between.get(<span class="number">1</span>)));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SORT:</span><br><span class="line">              List valListSort = (ArrayList) val ;</span><br><span class="line">              Object[] objArraySort = valListSort.toArray();</span><br><span class="line">              <span class="keyword">if</span>(valListSort.toString().split(<span class="string">&quot;,&quot;</span>).length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                Object object = <span class="string">&quot;asc&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (objArraySort[<span class="number">1</span>].equals(object))&#123;</span><br><span class="line">                   qw.orderBy(<span class="keyword">true</span>, <span class="keyword">true</span>, objArraySort[<span class="number">0</span>].toString());</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  qw.orderBy(<span class="keyword">true</span>, <span class="keyword">false</span>, objArraySort[<span class="number">0</span>].toString());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                String[] stringsSort;</span><br><span class="line">                <span class="keyword">for</span> (Object objectSort : objArraySort)&#123;</span><br><span class="line">                  stringsSort=objectSort.toString().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (stringsSort[<span class="number">1</span>].equals(<span class="string">&quot;asc&quot;</span>))&#123;</span><br><span class="line">                    qw.orderBy(<span class="keyword">true</span>, <span class="keyword">true</span>, stringsSort[<span class="number">0</span>]);</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    qw.orderBy(<span class="keyword">true</span>, <span class="keyword">false</span>, stringsSort[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        field.setAccessible(accessible);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strLen;</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="keyword">null</span> || (strLen = cs.length()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Character.isWhitespace(cs.charAt(i))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Field&gt; <span class="title">getAllFields</span><span class="params">(Class clazz, List&lt;Field&gt; fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));</span><br><span class="line">      getAllFields(clazz.getSuperclass(), fields);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fields;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2021/07/03/pattern-factory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/03/pattern-factory/" class="post-title-link" itemprop="url">抽象工厂</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-03 20:01:57" itemprop="dateCreated datePublished" datetime="2021-07-03T20:01:57+08:00">2021-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Pattern/" itemprop="url" rel="index"><span itemprop="name">Pattern</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态工厂"><a href="#动态工厂" class="headerlink" title="动态工厂"></a>动态工厂</h1><blockquote><p>Factories: Encapsulating Object Creation</p>
<p>A Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.</p>
<footer><strong>Bruce Eckel</strong><cite>On Java 8</cite></footer></blockquote>
<p><strong>工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.</strong></p>
<p>静态工厂简单, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.<br>那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后<code>xxx.getNewInstance()</code>, 例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Shape <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">create</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Shape)</span><br><span class="line">          Class.forName(<span class="string">&quot;package.name.&quot;</span> + type).getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.getLocalizedMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shape s = <span class="keyword">new</span> DynamicFactory().create(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">    System.out.println(s.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>抽象工厂是在工厂的基础上又封装了一层, 即将”工厂”对象作为参数传入，然后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  Supplier&lt;Player&gt; player;</span><br><span class="line">  Supplier&lt;Obstacle&gt; obstacle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  ConcreteFactory() &#123;</span><br><span class="line">    player = Player1::<span class="keyword">new</span>;</span><br><span class="line">    obstacle = Obstacle1::<span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Player p;</span><br><span class="line">  <span class="keyword">private</span> Obstacle ob;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getInstance</span><span class="params">(AbstractFactory factory)</span> </span>&#123;</span><br><span class="line">    p = factory.player.get();</span><br><span class="line">    ob = factory.obstacle.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">The Rings</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
