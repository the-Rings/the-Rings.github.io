<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何洞察本质</title>
    <url>/2022/04/16/How-to-gain-insight-into-the-essence/</url>
    <content><![CDATA[<p>很多人在看热点新闻评论时，总会觉得自己像个二傻子，因为他看到每一派的观念，都觉得说得对，说得好，说得有理。到最后把自己搞的精神分裂，骑在墙头左右为难。比如监管游戏行业、出于何种目的考虑取缔校外教培行业、要不要支持我们应该如何看待饭圈文化等等。</p>
<p>如果你看一个问题，最后总是选择了貌似公允的各打五十大板，并试图通过自己都没搞明白的辩证逻辑来安慰自己。这是允执厥中的中庸之道。</p>
<p><strong>那么这里可能存在很大的误会。因为你可能并不是允执厥中，而是压根儿没有自己的观点。真正的大师一般观点鲜明，很少骑墙。</strong></p>
<p><strong>出现骑墙的最大可能是，你没有价值观！</strong></p>
<p>价值观缺失，是因为没有找到自己的逻辑原点。我们所有的观念都源于一个原点，这就是底层价值。它类似于几何中的公理系统，比如两点之间直线最短，比如凡是直角都相等这些自明的理论。只有当我们根植于这些底层价值观并依托底层价值观对一个问题做出推导和判断时，我们才可以形成自己的逻辑体系。</p>
<p>比如过夜饭圈文化，一个你认为的弱智顶流饭圈。女孩儿有疯狂追捧的自由吗？而他们的追星的自由边界在哪里？在这个思考的过程中，你会逐步追溯到自由的边界这个原点。</p>
<p>当你认为顶流靠脸吃饭的小鲜肉赚几个亿，而你辛辛苦苦月薪和我一样2800的时候，你就会追溯到诺奇克和罗尔斯关于天赋和公平的理论。你会认识到诺奇克说得更符合逻辑，其实脸就是天赋。</p>
<p>比如，在分析监管游戏行业到底应不应该这个问题上，我们会考虑到儿童到底具不具备自由意志这个问题。多少岁的儿童可以默认为无自由意志，而对于无自由意志的儿童，我们如何通过父权意志对其进行管理等问题。比如在分析取缔校外教排行业的问题时，我们可以考虑教配行业到底有没有导致内卷，如何定义内卷，内卷和市场正当竞争的区别是什么?</p>
<p>在对这个问题进行深入思考中，我们会逐步认识到：内卷是没有增量而在系统内做低水平重复的一种行为。而竞争是产生增量并且突破现有系统的一个过程。<br>我们如果用这个底层价值去衡量校外教育培训，是内卷还是正当的竞争，思路就会非常清晰。</p>
<p>再比如，关于安乐死的问题，如果你反对安乐死，你依据的价值观可能是宗教信仰，儒家孝道或者生命第一原则等等。而如果你赞同安乐死，你依据的价值观可能是个人主义，个人对自己的生命具备完全的主导权这个原则不同的底层价值观会导致对一个命题完全不同的判断。</p>
<p>而大多数问题追溯到最后，我们都会来到一堵墙边，这个墙就是我们最底层的价值观，是我们的逻辑原点，它类似于电脑的操作系统，在这个操作系统上只能搭载符合这个操作系统的软件。</p>
<p>这个思想操作系统大概有几个类型，我简单归纳如下，</p>
<ol>
<li>集体主义和个人主义的区别。</li>
<li>自由市场和监管主义的区别。</li>
<li>古典自由主义和新自由主义的区别。</li>
<li>自由意志和父系意志的区别，这里不做展开。</li>
</ol>
<p>有些人说观念没有对错，只有阐释的立场不同。尼采也说过：没有本质，只有对本质的阐释。这个说法在某些角度是对的。</p>
<p>在不同的观念冲突中，只有保留了多元的观点，才能对事实做出清晰的认知。</p>
<p>但是，现代文明也形成了一些基本的价值共识。这些共识除了逻辑的先验性，更是靠无数的历史经验总结而来。<br>当你违背了这些思想，就会对文明构成巨大的损害，比如古典自由主义原则，比如保障个体的自由、财产、生命的人。比如自由意志的原则等等。</p>
<p>只有我们找到我们观念中的逻辑起点，价值起点，道德起点，才能在纷杂繁琐的社会问题中拨云见日，洞察本质。</p>
]]></content>
      <categories>
        <category>Thought</category>
      </categories>
  </entry>
  <entry>
    <title>回溯在项目中的一次应用</title>
    <url>/2022/07/20/backtrack-practical-application/</url>
    <content><![CDATA[<p>某自动化测试的项目，对于某个接口的测试，事先准备好了测试用例。比如，HTTP调用某个API接口的URL，其中需要几个参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: &quot;James&quot;, &quot;$James&quot;, &quot;123&quot;, &quot;-1&quot;, &quot;&quot;</span><br><span class="line">date: &quot;2020-07-01&quot;, &quot;2020/07/01&quot;, &quot;2020.07&quot;, &quot;&quot;</span><br><span class="line">is_admin: &quot;false&quot;, &quot;true&quot;, &quot;&quot;, &quot;/&quot;</span><br><span class="line">tags: &quot;[&#x27;stuff&#x27;, &#x27;&#x27;, &#x27;manager&#x27;]&quot;, &quot;[]&quot;, &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>此时需要对以上4个参数进行随机组合，接口可以传递的参数个数是0-4个，每个参数随机选择其后取值范围中的一个值来模拟调用。<br>例如，可能的情况是有600种</p>
<ol>
<li><code>&#123;name: &quot;123&quot;, date: &quot;2020-07-01&quot;, &quot;is_admin&quot;: &quot;true&quot;, tags: &quot;&quot;&#125;</code></li>
<li><code>&#123;name: &quot;&quot;, date: &quot;2020.07&quot;, is_admin: &quot;false&quot;&#125;</code></li>
<li><code>&#123;name: &quot;James&quot;, date: &quot;2020-07-01&quot;&#125;</code></li>
<li><code>...</code><br>…</li>
<li><code>&#123;&#125;</code></li>
</ol>
<p>以上问题可以抽象出一个模型出来，有m堆小球，每堆都有n个不同的小球，第一阶段先确定从哪几堆中取，第二阶段每堆取一个，一共有多少种取法，并把所有的组合罗列出来？</p>
<p>穷举问题可以使用“回溯”，第一阶段可以抽象为求集合的全部子集（0-1背包问题），第二阶段在第一阶段基础上确定了某个子集，一次对子集中对应堆的小球每个从中取一个（K阶段决策模型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 有m个key，每个key有m个值，如何列出所有的k-v组合？</span></span><br><span class="line"><span class="comment">   * 例如：</span></span><br><span class="line"><span class="comment">   * &#123;</span></span><br><span class="line"><span class="comment">   *    a: [1, 2, 3],</span></span><br><span class="line"><span class="comment">   *    b: [4, 5, 6],</span></span><br><span class="line"><span class="comment">   *    c: [7, 8, 9],</span></span><br><span class="line"><span class="comment">   *    d: [!, @, #],</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * 第一步：先获得参数名的子集</span></span><br><span class="line"><span class="comment">   * 第二步：根据某个参数名的组合（例如：&#123;b, c&#125;），从b对应的[4, 5, 6]中任选出一个值，从c对应的[7, 8, 9]中任选出一个值，</span></span><br><span class="line"><span class="comment">   * 拼出3*3=9中不同的组合输出</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Map&lt;String, List&lt;String&gt;&gt; valuesMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; paramsSubset(List&lt;String&gt; keys) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack_p(keys, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack_p</span><span class="params">(List&lt;String&gt; keys, <span class="keyword">int</span> k, List&lt;String&gt; path, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == keys.size()) &#123;</span><br><span class="line">      result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack_p(keys, k+<span class="number">1</span>, path, result);</span><br><span class="line">    path.add(keys.get(k));</span><br><span class="line">    backtrack_p(keys, k+<span class="number">1</span>, path, result);</span><br><span class="line">    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Map&lt;String, String&gt;&gt; assign(List&lt;String&gt; params) &#123;</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack_v(params, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack_v</span><span class="params">(List&lt;String&gt; params, <span class="keyword">int</span> k, List&lt;String&gt; path, List&lt;Map&lt;String, String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == params.size()) &#123;</span><br><span class="line">      Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">        hashMap.put(params.get(i), path.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">      result.add(hashMap);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = valuesMap.get(params.get(k)).size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      path.add(valuesMap.get(params.get(k)).get(i));</span><br><span class="line">      backtrack_v(params, k+<span class="number">1</span>, path, result);</span><br><span class="line">      path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; combine(List&lt;String&gt; keys) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; paramResult = paramsSubset(keys);</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; finalResult = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramResult.size(); i++) &#123;</span><br><span class="line">      finalResult.addAll(assign(paramResult.get(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    solution.valuesMap.put(<span class="string">&quot;a&quot;</span>, Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>));</span><br><span class="line">    solution.valuesMap.put(<span class="string">&quot;b&quot;</span>, Arrays.asList(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>));</span><br><span class="line">    solution.valuesMap.put(<span class="string">&quot;c&quot;</span>, Arrays.asList(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>));</span><br><span class="line">    solution.valuesMap.put(<span class="string">&quot;d&quot;</span>, Arrays.asList(<span class="string">&quot;!&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; r = solution.combine(<span class="keyword">new</span> ArrayList&lt;&gt;(solution.valuesMap.keySet()));</span><br><span class="line">    System.out.println(r.toString());</span><br><span class="line">    System.out.println(r.size());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>布尔代数</title>
    <url>/2022/01/24/boolean-algebra/</url>
    <content><![CDATA[<h3 id="十进制小数转化为二进制数"><a href="#十进制小数转化为二进制数" class="headerlink" title="十进制小数转化为二进制数"></a>十进制小数转化为二进制数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res, bit_count, max_length = <span class="number">0</span>, <span class="number">0</span>, <span class="number">36</span></span><br><span class="line">binary_number_str = <span class="string">&quot;0.&quot;</span></span><br><span class="line"><span class="keyword">while</span> bit_count &lt;= max_length:</span><br><span class="line">    bit_count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> res + <span class="number">2</span>**(-bit_count) &gt; <span class="number">1</span>/<span class="number">10</span>:</span><br><span class="line">        binary_number_str += <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        binary_number_str += <span class="string">&quot;1&quot;</span></span><br><span class="line">        res += <span class="number">2</span>**(-bit_count)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(binary_number_str, res)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>滑动窗口的一次应用</title>
    <url>/2022/12/12/continuous-addition/</url>
    <content><![CDATA[<h2 id="累加序列"><a href="#累加序列" class="headerlink" title="累加序列"></a>累加序列</h2><p>Review同事的代码发现一段关于累加的代码，场景大概是这样的：<br>日期对应数值序列，现在要累加这些指标，计算出每一天往前推3天的总和，画出一个折线图，并要求可以配置累加天数。举个例子，如果今天是周四，那么今天应该计算周一到周三的指标总和，今天是周五的话，要计算周二到周四的总和。<br>我看了他的代码，他是这样处理的：整体是两次for循环，外层循环遍历整个序列，内层循环向前倒序遍历3次做累加，然后输出结果值，然后外层循环+1，整体的时间复杂度是O(3n)，虽说可以近似为O(n)，但是直觉告诉我有优化的空间，可以一趟遍历得到答案。<br>通过分析过程发现，同事的代码，上一次计算和下一次计算累加的过程有重叠的。周四=周三+周二+周一，周五=周四+周三+周二，三个值计算还行，如果要累加30天，这样就重复计算了28天的数据。我给出了以下优化后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] continuousAddition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> count) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n - count - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (count &gt; n) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; count) &#123;</span><br><span class="line">      sum += arr[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    res[p - count] = sum;</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">      <span class="comment">// 只计算首尾，减去第一天，加上最后一天</span></span><br><span class="line">      sum = sum + arr[p - <span class="number">1</span>] - arr[p - <span class="number">1</span> - count];</span><br><span class="line">      res[p - count] = sum;</span><br><span class="line">      p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Cross-Origin Resource Sharing</title>
    <url>/2022/06/22/cors/</url>
    <content><![CDATA[<p>所有跨域问题一文讲清楚</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<blockquote>
<p>跨源资源共享 (CORS)（或通俗地译为跨域资源共享）是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的”预检(preflight)”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p>
</blockquote>
<blockquote>
<p>跨源 HTTP 请求的一个例子：运行在 <a href="https://domain-a.com/">https://domain-a.com</a> 的 JavaScript 代码使用 XMLHttpRequest 来发起一个到 <a href="https://domain-b.com/data.json">https://domain-b.com/data.json</a> 的请求。</p>
</blockquote>
<blockquote>
<p>出于安全性，浏览器限制脚本内发起的跨源 HTTP 请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非响应报文包含了正确 CORS 响应头。</p>
</blockquote>
<p>注：preflight(预检)请求是一个OPTIONS方法的请求，如果OPTIONS请求得到了正确的响应头，那么浏览器就认为可以跨域。所以解决跨域问题有两种思路，一种是部署在同一个域，第二种是让OPTIONS请求带上“正确”的响应头。通常大家都采用第二种方式，比如，在后端gateway中配置corsFilter，让所有的请求都都加上正确的响应头。</p>
]]></content>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows配置安装虚拟机以及Docker等相关应用的镜像</title>
    <url>/2022/01/22/docker-images-install/</url>
    <content><![CDATA[<h1 id="Vagrant-Install"><a href="#Vagrant-Install" class="headerlink" title="Vagrant Install"></a>Vagrant Install</h1><p>virtual box和vagrant配合比vmware更加有效率<br>官网即可下载两个工具，不需要配置任何环境变量（注意打开BIOS中的虚拟化功能才能使用virtual box，一般都是默认打开的）</p>
<ol>
<li><p>vagrant可以快速下载镜像并创建虚拟机，先去vagrantup上搜索镜像，找到镜像名，找一个干净的文件夹，执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd target_dir</span><br><span class="line">vagrant init centos/7 </span><br><span class="line"><span class="meta">#</span><span class="bash"> vagrant init centos/7 https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加上国内的mirros加速下载</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动并进入虚拟机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vagrant up</span><br><span class="line">vagrant ssh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果修改了配置文件等相关信息，就要使用`vagrant reload`优雅地重启虚拟机</span></span><br></pre></td></tr></table></figure>
<p>此时，可以在virtual box工具中看到这个虚拟机，但是整个过程中无需在virtual box进行操作</p>
</li>
<li><p>替换国内repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">sudo curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure></li>
<li><p>编辑Vagrantfile，使用网络地址转换(NAT)模式，是虚拟机成为宿主机的一部分<br>执行vagrant up后就会在当前文件夹生成一个Vagrantfile文件，这个文件不能挪动位置<br>为虚拟机指定ip能使主机和虚拟机便捷通信，首先查看主机ipconfig的配置”VirtualBox Host-Only Network”项对应的ip，<br>VirtualBox的ip与虚拟机的ip必须保持在同一个网段，编辑Vagrantfile文件的行，假设VirtualBox的ip为192.168.56.1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>如果要进行局域网访问，使虚拟机成为一台在局域网中独立的机器(桥接模式)，放弃第4步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config.vm.network &quot;public_network&quot;, bridge: &quot;Intel(R) Ethernet Connection (16) I219-V&quot;</span><br></pre></td></tr></table></figure>
<p>注意：这里的bridge网桥，通过在宿主机上执行<code>ipconfig /all</code>，查看当前的网络适配器，如果你使用网线接入，安装了VirtaulBox，那么你会看到两个网络适配器，一个是宿主机真实的网卡，一个是虚拟网卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以太网适配器 以太网 2:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Intel(R) Ethernet Connection (16) I219-V</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 98-8F-E0-64-DE-43</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 否</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   IPv6 地址 . . . . . . . . . . . . : 2408:8256:2e80:838:db54:b1d5:b1ef:458(首选)</span><br><span class="line">   临时 IPv6 地址. . . . . . . . . . : 2408:8256:2e80:838:98c3:3136:3976:e052(首选)</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::c40b:5832:8a7e:4841%14(首选)</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.1.2(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . : fe80::1%14</span><br><span class="line">                                       192.168.1.1</span><br><span class="line">   DHCPv6 IAID . . . . . . . . . . . : 127438816</span><br><span class="line">   DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-2B-B4-BB-F6-98-8F-E0-64-DE-43</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : fe80::1%14</span><br><span class="line">                                       22.8.33.100</span><br><span class="line">                                       114.114.114.114</span><br><span class="line">   TCPIP 上的 NetBIOS  . . . . . . . : 已启用</span><br><span class="line"></span><br><span class="line">以太网适配器 以太网 3:</span><br><span class="line"></span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : VirtualBox Host-Only Ethernet Adapter</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 0A-00-27-00-00-0C</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 否</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line">   本地链接 IPv6 地址. . . . . . . . : fe80::6824:2664:4b:f79e%12(首选)</span><br><span class="line">   IPv4 地址 . . . . . . . . . . . . : 192.168.1.4(首选)</span><br><span class="line">   子网掩码  . . . . . . . . . . . . : 255.255.255.0</span><br><span class="line">   默认网关. . . . . . . . . . . . . :</span><br><span class="line">   DHCPv6 IAID . . . . . . . . . . . : 805961767</span><br><span class="line">   DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-2B-B4-BB-F6-98-8F-E0-64-DE-43</span><br><span class="line">   DNS 服务器  . . . . . . . . . . . : 22.8.33.100</span><br><span class="line">                                       114.114.114.114</span><br><span class="line">   TCPIP 上的 NetBIOS  . . . . . . . : 已启用</span><br><span class="line"></span><br><span class="line">无线局域网适配器 WLAN:</span><br><span class="line"></span><br><span class="line">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span><br><span class="line">   连接特定的 DNS 后缀 . . . . . . . :</span><br><span class="line">   描述. . . . . . . . . . . . . . . : Realtek RTL8852BE WiFi 6 802.11ax PCIe Adapter</span><br><span class="line">   物理地址. . . . . . . . . . . . . : 9C-2F-9D-AA-1D-FF</span><br><span class="line">   DHCP 已启用 . . . . . . . . . . . : 是</span><br><span class="line">   自动配置已启用. . . . . . . . . . : 是</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用<code>netsh interface show interface</code>查看，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管理员状态     状态           类型             接口名称</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">已启用            已连接            专用               以太网 2</span><br><span class="line">已启用            已连接            专用               以太网 3</span><br><span class="line">已启用            已断开连接          专用               WLAN</span><br></pre></td></tr></table></figure>
<p>此时，如果拔掉网线，发现“以太网2”断开连接，但是“以太网3”仍然是保持连接。<br>“Intel(R) Ethernet Connection (16) I219-V” 是您计算机上的真实物理网卡，而 “VirtualBox Host-Only Ethernet Adapter” 则是虚拟机软件 VirtualBox 创建的虚拟网络适配器。<br>“Intel(R) Ethernet Connection (16) I219-V” 是一种常见的物理网卡，用于连接计算机到物理网络，例如通过有线连接到路由器或交换机。<br>“VirtualBox Host-Only Ethernet Adapter” 是 VirtualBox 虚拟机软件创建的虚拟网络适配器，用于虚拟机之间或者虚拟机与主机之间的通信。所以，它不会断。</p>
</li>
<li><p>测试局域网连通性</p>
</li>
</ol>
<ul>
<li>虚拟机执行<code>ip addr</code>查看ip，一般是<code>eth1</code>中的<code>inet</code></li>
<li>无论是，宿主机ping虚拟机，还是虚拟机ping局域网的其他机器，应该都是通的。</li>
</ul>
<h1 id="Docker-install"><a href="#Docker-install" class="headerlink" title="Docker install"></a>Docker install</h1><p>下载路径<a href="https://docs.docker.com/">https://docs.docker.com</a> &gt; Get Docker &gt; Docker Engine &gt; Install On CentOS<br>读文档只选择重要的步骤：</p>
<ol>
<li>删除旧docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li>
<li>配置repo<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure></li>
<li>启动docker<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置开机启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li>
<li>配置阿里云docker镜像加速<br>登录阿里云 &gt; 控制台 &gt; 产品与服务 &gt; 容器服务 &gt; 容器镜像服务 &gt; 镜像工具 &gt; 镜像加速器 &gt; CentOS &gt; 配置镜像加速</li>
</ol>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol>
<li>登录docker hub &gt; 搜索mysql<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo docker images 查看本地镜像</span></span><br></pre></td></tr></table></figure></li>
<li>启动容shell器，并配置端口映射、挂载文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>
注：</li>
</ol>
<p>-p 是将容器的3306映射到主机的3306<br>-v /mydata/mysql/log:/var/log/mysql 将日志文件挂载到主机<br>-e 初始化root用户密码</p>
<ol start="3">
<li>查看容器启动情况<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker ps</span><br></pre></td></tr></table></figure></li>
<li>进入docker容器内部查看<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it [container-id] /bin/bash</span><br></pre></td></tr></table></figure></li>
<li>mysql字符编码配置<br>进入主机挂载mysql的文件目录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /mydata/mysql/conf</span><br><span class="line">vim my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET NAMES utf8mb4&#x27;</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure></li>
<li>Always Start<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update mysql --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><ol>
<li><p>登录docker hub &gt; 搜索reids</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull redis</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo docker images 查看本地镜像</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /mydata/redis/conf/</span><br><span class="line">sudo touch /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line">sudo docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
<p>redis配置文件描述：<br><a href="https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf">https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf</a></p>
</li>
<li><p>验证<br>不再进入/bin/bash，直接进入redis-cli命令行即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure></li>
<li><p>Always Start</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update redis --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><ol>
<li>下载安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull elasticsearch:7.4.2</span><br><span class="line">sudo docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure></li>
<li>创建文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /mydata/elasticsearch/config</span><br><span class="line">cd /mydata/elasticsearch/config</span><br><span class="line">touch elasticsearch.yml</span><br><span class="line">sudo mkdir -p /mydata/elasticsearch/data</span><br><span class="line">duso mkdir -p /mydata/elasticsearch/plugins</span><br></pre></td></tr></table></figure></li>
<li>赋权限<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod -R /mydata/elasticsearch/</span><br></pre></td></tr></table></figure></li>
<li>配置文件写入<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure></li>
<li>启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; \ #设置内存大小占用64~128M（很重要）</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticserach.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \ # -v 挂载文件，这样只用修改宿主机的文件，就可以在容器中得到应用</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure></li>
<li>Always Start<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update elasticsearch --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Kibaba"><a href="#安装Kibaba" class="headerlink" title="安装Kibaba"></a>安装Kibaba</h2><ol>
<li>下载<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull kibana:7.4.2</span><br><span class="line">sudo docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure></li>
<li>Always Start<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update kibana --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><ol>
<li>下载<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker pull nginx:1.20.2</span><br></pre></td></tr></table></figure></li>
<li>试运行并复制出配置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 80:80 --name nginx -d nginx:1.20.2</span><br><span class="line">sudo mkdir -p /mydata/nginx/conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制nginx的默认配置到mydata文件下</span></span><br><span class="line">sudo docker container cp nginx:/etc/nginx/. /mydata/nginx/conf/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止删除nginx容器</span></span><br><span class="line">sudo docker stop nginx</span><br><span class="line">sudo docker rm nginx</span><br></pre></td></tr></table></figure></li>
<li>配置启动nginx<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.20.2</span><br></pre></td></tr></table></figure></li>
<li>Always Start<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update nginx --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h2><ol>
<li>下载<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull nacos/nacos-server:2.0.3</span><br></pre></td></tr></table></figure>
nacos版本要与spring-cloud-alibaba/spring-cloud/spring-boot的版本是兼容的，可以查看<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明</a></li>
<li>创建文件夹<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/nacos/logs</span><br><span class="line">mkdir -p /mydata/nacos/init.d</span><br></pre></td></tr></table></figure></li>
<li>启动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker  run --name nacos \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--privileged=true \</span><br><span class="line">--restart=always \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-v /mydata/nacos/logs:/mydata/nacos/logs \</span><br><span class="line">-v /mydata/nacos/init.d/custom.properties:/mydata/nacos/init.d/custom.properties \</span><br><span class="line">-d nacos/nacos-server:2.0.3</span><br></pre></td></tr></table></figure>
其中<code>-e PREFER_HOST_MODE=hostname</code>可以将其配置为支持域名模式，默认是ip模式<br>8848端口用来HTTP服务，9848和9849用来服务发现和注册，所以也是需要映射到宿主机的端口的</li>
<li>Always Start<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker update nacos --restart=always</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置容器的开机启动</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h2><ol>
<li>安装zookeepr</li>
</ol>
<h2 id="安装Zipkin"><a href="#安装Zipkin" class="headerlink" title="安装Zipkin"></a>安装Zipkin</h2>]]></content>
      <categories>
        <category>Docker</category>
        <category>Vagrant</category>
      </categories>
  </entry>
  <entry>
    <title>使用Gradle构建多项目</title>
    <url>/2021/06/19/gradle-multi-module-project/</url>
    <content><![CDATA[<p>从创建一个最简单的gradle项目开始, 然后介绍multi module项目</p>
<h1 id="Creating-simplest-Gradle-project-for-Java"><a href="#Creating-simplest-Gradle-project-for-Java" class="headerlink" title="Creating simplest Gradle project for Java"></a>Creating simplest Gradle project for Java</h1><p>以创建一个Redis Client为例, 引入一个第三方库Jedis依赖.</p>
<ol>
<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;simplest-gradle-project&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>
<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例)<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">&#x27;org.demo&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url <span class="string">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	<span class="comment">// implementation &#x27;redis.clients:jedis:jedis-3.6.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果通过gradle task创建src文件目录(在build.gradle文件中添加下述代码), 然后运行 <code>./gradlew :createDirs</code>, 或者直接通过IDEA的gradle插件, 双击<code>simplest-gradle-project &gt; Tasks &gt; other &gt; createDirs</code><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建缺失的src目录</span></span><br><span class="line"><span class="keyword">task</span> createDirs &#123;</span><br><span class="line">    <span class="keyword">sourceSets</span>*.java.srcDirs*.<span class="keyword">each</span>&#123;</span><br><span class="line">        it.mkdirs()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">sourceSets</span>*.resources.srcDirs*.<span class="keyword">each</span>&#123;</span><br><span class="line">        it.mkdirs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考官方文档整理而来,<br><a href="https://spring.io/guides/gs/multi-module/">https://spring.io/guides/gs/multi-module/</a></p>
<h1 id="Creating-a-Multi-Module-Project"><a href="#Creating-a-Multi-Module-Project" class="headerlink" title="Creating a Multi Module Project"></a>Creating a Multi Module Project</h1><ol>
<li>首先创建Root Project, 即创建一个文件夹, 添加<code>settings.gradle</code>文件并编辑(首先确定自己有多少子项目)<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;gradle-multi-module&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;subproject1&#x27;</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;subproject2&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>在root目录下, 创建gradle wrapper的必要文件, <code>gradlew</code>, <code>gradlew.bat</code>, <code>gradle</code>(文件夹), 这些文件可以通过 Spring Initializr 新建一个项目得到.</li>
<li>在root目录下, 创建subprojects文件夹, <code>mkdir -p src/main/java/com/example/multimodule/service</code></li>
<li>在每个subproject下创建<code>build.gradle</code>文件, 如下内容(示例):<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.5.2&#x27;</span></span><br><span class="line">	id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.11.RELEASE&#x27;</span></span><br><span class="line">	id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> = <span class="string">&#x27;com.example&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line"><span class="keyword">sourceCompatibility</span> = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url <span class="string">&#x27;https://maven.aliyun.com/repository/public/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url <span class="string">&#x27;https://maven.aliyun.com/repository/spring/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">	implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class="line">	testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>对Gradle做出一些总结.</p>
<p>gradle是一个扩展性很强的build tool, 比Maven更加灵活. </p>
<ol>
<li>Gradle makes it easy to build common types of project — say Java libraries — by adding a layer of conventions and prebuilt functionality through plugins.</li>
<li>Gradle models its builds as Directed Acyclic Graphs (DAGs) of tasks (units of work). What this means is that a build essentially configures a set of tasks and wires them together — based on their dependencies — to create that DAG. Once the task graph has been created, Gradle determines which tasks need to be run in which order and then proceeds to execute them. Gradle构建项目的过程是执行一系列的task, 这些task构成了一个有向无环图DAG. 对于Java项目这些task就是: check, assemble, jar等等, 这些任务是内置的不需要用户定义.<br>这里还经常提到一个概念: DSL . DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言; 而与 DSL 相对的就是 GPL, 这里的 GPL 并不是我们知道的开源许可证, 而是 General Purpose Language 的简称，即通用编程语言，也就是我们非常熟悉的 Objective-C、Java、Python 以及 C 语言等等。比如Regex, HTML等, Gradle中支持Grovvy. 与 GPL 相对，DSL 与传统意义上的通用编程语言 C、Python 以及 Haskell 完全不同。通用的计算机编程语言是可以用来编写任意计算机程序的，并且能表达任何的可被计算的逻辑，同时也是 <a href="/2021/11/30/theory-turing-completeness/" title="图灵完备">图灵完备</a> 的。</li>
<li>没有必要全局安装Gradle，在项目中使用Gradle Wrapper即可，同时实际中要配置GRADLE_USER_HOME环境变量，设置Gradle Cache的存放位置，以免在C盘形成很多垃圾文件</li>
</ol>
]]></content>
      <categories>
        <category>Package Manager</category>
      </categories>
  </entry>
  <entry>
    <title>使用Hexo构建博客</title>
    <url>/2021/05/28/hexo-build-guide/</url>
    <content><![CDATA[<p>一直以来，使用其他工具来记录技术知识的积累，以后陆续将其转到github上。使用Hexo搭建项目可以自动将文档生成静态HTML等文件，上传到github上，随时通过your-github-name.github.io查看自己的公开静态信息库。</p>
<h2 id="Github准备操作"><a href="#Github准备操作" class="headerlink" title="Github准备操作"></a>Github准备操作</h2><ol>
<li>首先在github上创建一个新的repository，其中<code>Repository name</code>为<code>[your-github-name].github.io</code>，设为开源, 用来存放生成的静态文件, 先不创建任何文件和分支.</li>
<li>在创建一个repository, <code>Repository name</code>最好设为<code>github-bolg</code>(根据个人喜好), 这个项目存放文档以及源码</li>
<li>将ssh公钥<code>id_ras.pub</code>内容添加到个人信息 &gt; settings &gt; SSH keys</li>
</ol>
<h2 id="本地准备操作"><a href="#本地准备操作" class="headerlink" title="本地准备操作"></a>本地准备操作</h2><ol>
<li><p>安装Node.js (默认安装了npm)</p>
</li>
<li><p>npm的配置, 对前端不是很熟, 这里需要记录一下</p>
<ul>
<li>在Windows默认的用户目录下, 新建<code>C:\Users\your-user-name\.npmrc</code>文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">prefix=D:\your-path\nodejs\node_global</span><br><span class="line">cache=D:\your-path\nodejs\node_cache</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装<code>npm install -g hexo</code></p>
</li>
<li><p>初始化<code>hexo init [your-project-name]</code></p>
</li>
<li><p>此时可以进行一步本地启动尝试. 执行三个命令: <code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo server</code>, 如果成功访问<code>localhost:4000</code>说明初始化成功</p>
</li>
<li><p>进入项目根目录查看</p>
<ul>
<li><code>.deploy_git</code>&amp;<code>.github</code>不明其意, 勿动</li>
<li><code>source/_posts</code>存放源文档, 未来soure中还会加入<code>about</code>, <code>categoryies</code>, <code>tags</code>文件夹, 分别对应了<code>关于</code> , <code>分类</code>, <code>标签</code>页面的源文档. </li>
<li><code>themes</code>对应主题, 每个主题都会是一个文件夹</li>
<li><code>_config.yml</code>记录了整个项目的配置, 包括显示的语言, 时区等</li>
<li><code>package.json</code>&amp;<code>package-lock.json</code>为项目依赖包的记录</li>
<li><code>public</code>文件夹是生成的静态文件保存的位置, 对应<code>[your-github-name].github.io</code>仓库</li>
<li><code>node_modules</code>对应依赖包信息</li>
</ul>
</li>
<li><p>整个项目初始化为git项目, 并添加<code>.gitignore</code>文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>

<ul>
<li><blockquote>
<p>通过此gitignore文件可以看出向<code>[github-blog]</code>repository推送的包括源文档, 主题文件和配置文件</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin [github-bolg repository ssh address]</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> example: $ git remote add origin git@github.com:the-Rings/github-blog.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> github从2020年12月份之后, 不再支持用户名&amp;密码方式推送项目, 所以这里是ssh address, 配合我们之前加入的SSH keys使用</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;something&quot;</span><br><span class="line">git push --set-upstream main</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送完成</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置<code>_config.yml</code>向<code>[your-github-name].github.io</code>仓库推送public下的文件, 这是不需要初始化git仓库, 使用hexo相关工具完成</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑_config.yml中的deploy选项</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:[your-github-name]/[your-github-name].github.io.git</span> <span class="comment"># 复制仓库的SSH地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># 分支默认为main即可</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装<code>npm install hexo-deployer-git --save</code>, 这个工具来向github推送静态文件</p>
</li>
<li><p>通过<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code>三个命令组合完成, 实际上每次修改之后都是这一顿操作.</p>
</li>
</ol>
<h2 id="主题等相关配置操作"><a href="#主题等相关配置操作" class="headerlink" title="主题等相关配置操作"></a>主题等相关配置操作</h2><ol>
<li><p>选用<code>Next</code>主题, 然后对<code>theme/next</code>中的配置文件进行相关设置, 这里参考网友们的答案即可, 主要是对首页、归档、分类、标签、关于进行相关设置和注释放开, 并通过命令增加对应的模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure></li>
<li><p>启用搜索功能, 在项目的根目录下<code>_config.yml</code>找到<code>Extensions</code>, 增加配置, 并执行<code>$ npm install hexo-generator-searchdb --save</code></p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后, 在主题配置文件<code>theme/next/.config.yml</code>中设置<code>local_search: enable: true</code></li>
</ul>
</li>
<li><p>UML图插件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-plantuml</span><br></pre></td></tr></table></figure>
<p> 语法参考: <a href="https://plantuml.com/zh/class-diagram">https://plantuml.com/zh/class-diagram</a><br> 预览效果: <a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000</a></p>
 <img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00></li>
</ol>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>下载插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<p>在<code>_config.yml</code>做如下更改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这样每次<code>hexo new post &quot;xxx&quot;</code>后，就会在<code>_post</code>下生成一个同名文件夹，将图片放在这个同名文件夹中即可，然后在引用图片的地方加上<code>![](image_name.jpeg)</code>即可</p>
<h2 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h2><ol>
<li>站内文章链接<a href="#">Post not found: file_name display name</a></li>
</ol>
<h2 id="在一台新的机器上克隆项目的流程"><a href="#在一台新的机器上克隆项目的流程" class="headerlink" title="在一台新的机器上克隆项目的流程"></a>在一台新的机器上克隆项目的流程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone your-github-blog-url</span><br><span class="line">cd your-github-blog-root-path</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> your-node-module-path to PATH</span></span><br><span class="line">npm install -g hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从package-lock.json安装所有包</span></span><br><span class="line">npm ci</span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出现NEXT主题的logo说明安装成功</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出现“hexo: 无法加载文件 ******.ps1”的错误，可能要以管理员身份运行cmd，“set-ExecutionPolicy RemoteSigned”</span></span><br></pre></td></tr></table></figure>
<h4 id="日常操作流程"><a href="#日常操作流程" class="headerlink" title="日常操作流程"></a>日常操作流程</h4><ol>
<li>写博客<code>hexo new post [new-blog-name]</code>, 在<code>source/_post/</code>下就生成了一个新的博客文件, 可以用其他markdown编辑工具来编写, 比如Typora</li>
<li>在博客文档的开头可以设置标签和分类</li>
<li>写完之后, 提交源码<code>git add </code>&amp;<code>git commit</code>&amp;<code>git push</code></li>
<li>部署发布<code>hexo clean</code>&amp;<code>hexo generate</code>&amp;<code>hexo deploy</code></li>
</ol>
<h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>总结一些在部署中的错误解决</p>
<ol>
<li>在执行<code>hexo generate</code>中出现错误: <code>Template render error: (unknown path)</code>, 多半是语法错误, 比如, 在使用<code>&#123;% xxx %&#125;</code>时写成了<code>&#123; % xxx %&#125;</code>, 前方多了一个空格.</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://the-rings.github.io/">the-Rings</a>! This is your very first post.</p>
]]></content>
  </entry>
  <entry>
    <title>现代乡愁</title>
    <url>/2022/03/19/homesickness/</url>
    <content><![CDATA[<p><em>乡愁</em>的本质是西方工业革命的产物，工业革命产生了大量的劳工阶层，他的主体是失去土地的农民，这些从农村走进城市的劳工阶层，一进城就被套路了，因为他们无法在城市中找到自己的存在。</p>
<p>首先，工业文明导致宗族关系开始瓦解，人们为了一个工作机会必须辗转奔波，流离失所，他们原理自己熟悉的环境，背井离乡的上班族，虽然可以在新的环境中找到归属，但是他们和旧世界的联系戛然而止，旧的关系瓦解，新的社群关系没有建立，这种孤独感让他们渴望回家。</p>
<p>同时，工人阶层在城市进入到了一个逐渐被无产化的过程，当城市中产和企业家的生活越来越富足，而工人阶级的生存状况却很少改变，强者越强，弱者越弱的马太效应，造就了工人阶级的普遍不满，马太效应造成了普遍的民粹化，和对资本家的仇视，这是18世纪后叶工人运动兴起的根本原因。</p>
<p>另外，推崇竞争的工业文明带来了安全感的缺失，现代化对静态的农耕文明具有非常强的颠覆性，它的淘汰率极高，流动性也极强，世界从此开始了混沌态。一劳永逸的生存之道不再有，而失业破产更是司空见惯，人们生活在常态性的变化和空间的流浪中，他们背负了巨大的不确定性，因为不确定性，人们更加向往确定，故乡就成了这个确定性的原点，成为了人们梦里的乌托邦。</p>
<p>但是，乌托邦一定会破灭，就像人们每次返乡，都目睹了一场乌托邦破灭的过程。人们已经无法从锲约社会退格回到故乡的宗族社会，故乡的亲情淡漠，娱乐匮乏，还有故乡的旱厕都让他们无法忍受。当故乡这个唯一的确定性破灭，人们就成为了精神上的无家可归的流浪者。</p>
<p>于是，故乡就有了批判性，为什么故乡那么愚昧，为什么故乡总是不发展，在对故乡的批判中，广义的乡愁诞生了，乡愁的对象不再是具体的故乡，它成了人们内心的乌托邦。旷野散步也好，东江垂钓也好，乡愁蔓延到了更远的地方，那个曾经具象的故乡，开始被人们心中的故乡所取代。</p>
<p>罗兰·罗伯森在《全球化与怀乡范式》中提出现代社会中乡愁是一种观念，它代表着人们对过去生活方式的决裂，以及现代意识的觉醒，乡愁是人们对故乡语言，环境和生活方式的缅怀。所以乡愁自带悲伤的BGM，它注定是一种无解的追寻。<br>乡愁是流浪的人对母体最深的眷恋，不论是知识分子的去国怀乡，还是工人阶层的不断流浪，乡愁的无家可归，它催生了人类的悲悯、流浪、希望等等伟大的“非理性精神”，从而成为了人文主义的摇篮。</p>
]]></content>
      <categories>
        <category>Thought Gravity</category>
      </categories>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2021/07/24/java-annotation/</url>
    <content><![CDATA[<p>通过格式化的方式让代码附带信息, 之后根据这些约定好的格式, 在源代码时期, 编译时期和运行时期, 通过Annotation Processor做一些操作. 注解可以理解为一种特殊的注释, 只不过是给机器看的.<br>定义注解的语法看起来就像在定义一个接口.</p>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><p>定义在注解中的类型包括: 基本类型(All primitives)、String、Class、enum、Annotation以及以上这些类型组成的数组。</p>
<p>注解不支持继承.</p>
<p>有五种元注解, 元注解用于注解其他注解. 其中@Target和@Retention是必须的. @Retention标识了注解在哪个阶段起作用，参数SOURCE，CLASS，RUNTIME中的一个，其中SOURCE表示注解将会被编译器丢弃（忽略），CLASS表示注解将会被JVM丢弃（忽略），RUNTIME表示注解可以再运行时起作用，并一直保留，所以可以通过反射读取注解信息。也就是说，SOURCE在complie time起作用，javac编译完就丢弃，比如@SuppressWarnings @Override就用在启动编译的时候。比如:<br>有一个类库叫mapstruct，其中@Mapper注解用在接口上对应@Retentation(RetentationPolicy.CLASS)。在它编译打包后，会在target/generated-sources/annotations/下生成对应的实现类的java文件，然后生成实现类的class文件。</p>
<p>那么问题来了，SOURCE也是在编译时起作用，究竟在那个阶段呢？以下这张图展示了Java的编译过程：</p>
<img  src=http://www.plantuml.com/plantuml/svg/BOsn2WCn34DtVuN6TWdNDPbkA5tl5qnYsi3X5CUbtD_NXHEI9l4qdSs9CexnCSoeAgYZII4oUGjxniOs1QmDTtMnGWXbf9JAkS7trNV1PLKTpjw7OhDHPSwkp-iVlohlnqbvY8gnnqN6RLd2aVWJRJy0>

<p>在Annotation Processing的过程之后，RetentationPolicy.SOURCE就被丢弃了，同时RetentationPolicy.CLASS的注解要还保留在class文件中。</p>
<h2 id="Using-javac-to-Process-Annotations"><a href="#Using-javac-to-Process-Annotations" class="headerlink" title="Using javac to Process Annotations"></a>Using javac to Process Annotations</h2><p>自定义注解之后，如果不对其进行处理，那么注解不会比注释更有用。</p>
<p>如果要在编译时期做一些事情(利用注解生成代码), 这时就需要用到<code>Annotation Processor</code>, 具体的做法是继承AbstractProcessor, 然后实现其process方法.</p>
<p>Annotation Processor机制是什么？.<br>如果在上一轮的processing中生成一个新的source code文件，那么这个文件将被再次检查annotation，直到没有新的source file产生。最后所有的源文件都被编译完成。这就是为什么mapstruct先生成java文件，然后生成class文件。</p>
<h2 id="Runtime-Annotations-Processing"><a href="#Runtime-Annotations-Processing" class="headerlink" title="Runtime Annotations Processing"></a>Runtime Annotations Processing</h2><p>在运行时通过反射完成一些操作的话，不是继承AbstractProcessor，只需要通过Java反射API中扩展的getAnnotation(xxx.class)方法即可。</p>
<p>比如，通过自定义注解@Query(…)来实现动态查询，事先在一个类Criteria，其中声明好查询条件的字段Fields，都用@Query装饰。然后写这样一个方法，接收Criteria对象criteria，criteria.getClass().getDeclaredFields()，遍历这个数组，然后对数组中的每个Field，field.setAccessible(true)，保证对private的访问。然后field.getAnnotation(Query.class)获得当前这个@Query传入的参数，确定查询条件是等于，like等等。根据filed.getName()获得字段名称，filed.get(criteria)获得对象中此属性的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> com.lee.annotation.Query;</span><br><span class="line"><span class="keyword">import</span> com.lee.config.mybatis.SimpleQueryWrapper;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> guomaoqing907</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;all&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryHelpForMybatis</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, Q&gt; <span class="function">SimpleQueryWrapper&lt;T&gt; <span class="title">getQueryCondition</span><span class="params">(Q query)</span> </span>&#123;</span><br><span class="line">    List&lt;SimpleQueryWrapper&lt;T&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;SimpleQueryWrapper&lt;T&gt;&gt;();</span><br><span class="line">    SimpleQueryWrapper&lt;T&gt; qw = <span class="keyword">new</span> SimpleQueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (query == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> qw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Field&gt; fields = getAllFields(query.getClass(), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> accessible = field.isAccessible();</span><br><span class="line">        <span class="comment">// 设置对象的访问权限，保证对private的属性的访</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Query q = field.getAnnotation(Query.class);</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String propName = q.propName();</span><br><span class="line">          String joinName = q.joinName();</span><br><span class="line">          <span class="comment">// 不支持join表的条件，需要在具体查询接口处另作处理</span></span><br><span class="line">          <span class="keyword">if</span> (!isBlank(joinName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          String blurry = q.blurry();</span><br><span class="line">          String attributeName = isBlank(propName) ? field.getName() : propName;</span><br><span class="line">          <span class="keyword">boolean</span> sortType = q.sortType();</span><br><span class="line">          Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">          Object val = field.get(query);</span><br><span class="line">          <span class="keyword">if</span> (ObjectUtil.isNull(val) || <span class="string">&quot;&quot;</span>.equals(val) || ObjectUtil.isEmpty(val)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 模糊多字段</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectUtil.isNotEmpty(blurry)) &#123;</span><br><span class="line">            String[] blurrys = blurry.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            List&lt;SimpleQueryWrapper&lt;T&gt;&gt; conditionChain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> 如何实现 (a like &#x27;..&#x27; or b like &#x27;..&#x27; or c like &#x27;..&#x27;) and d = &#x27;..&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> (String s : blurrys) &#123;</span><br><span class="line">              qw.or().like(s, val.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">switch</span> (q.type()) &#123;</span><br><span class="line">            <span class="keyword">case</span> EQUAL:</span><br><span class="line">              qw.eq(attributeName, val);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREATER_THAN:</span><br><span class="line">              qw.and(obj -&gt; obj.ge(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LESS_THAN:</span><br><span class="line">              qw.and(obj -&gt; obj.le(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LESS_THAN_NQ:</span><br><span class="line">              qw.and(obj -&gt; obj.lt(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> INNER_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.like(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LEFT_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.likeLeft(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RIGHT_LIKE:</span><br><span class="line">              qw.and(obj -&gt; obj.likeRight(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IN:</span><br><span class="line">              List valList = (ArrayList) val;</span><br><span class="line">              Object[] objArray = valList.toArray();</span><br><span class="line">              qw.and(obj -&gt; obj.in(attributeName, objArray));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_EQUAL:</span><br><span class="line">              qw.and(obj -&gt; obj.ne(attributeName, val));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NOT_NULL:</span><br><span class="line">              qw.and(obj -&gt; obj.isNotNull(attributeName));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IS_NULL:</span><br><span class="line">              qw.and(obj -&gt; obj.isNull(attributeName));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BETWEEN:</span><br><span class="line">              List&lt;Object&gt; between = <span class="keyword">new</span> ArrayList&lt;&gt;((List&lt;Object&gt;) val);</span><br><span class="line">              qw.and(obj -&gt; obj.between(attributeName, between.get(<span class="number">0</span>), between.get(<span class="number">1</span>)));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SORT:</span><br><span class="line">              List valListSort = (ArrayList) val ;</span><br><span class="line">              Object[] objArraySort = valListSort.toArray();</span><br><span class="line">              <span class="keyword">if</span>(valListSort.toString().split(<span class="string">&quot;,&quot;</span>).length&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                Object object = <span class="string">&quot;asc&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (objArraySort[<span class="number">1</span>].equals(object))&#123;</span><br><span class="line">                   qw.orderBy(<span class="keyword">true</span>, <span class="keyword">true</span>, objArraySort[<span class="number">0</span>].toString());</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                  qw.orderBy(<span class="keyword">true</span>, <span class="keyword">false</span>, objArraySort[<span class="number">0</span>].toString());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                String[] stringsSort;</span><br><span class="line">                <span class="keyword">for</span> (Object objectSort : objArraySort)&#123;</span><br><span class="line">                  stringsSort=objectSort.toString().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (stringsSort[<span class="number">1</span>].equals(<span class="string">&quot;asc&quot;</span>))&#123;</span><br><span class="line">                    qw.orderBy(<span class="keyword">true</span>, <span class="keyword">true</span>, stringsSort[<span class="number">0</span>]);</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    qw.orderBy(<span class="keyword">true</span>, <span class="keyword">false</span>, stringsSort[<span class="number">0</span>]);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        field.setAccessible(accessible);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qw;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">(<span class="keyword">final</span> CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> strLen;</span><br><span class="line">    <span class="keyword">if</span> (cs == <span class="keyword">null</span> || (strLen = cs.length()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!Character.isWhitespace(cs.charAt(i))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Field&gt; <span class="title">getAllFields</span><span class="params">(Class clazz, List&lt;Field&gt; fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));</span><br><span class="line">      getAllFields(clazz.getSuperclass(), fields);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fields;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java匿名内部类</title>
    <url>/2021/11/04/java-anonymous-inner-class/</url>
    <content><![CDATA[<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><blockquote><p>Anonymous classes enable you to make your code more concise. They enable you to declare and instantiate a class at the same time. They are like local classes except that they do not have a name. Use them if you need to use a local class only once.</p>
</blockquote>
<p>匿名内部类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</p>
<p>匿名内部类，顾名思义，这个类是没有名字的，定义即实例化对象<br>语法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">getContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel p = <span class="keyword">new</span> Parcel();</span><br><span class="line">    p.getContents().value();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// output:</span></span><br><span class="line">  <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个表达式, new后加接口(类)名(并且此接口或类一定是已经声明的), 表示这个匿名内部类实现(继承)了对应的接口(类)。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java函数式编程</title>
    <url>/2021/08/04/java-functional-programming/</url>
    <content><![CDATA[<p>编程风格可以分为命令式(Imperative)和声明式(Declarative), 它声明了要做什么, 而不是每一步如何做.<br>这正是我们在函数式编程中所看到的的.</p>
<p>函数是Java支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。<br>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。<br>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<br>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！<br>像Java、Python对函数式编程提供部分支持。由于允许使用变量，因此，他们不是纯函数式编程语言。Haskell是一种纯函数式变成语言。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>从概念上来说, Lambda表达式, 生产的是函数, 而不是类<br>但是在JVM上, everything is a class, 但是经过各种幕后操作之后, <strong>使得Lambda看起来像函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IntCall</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntCallImpl</span> <span class="keyword">implements</span> <span class="title">IntCall</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> arg * call(arg - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalPrograming</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> IntCall fact;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 传统方法实现 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oldApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntCallImpl intCall = <span class="keyword">new</span> IntCallImpl();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;oldApproach --&gt; &quot;</span> + intCall.call(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 函数式编程实现 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">functionalApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里使用Lambda表达式的简洁语法, 但是其底层实现仍然是类和对象, IntCallImpl的步骤可能一步也没有少, 只是看起来像生成了一个函数.</span></span><br><span class="line">    fact = n -&gt; n == <span class="number">0</span> ? <span class="number">1</span> : n * fact.call(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;functionalApproach --&gt; &quot;</span> + fact.call(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anonymousInnerClassApproach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntCall fact = IntCallImpl::call</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionalPrograming.oldApproach();</span><br><span class="line">    FunctionalPrograming.functionalApproach();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mehtod-References"><a href="#Mehtod-References" class="headerlink" title="Mehtod References"></a>Mehtod References</h1><p>方法引用的语法:</p>
<blockquote><p>A method reference is a class name or an object name, follow by a ::, then the name of the method </p>
</blockquote>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;X::f&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MarkString0</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MarkString1</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">make</span><span class="params">(X x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundMethodReferences</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// MarkString0 n = X::f                             [1]</span></span><br><span class="line">      X x = <span class="keyword">new</span> X();</span><br><span class="line">      MarkString0 n = x::f;   <span class="comment">// method references        [2]</span></span><br><span class="line">      System.out.println(n.make());</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      MarkString1 m = X::f;   <span class="comment">//unbound method references [3]</span></span><br><span class="line">      System.out.println(m.make(<span class="keyword">new</span> X()));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从逻辑上来将, 方法的引用是指向一个Method类的一个实例, 方法对象必须绑定在某个类的对象上. 按照这个逻辑, 所以<code>[2]</code>可以赋值成功, <code>[1]</code>不能. <code>[1]</code>这种方式, <code>class X</code>和<code>interface MarkString0</code>中都没有可以创建<code>X</code>的对象, 没有对象如何调用f()方法呢? 这就引出Unbound Method References</p>
<h2 id="Unbound-Method-References"><a href="#Unbound-Method-References" class="headerlink" title="Unbound Method References"></a>Unbound Method References</h2><p>对于这种方式(感觉不常用), 我们需要让对应的接口的第一个参数(隐性规定)必须是X. 举一反三, 如下示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">This</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">three</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">four</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, String s, <span class="keyword">char</span> c)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TwoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call2</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ThreeArgs</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">call3</span><span class="params">(This athis, <span class="keyword">int</span> i, <span class="keyword">double</span> d, String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiUnbound</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TwoArgs twoargs = This::two;</span><br><span class="line">    ThreeArgs threeargs = This::three;</span><br><span class="line">    This athis = <span class="keyword">new</span> This();</span><br><span class="line">    twoargs.call2(athis, <span class="number">11</span>, <span class="number">3.14</span>);</span><br><span class="line">    threeargs.call3(athis, <span class="number">11</span>, <span class="number">3.14</span>, <span class="string">&quot;Three&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数引用"><a href="#构造函数引用" class="headerlink" title="构造函数引用"></a>构造函数引用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age = -<span class="number">1</span>; <span class="comment">// For &quot;unknown&quot;</span></span><br><span class="line">  Dog() &#123; name = <span class="string">&quot;stray&quot;</span>; &#125;</span><br><span class="line">  Dog(String nm) &#123; name = nm; &#125;</span><br><span class="line">  Dog(String nm, <span class="keyword">int</span> yrs) &#123; name = nm; age = yrs; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MakeNoArgs</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make1Arg</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Make2Args</span> </span>&#123;</span><br><span class="line">  <span class="function">Dog <span class="title">make</span><span class="params">(String nm, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CtorReference</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MakeNoArgs mna = Dog::<span class="keyword">new</span>; <span class="comment">// [1]</span></span><br><span class="line">    Make1Arg m1a = Dog::<span class="keyword">new</span>;   <span class="comment">// [2]</span></span><br><span class="line">    Make2Args m2a = Dog::<span class="keyword">new</span>;  <span class="comment">// [3]</span></span><br><span class="line">    Dog dn = mna.make();</span><br><span class="line">    Dog d1 = m1a.make(<span class="string">&quot;Comet&quot;</span>);</span><br><span class="line">    Dog d2 = m2a.make(<span class="string">&quot;Ralph&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dog 有三个构造函数，函数式接口内的 make() 方法反映了构造函数参数列表（ make() 方法名称可以不同）。</p>
<p>注意我们如何对 [1]，[2] 和 [3] 中的每一个使用 Dog :: new。 这三个构造函数只有一个相同名称：:: new，但在每种情况下赋值给不同的接口，编译器可以从中知道具体使用哪个构造函数。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>现在我们讨论本后的本质. Java是强类型语言, 编译器必须得知每个对象的类型信息, 所以method reference和Lambda表达式都必须被赋值. 通过赋值让编译器推测出准确的类型信息. 比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x -&gt; x.toString()</span><br></pre></td></tr></table></figure>
<p>编译器可以轻松地知道返回值肯定是String, 但是x是什么类型呢? Lambda表达式包含类型推导. 再比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>
<p><strong>必须当Lambda表达式被指派给某个接口, 才能确定其类型</strong>. 比如: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Functional</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FunctionalNoAnn</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">goodbye</span><span class="params">(String arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@FunctionalInterface</span></span><br><span class="line"><span class="comment">interface NotFunctional &#123;</span></span><br><span class="line"><span class="comment">  String goodbye(String arg);</span></span><br><span class="line"><span class="comment">  String hello(String arg);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">产生错误信息:</span></span><br><span class="line"><span class="comment">NotFunctional is not a functional interface</span></span><br><span class="line"><span class="comment">multiple non-overriding abstract methods</span></span><br><span class="line"><span class="comment">found in interface NotFunctional</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">goodbye</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Goodbye, &quot;</span> + arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionalAnnotation fa =</span><br><span class="line">      <span class="keyword">new</span> FunctionalAnnotation();</span><br><span class="line">    Functional f = fa::goodbye;</span><br><span class="line">    FunctionalNoAnn fna = fa::goodbye;</span><br><span class="line">    <span class="comment">// Functional fac = fa; // Incompatible</span></span><br><span class="line">    Functional fl = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">    FunctionalNoAnn fnal = a -&gt; <span class="string">&quot;Goodbye, &quot;</span> + a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中, <code>@FunctionalInterface</code>是一个可选注解, 没有也行.<br>通过以上例子我们可以得知, Lambda表达式被指派的接口只能有一个抽象方法对应. 摘录一段解释</p>
<blockquote><p>Look closely at what happens in the definitions of <code>f</code> and <code>fna</code>. Functional and<br>FunctionalNoAnn define interfaces. Yet what is assigned is just the method goodbye.<br>First, this is only a method and not a class. Second, it’s not even a method of a class<br>that implements one of those interfaces. This is a bit of magic that was added to Java<br>8: if you assign a method reference or a lambda expression to a functional interface<br>(and the types fit), Java will adapt your assignment to the target interface. <strong>Under<br>the covers, the compiler wraps your method reference or lambda expression in an<br>instance of a class that implements the target interface.</strong></p>
<p>A @FunctionalInterface is also called a Single Abstract Method (SAM) type.</p>
<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>


<p>如果将Lambda表达式作为参数传入, 看流式编程中, <code>Stream.of(...).map((x, y) -&gt; x + y))</code>, 其中map方法接收了一个表达式. 查看其源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后, 再查看Function接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function  方法输入的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function 方法输出的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由Function也可以看出其中只有一个抽象方法<code>apply</code>, 那么这个肯定与Lambda表达式的格式对应. 方法的输入和输出分别由泛型<code>&lt;T, R&gt; </code>与之对应.</p>
<p>那么@FunctionalInterface的意义是什么, 在源码注释中解释很清楚:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code>是为了检测, 以限制所注释的接口中只能有一个抽象方法.</p>
<p>在<code>java.util.function</code>中还有很多函数式接口, 这里就不在列举了.</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>其实就是生成函数的函数, 比如返回一个Lambda表达式.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Function&lt;String, String&gt; <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s -&gt; s.toLowerCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h2><p>一般情况下, 函数执行完成后, 其内部定义的局部变量, 将会被垃圾回收. 如果有一个函数使用函数作用域之外的变量, 并将此函数返回, 这些变量将会在函数中继续存在, 即使母函数已经执行完毕.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure2</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeFun方法返回的IntSupplier将i和x进行了”close over”, 即使makeFun执行完毕, x和i仍然有效, 一般情况下, 它们就被回收了.</p>
<p>此时, 考虑如下情况:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure3</span> </span>&#123;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在编译时, x++ 和 i++ 都会报错</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; x++ + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Variable used in lambda expression should be final or effectively final</em><br>Lambda表达式中引用的局部变量必须是final, 或者等同final. 使用时, final可以省略. </p>
<p>那么, 为什么呢?<br>考虑在一般情况, 不使用Lambda表达式时, 我们可能会这么写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.IntSupplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    lambda(x, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      x++;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x和i传入lambda时, 一定是一个定量, 不可能是一个变量, 这不符合思维逻辑. 只是Lambda表达式给我们一个将函数返回的机会, 早期的Java版本没有这个特性.</p>
<h4 id="闭包的结论"><a href="#闭包的结论" class="headerlink" title="闭包的结论"></a>闭包的结论</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function">IntSupplier <span class="title">makeFun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一切正常, 因为i是成员, 非局部.</span></span><br><span class="line">    <span class="keyword">return</span> () -&gt; x + i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda可以无限制的引用成员变量(members), 但是当其引用局部变量(local variable)时, 局部变量必须声明为final.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lambda表达式与Method Reference原理上是一样的, 编译器会解析它们, 之后将它们包裹在一个类中, 这个类实现了目标接口. 所以, 当我们去书写Lambda表达式的时候, 编译器也会据此生成代码.</p>
<p>解释的更加仔细一点, 写了一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TargetInterface</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">apply</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">connect</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data + <span class="string">&quot;&lt;---&gt;&quot;</span> + data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferencesNature</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Tool tool = <span class="keyword">new</span> Tool();</span><br><span class="line">    TargetInterface t = tool::connect;</span><br><span class="line">    System.out.println(t.apply(<span class="string">&quot;you&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下这个示例反应了运行时生成字节码的伪代码, <code>$Example1</code>在目标接口和类之间搭建了一个桥梁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 示例: 自动生成的类 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> $<span class="title">Example1</span> <span class="keyword">implements</span> <span class="title">TargetInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Tool tool;</span><br><span class="line">  $Example1(Tool tool) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tool = tool;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tool.connect(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与Method Reference是一样的(省略main方法声明)</span></span><br><span class="line">$Example1 example1 = <span class="keyword">new</span> $Example1(<span class="keyword">new</span> Tool());</span><br><span class="line">example1.apply(<span class="string">&quot;you&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么Lambda表达式, 就更进一步. 首先表达式是一个函数, 函数必须属于某个类. 所以, 生成的字节码时<code>Tool</code>类和<code>$Example1</code>都生成了, 所以Lambda和Method References是本质是一样的.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的类加载器</title>
    <url>/2021/06/15/java-classloader/</url>
    <content><![CDATA[<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>类加载器负责加载类. ClassLoader是抽象类. 对于给定类的二进制名字, 类加载器应该试图去定位或者生成构成一个类定义的数据. 一个典型的策略是将这个名字转换为文件名, 然后从文件体统中读取该名字的class file.</p>
<p>Every Class object contains a reference to the ClassLoader that defined it.<br>每个Class对象都包含一个引用, 它指向定义它的那个ClassLoader.</p>
<blockquote>
<p>这一点在源码中表现的就是, 在Class类中, 有一个Filed是ClassLoader类型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class="line"><span class="comment">     * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment">     * generated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 这里出现了私有构造器, 说明这个构造函数是能在Class这类里使用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">        <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">        classLoader = loader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialized in JVM not by private constructor</span></span><br><span class="line">    <span class="comment">// This field is filtered from reflection access, i.e. getDeclaredField</span></span><br><span class="line">    <span class="comment">// will throw NoSuchFieldException</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br>应用实现了ClassLoader的子类, 是为了扩展JVM动态加载类的方式.</p>
<p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br>ClassLoader 类使用委托模型来搜索类和资源。 ClassLoader 的每个实例都有一个关联的父类加载器。当请求查找类或资源时，ClassLoader 实例会将类或资源的搜索委托给其父类加载器，然后再尝试查找类或资源本身。虚拟机的内置类加载器，称为“引导类加载器”，它本身没有父级，但可以作为 ClassLoader 实例的父级。</p>
<p>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br>一般情况下, JVM加载类通过本地的文件系统. 比如, UNIX系统, JVN从CLASSPATH环境变量定义的目录中来加载类.</p>
<p>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br>然而, 有些类可能不来源于文件; 它们可能来源于其他资源, 比如网络或者被应用构造. <code>defineClass</code>方法将字节数组转换为类Class的实例. 这个新定义的类的实例可以被<code>Class.newInstace</code>创建.</p>
<p>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br>被类加载器创建的对象, 它的方法和构造器可能引用自其他类. </p>
<p>For example, an application could create a network class loader to download class files from a server. Sample code might look like:</p>
<p>   ClassLoader loader = new NetworkClassLoader(host, port);<br>   Object main = loader.loadClass(“Main”, true).newInstance();<br>        . . .</p>
<p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:</p>
<pre><code> class NetworkClassLoader extends ClassLoader &#123;
     String host;
     int port;

     public Class findClass(String name) &#123;
         byte[] b = loadClassData(name);
         return defineClass(name, b, 0, b.length);
     &#125;

     private byte[] loadClassData(String name) &#123;
         // load the class data from the connection
          . . .
     &#125;
 &#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/2021/08/12/java-reflection/</url>
    <content><![CDATA[<p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p>
<blockquote><p>Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions.<br>The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</p>
<footer><strong>Oracle</strong></footer></blockquote>


<h1 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h1><p>简言之，反射是为了在运行时获得程序中类的属性和方法等信息。在Java中程序中的类在编译时期就确定下来了，反射机制可以动态创建对象并调用其members. Python对象的类型在编译时是未知的，在运行时才知道运行的对象是谁。</p>
<p>反射应用的三种形式，总结起来分别是：</p>
<ol>
<li>运行时得到类的信息</li>
<li>类型转换</li>
<li>instanceof</li>
</ol>
<p>Java中使用反射遵循以下流程。java.lang.reflect包中有Field, Method和Constructor（它们都继承AccessibleObject，实现了Member接口），在运行时JVM为类创建Field，Method和Constructor等的对象。你可以使用Constructor创建新对象，使用某个特定的Method对象调用invoke方法，或者使用Class.forName（当你没有对象的时候，你可以使用Class.forName得到类，当你拥有对象的时候，你可以通过该对象调用getClass方法，他们的结果是等价的），getSuperClass，getFields，getMethods，getConstructors来得到这些Member对象的数组。</p>
<p>以上一直在强调“动态”，但是归根结底Java仍然是一门静态语言，与Python才是真动态，在Java里所有的类在编译时期就已经完全确定了，不会再增加新的类，但是Python不一样，在运行时才知道某个类的存在，可以在运行时往类中增加额外的属性，不像Java要使用什么必须先声明出来。</p>
<p>很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</p>
<h2 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h2><p>Java创建对象有两种方式，一个是new，一个是反射<br>反射创建对象，第一步是获取Class，第二步获取构造器，第三步构造器newInstance()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;xxx.xxx&quot;</span>);</span><br><span class="line">Constructor ctor = class.getConstructor();</span><br><span class="line">clazz obj = ctor.newInstance();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其中获取到Class有三种方式：</p>
<ul>
<li>Class.forName(“xxx.xxx”)</li>
<li>对象.getClass</li>
<li>类.Class<br>这三种方式没有性能区别<br><code>Class.forName(...).getContructor()</code>只能获取到<code>Member.PUBLIC</code>的构造方法, 一个类如果不声明任何构造方法就会由一个默认的构造方法, 如果这个类是<code>Member.PUBLIC</code>那么默认的构造方法也是, 如果这个类是包访问权限, 那么默认构造器也是包访问权限啊</li>
</ul>
</blockquote>
<h2 id="Method-Invoke"><a href="#Method-Invoke" class="headerlink" title="Method Invoke"></a>Method Invoke</h2><p>在实际应用中, 经常会用到method.invoke, 比如在动态代理中, 附上其源码来分析一下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invokes the underlying method represented by this &#123;<span class="doctag">@code</span> Method&#125;</span></span><br><span class="line"><span class="comment"> * object, on the specified object with the specified parameters.</span></span><br><span class="line"><span class="comment"> * Individual parameters are automatically unwrapped to match</span></span><br><span class="line"><span class="comment"> * primitive formal parameters, and both primitive and reference</span></span><br><span class="line"><span class="comment"> * parameters are subject to method invocation conversions as</span></span><br><span class="line"><span class="comment"> * necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is static, then the specified &#123;<span class="doctag">@code</span> obj&#125;</span></span><br><span class="line"><span class="comment"> * argument is ignored. It may be null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the number of formal parameters required by the underlying method is</span></span><br><span class="line"><span class="comment"> * 0, the supplied &#123;<span class="doctag">@code</span> args&#125; array may be of length 0 or null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is an instance method, it is invoked</span></span><br><span class="line"><span class="comment"> * using dynamic method lookup as documented in The Java Language</span></span><br><span class="line"><span class="comment"> * Specification, Second Edition, section 15.12.4.4; in particular,</span></span><br><span class="line"><span class="comment"> * overriding based on the runtime type of the target object will occur.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the underlying method is static, the class that declared</span></span><br><span class="line"><span class="comment"> * the method is initialized if it has not already been initialized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the method completes normally, the value it returns is</span></span><br><span class="line"><span class="comment"> * returned to the caller of invoke; if the value has a primitive</span></span><br><span class="line"><span class="comment"> * type, it is first appropriately wrapped in an object. However,</span></span><br><span class="line"><span class="comment"> * if the value has the type of an array of a primitive type, the</span></span><br><span class="line"><span class="comment"> * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in</span></span><br><span class="line"><span class="comment"> * other words, an array of primitive type is returned.  If the</span></span><br><span class="line"><span class="comment"> * underlying method return type is void, the invocation returns</span></span><br><span class="line"><span class="comment"> * null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  the object the underlying method is invoked from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the arguments used for the method call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the result of dispatching the method represented by</span></span><br><span class="line"><span class="comment"> * this object on &#123;<span class="doctag">@code</span> obj&#125; with parameters</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> args&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalAccessException    if this &#123;<span class="doctag">@code</span> Method&#125; object</span></span><br><span class="line"><span class="comment"> *              is enforcing Java language access control and the underlying</span></span><br><span class="line"><span class="comment"> *              method is inaccessible.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> IllegalArgumentException  if the method is an</span></span><br><span class="line"><span class="comment"> *              instance method and the specified object argument</span></span><br><span class="line"><span class="comment"> *              is not an instance of the class or interface</span></span><br><span class="line"><span class="comment"> *              declaring the underlying method (or of a subclass</span></span><br><span class="line"><span class="comment"> *              or implementor thereof); if the number of actual</span></span><br><span class="line"><span class="comment"> *              and formal parameters differ; if an unwrapping</span></span><br><span class="line"><span class="comment"> *              conversion for primitive arguments fails; or if,</span></span><br><span class="line"><span class="comment"> *              after possible unwrapping, a parameter value</span></span><br><span class="line"><span class="comment"> *              cannot be converted to the corresponding formal</span></span><br><span class="line"><span class="comment"> *              parameter type by a method invocation conversion.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> InvocationTargetException if the underlying method</span></span><br><span class="line"><span class="comment"> *              throws an exception.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> NullPointerException      if the specified object is null</span></span><br><span class="line"><span class="comment"> *              and the method is an instance method.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> ExceptionInInitializerError if the initialization</span></span><br><span class="line"><span class="comment"> * provoked by this method fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上源码中, 首先进行了权限检查，接着调用了methodAccessor的invoke方法，其中methodAccessor是一个共享的变量(volatile)。Reflection.getCallerClass()方法是一个native修饰的方法，native表示该方法的实现由C/C++来编写，放在本地的共享库中。</p>
<p>MethodAccessor是一个接口, 最终通过NativeMethodAccessorImpl来实现invoke, 然后调用native方法invoke0:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList.remove</title>
    <url>/2021/11/15/java-arraylist/</url>
    <content><![CDATA[<p>ArrayList基于数组的List集合, 那么从数组中删除一个元素的底层逻辑是什么样?</p>
<h3 id="ArrayList-remove-index"><a href="#ArrayList-remove-index" class="headerlink" title="ArrayList.remove(index)"></a>ArrayList.remove(index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; al = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>));</span><br><span class="line">String old = al.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(old);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>Arrays.asList(...).remove(index)</code>会抛出<code>UnsupportedOperationException</code>.<br>Arrays.asList方法返回一个ArrayList(内部类), 是<code>java.util.Arrays</code>下的一个内部类, 对remove并没有实现逻辑<br>通过<code>Arrays.asList(...)</code>得到的List是一个只读的集合, 也没有实现add方法. 所以这里可以通过ArrayList的构造方法新建可以增删改查的集合</p>
</blockquote>
<p>ArrayList源码(部分):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// elementData</span></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment">     * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment">     * indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index the index of the element to be removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the element that was removed from the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// numMoved表示要移动的元素数量</span></span><br><span class="line">        <span class="comment">// 如果等于0说明, 要删除的是最后一位, 不需要移动, 直接将最后一位设为null即可</span></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList内部维护了一个数组<code>elementData</code>. remove并没有删除数组中的元素, 而是通过<code>System.arraycopy</code>方法将index后的元素向前移动一位, 把最后一位的的值设为null.<br>System.arraycopy是一个native方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将从src数组的指定位置srcPos开始复制length长度的元素, 对应到dest数组的descPos位置依次往后替换</span></span><br><span class="line"><span class="comment"> * 比如, 当length为2的两个数组, srcPos=3, destPos=0</span></span><br><span class="line"><span class="comment"> * src: [a, b, c, d, e]</span></span><br><span class="line"><span class="comment"> *                ↓  ↓</span></span><br><span class="line"><span class="comment"> * dest:         [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"> * output: [a, b, 3, 4, 5](dest)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src     the source array.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcPos  starting position in the source array.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest    the destination array.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destPos starting position in the destination data.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length  the number of array elements to be copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>寻找native方法的实现C++源码, 下载<a href="https://github.com/openjdk/jdk/tags?after=jdk8-b114">OpenJDK</a>源码, 在<code>jdk\src\share\native</code>你可以找到C/C++源码</p>
<ul>
<li>jdk\src\linux source for linux.</li>
<li>jdk\src\windows source for windows.</li>
<li>jdk\src\solaris souce for solaris.</li>
<li>jd\src\share common source.</li>
</ul>
<p>最后在<code>hotspot\src\share\vm\oops\objArrayKlass.cpp</code>168行, 其中有copy_array方法, 大概思路是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    dest[destPos] = src[srcPos]</span><br><span class="line">    destPos++;</span><br><span class="line">    srcPos++;</span><br><span class="line">    length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果List集合对应的数组是<code>[a, b, c, d, e]</code>, 现在执行<code>.remove(0)</code>, 调用<code>System.arraycopy(elementData, 1, elementData, 0, 4)</code>后得到的<code>elementData</code>是<code>[b, c, d, e, e]</code>, 数组的长度不会发生变化. 紧接着执行<code>elementData[--size] = null</code>, <code>[b, c, d, e, null]</code>, 完成操作. 源码注释中解释到: <strong>clear to let GC do its work</strong>, 让GC完成接下来的工作, 此时ArrayList.size已经减1, 但是由于数组在被创建出来以后长度无法更改, 所以其对应的数组<code>elementData</code>的长度依然不变.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br></pre></td></tr></table></figure>
<p>这样一行代码让人感觉很奇怪. 首先, 数组中的最后一个元素是由于所有位置的元素向前移动而多出来的, 这个元素的值不应该能被外界访问到; 再者, 这个元素可能会在程序中保持很长时间(因为List容器还在使用暂时无法回收), 也不应该再被使用, 设为null, 做为一个垃圾回收的标志.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Maven Wrapper最佳实践</title>
    <url>/2021/11/07/maven-wrapper/</url>
    <content><![CDATA[<p>将一个maven项目所有信息都保留在项目根目录下, 包括maven本身</p>
<h2 id="结合IDEA的最佳实践"><a href="#结合IDEA的最佳实践" class="headerlink" title="结合IDEA的最佳实践"></a>结合IDEA的最佳实践</h2><p>收到这个”捆绑思想”的影响. 我希望我可以在开发时, 将项目中的依赖从本地仓库中分离. 一个项目一个依赖库, 就比如node_modules.</p>
<ol>
<li>安装好maven wrapper, 在<code>$PROJECT_DIR$</code>下执行: <code>$mvn -N io.takari:maven:wrapper [-Dmaven=3.6.3]</code></li>
<li>复制一个<code>settings.xml</code>到<code>$PROJECT_DIR$/.mvn/</code>下</li>
<li><code>$PROJECT_DIR$/.mvn/</code>新建文件夹<code>repository</code></li>
<li>IDEA中配置<code>Setting &gt; Build, Execution, Deployment &gt; Build Tools &gt; Maven</code></li>
</ol>
<ul>
<li>修改<code>Maven Home Path</code>为<code>Use Maven wrapper</code>, 如果发现没有这个选项说明IDEA没有更新(至少要2021.2.3+的版本)</li>
<li>修改<code>User settings file</code>为<code>$PROJECT_DIR$/.mvn/settings.xml</code></li>
<li>修改<code>Local repository</code>为<code>$PROJECT_DIR$/.mvn/repository</code></li>
</ul>
<h2 id="Maven-Wrapper安装"><a href="#Maven-Wrapper安装" class="headerlink" title="Maven Wrapper安装"></a>Maven Wrapper安装</h2><p>在项目根目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -N io.takari:maven:0.7.7:wrapper</span><br><span class="line">mvn -N io.takari:maven:wrapper -Dmaven=3.6.3</span><br></pre></td></tr></table></figure>
<p>This creates two files (mvnw, mvnw.cmd) and a hidden directory (.mvn). mvnw can be used in Unix-like environments and mvnw.cmd can be used in Windows.<br>这将会创建两个文件和一个目录. <code>mvnw</code>用来Unix-like环境, <code>mvnw.cmd</code>用在Windows环境.</p>
<p>Instead of the usual mvn command, they would use mvnw. for example:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./mvnw clean install</span><br></pre></td></tr></table></figure>

<h2 id="Maven-Wrapper原理"><a href="#Maven-Wrapper原理" class="headerlink" title="Maven Wrapper原理"></a>Maven Wrapper原理</h2><p>The <code>.mvn/wrapper</code> directory has a jar file <code>maven-wrapper.jar</code> that downloads the required version of Maven if it’s not already present. It installs it in the <code>./m2/wrapper/dists</code> directory under the user’s home directory.</p>
<p>Where does it download Maven from? This information is present in the mvn/wrapper/maven-wrapper.properties file:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">distributionUrl</span>=<span class="string">https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip</span></span><br><span class="line"><span class="attr">wrapperUrl</span>=<span class="string">https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.5.6/maven-wrapper-0.5.6.jar</span></span><br></pre></td></tr></table></figure>

<h2 id="Maven-Wrapper贯彻的思想"><a href="#Maven-Wrapper贯彻的思想" class="headerlink" title="Maven Wrapper贯彻的思想"></a>Maven Wrapper贯彻的思想</h2><p>Years ago, I was on a team developing a desktop-based Java application. We wanted to share our artifact with a couple of business users in the field to get some feedback. It was unlikely they had Java installed. Asking them to download, install, and configure version 1.2 of Java (yes, this was that long ago!) to run our application would have been a hassle for them.</p>
<p>Looking around trying to find how others had solved this problem, I came across this idea of <strong>“bundling the JRE”</strong>. The idea was to include within the artifact itself the Java Runtime Environment that our application depended on. Then users don’t need to have a particular version or even any version of Java pre-installed - a neat solution to a specific problem.</p>
<p>Over the years I came across this idea in many places. Today when we containerize our application for cloud deployment, it’s the same general idea: encapsulate the dependent and its dependency into a single unit to hide some complexity.<br>The Maven Wrapper makes it easy to build our code on any machine, including CI/CD servers. We don’t have to worry about installing the right version of Maven on the CI servers anymore!</p>
]]></content>
      <categories>
        <category>Package Manager</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2022/11/29/mysql-transaction/</url>
    <content><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>MySQL中事务的默认隔离级别是Repeatable read（可重复读），开发中如果遇到调试的问题时，要看当前未提交的数据时，我们可以在图形客户端（如：DBeaver）中打开一个会话，在这个会话中临时修改当前的数据库隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>流式编程</title>
    <url>/2021/06/07/java-streams/</url>
    <content><![CDATA[<p>Java8引入新的概念Streams. 如何将此融入到现有的生态百万行代码的类库中. 一个巨大挑战来自使用接口的库, 如果将一个新的方法添加到接口, 那就破坏了每一个实现接口的类,因为这些类要实现你新添加的方法.<br>设计者给出的解决方案是, 在接口中添加被default修饰的方法.<br>通过这种方案, 将流式编程平滑地嵌入到现有的类中.<br>流的操作有三种: creating streams, intermediate operations, terminal operations.</p>
<blockquote><p><strong>Declarative programming</strong> is a style where we state what we want done, rather than<br>specifying how, and it’s what you see in functional programming. Notice it’s much<br>more difficult to understand the <strong>imperative programming</strong>.</p>
<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>
<p>对比一下声明式编程和命令式编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declarative programming</span></span><br><span class="line"><span class="keyword">new</span> Random(<span class="number">47</span>).ints(<span class="number">5</span>, <span class="number">20</span>).distinct().limit(<span class="number">7</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Imperative programming</span></span><br><span class="line">Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">SortedSet&lt;Integer&gt; rints = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(rints.size() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> r = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">    rints.add(r);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(rints);</span><br></pre></td></tr></table></figure>
<p>显然命令式编程更难理解, 而且在Streams过程中, 没有明显地看到任何变量的定义.<br>语义清晰是Java Stream API的优点之一.</p>
<h1 id="Creating-Streams"><a href="#Creating-Streams" class="headerlink" title="Creating Streams"></a>Creating Streams</h1><ol>
<li>通过Streams.of(…)将一组元素转换为Stream</li>
<li>每隔集合可以通过调用其<code>.stream()</code>方法来产生一个流.</li>
<li><code>Stream.generate(...)</code>, generate接收一个参数<code>Supplier&lt;T&gt;</code>, 通过调用实现了<code>Supplier&lt;T&gt;</code>接口的类的get方法(也可以传Lambda表达式, 原理也是有个类实现了Supplier接口, 具体在函数式编程里有详细介绍). 不过generate必须有一个限制, 不能无限制的运行. 否则会造成<code>java.lang.OutOfMemoryError: Java heap space</code>错误. 比如, 中间加入了limit函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(() -&gt; <span class="string">&quot;h&quot;</span>).limit(<span class="number">30</span>).collect(Collectors.joining());</span><br></pre></td></tr></table></figure></li>
<li><code>Stream.iterate(...)</code>, iterate接收的参数第一个是seed, 第二个其实是<code>Function&lt;T&gt;</code>, 如下例子, 生成斐波那契数列:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// seed将会作为i的初始化值, 返回值y将作为参数再次会传递给该函数</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, (i) -&gt; &#123;<span class="keyword">int</span> y = i + x; x = i; <span class="keyword">return</span> y;&#125;).limit(<span class="number">30</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
<li>使用建造者模式. 其实建造者模式类似于新建一个集合, 然后往里put元素.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.Builder&lt;String&gt; builder = Stream.builder();</span><br><span class="line">String res = builder.build().map(...).collect(Collector.joining(<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><code>Arrays.stream()</code></li>
</ol>
<h1 id="Intermediate-Operations"><a href="#Intermediate-Operations" class="headerlink" title="Intermediate Operations"></a>Intermediate Operations</h1><ol>
<li>.map(…)</li>
<li>.peek(…), 使用peek()帮助调试</li>
<li>.skip(…)</li>
<li>.limit(…)</li>
<li>.sorted(Comparator.reverseOrder())</li>
<li>.filter(Predicate)</li>
<li>.distinct()</li>
<li>parallel(), 这个重点说一下, 这个是将流中计算机制换为并行计算, 所以最终输出元素的顺序是随机的. 要是再此基础上要得到有序的输出, 需要上如<code>forEachOrdered(...)</code>等的Terminal Operations</li>
</ol>
<h1 id="Terminal-Operations"><a href="#Terminal-Operations" class="headerlink" title="Terminal Operations"></a>Terminal Operations</h1><ol>
<li>.collect(Collector.toList())</li>
<li>.toArray()</li>
<li>.forEach()</li>
<li>.reduce(…), 最终输出的是一个元素. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reduce函数功能展示</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerSupplier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个100以内的随机数流(建造者模式)</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> Stream&lt;Integer&gt; <span class="title">supply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Random rand = <span class="keyword">new</span> Random(<span class="number">15</span>);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> BOUND = <span class="number">100</span>;</span><br><span class="line">		Stream.Builder&lt;Integer&gt; builder = Stream.builder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">			builder.add(rand.nextInt(BOUND));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> builder.build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reduce</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// reduce(BinaryOperator), BinaryOperator这个函数式接口对应的函数只有两个参数</span></span><br><span class="line">		<span class="comment">// 其中fr0既作为初始化的第一个值, 又作为每次的返回值传入, 在输出中可以看到</span></span><br><span class="line">		<span class="comment">// 最终reduce返回的值, Integer被Optional包裹</span></span><br><span class="line">		IntegerSupplier.supply().reduce((fr0, fr1) -&gt; &#123;</span><br><span class="line">			System.out.println(fr0 + <span class="string">&quot;--compare to--&quot;</span> + fr1);</span><br><span class="line">			<span class="keyword">return</span> fr0 &lt; fr1 ? fr0 : fr1;</span><br><span class="line">		&#125;).ifPresent(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">/* 41--compare to--72</span></span><br><span class="line"><span class="comment"> * 72--compare to--38</span></span><br><span class="line"><span class="comment"> * 72--compare to--67</span></span><br><span class="line"><span class="comment"> * 72--compare to--85</span></span><br><span class="line"><span class="comment"> * 85--compare to--60</span></span><br><span class="line"><span class="comment"> * 85--compare to--59</span></span><br><span class="line"><span class="comment"> * Optional[85]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h3><p>为了防止流执行的过程中, 出现”空流”而中断抛出异常, 所以引入了Optional类, 为空时将会返回<code>Optional.empty</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空流, 等价于: Stream&lt;String&gt; s = Stream.empty();</span></span><br><span class="line">Stream.&lt;String&gt;empty().findFirst()</span><br><span class="line"><span class="comment">// output: Optional.empty</span></span><br></pre></td></tr></table></figure>
<p>原理是将返回值塞到了Optional对象中, Optional类提供了很多诸如<code>isPresent()</code>, <code>orElse</code>, <code>orElseGet</code>等方法, 在Python3.7以后引入类型系统后也有了Optional类型, 如果一个变量被标识为Optional, 那么这个对象可能为none.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>network-http-message</title>
    <url>/2022/07/31/network-http/</url>
    <content><![CDATA[<h5 id="Web的应用层协议是HTTP-HyperText-Transfer-Protocol-HTTP-，HTTP使用TCP作为支撑它的传输层协议，定义在-RFC-1945-和-RFC-2616"><a href="#Web的应用层协议是HTTP-HyperText-Transfer-Protocol-HTTP-，HTTP使用TCP作为支撑它的传输层协议，定义在-RFC-1945-和-RFC-2616" class="headerlink" title="Web的应用层协议是HTTP(HyperText Transfer Protocol, HTTP)，HTTP使用TCP作为支撑它的传输层协议，定义在[RFC 1945]和[RFC 2616]"></a>Web的应用层协议是HTTP(HyperText Transfer Protocol, HTTP)，HTTP使用TCP作为支撑它的传输层协议，定义在<code>[RFC 1945]</code>和<code>[RFC 2616]</code></h5><h5 id="HTTP定义了浏览器和Web服务器之间的传输的message-报文-格式和序列，HTTP服务器不保存关于客户端的任何信息，它一种无状态协议-stateless-protocol"><a href="#HTTP定义了浏览器和Web服务器之间的传输的message-报文-格式和序列，HTTP服务器不保存关于客户端的任何信息，它一种无状态协议-stateless-protocol" class="headerlink" title="HTTP定义了浏览器和Web服务器之间的传输的message(报文)格式和序列，HTTP服务器不保存关于客户端的任何信息，它一种无状态协议(stateless protocol)"></a>HTTP定义了浏览器和Web服务器之间的传输的message(报文)格式和序列，HTTP服务器不保存关于客户端的任何信息，它一种无状态协议(stateless protocol)</h5><ol>
<li>HTTP协议是在应用程序中实现的</li>
</ol>
<h5 id="在HTTP-1-1中，每个请求和响应是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送，采用前一种，被称为non-persistent-connection-非持续连接-，后一种被称为persistent-connection-持续连接"><a href="#在HTTP-1-1中，每个请求和响应是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送，采用前一种，被称为non-persistent-connection-非持续连接-，后一种被称为persistent-connection-持续连接" class="headerlink" title="在HTTP/1.1中，每个请求和响应是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送，采用前一种，被称为non-persistent connection(非持续连接)，后一种被称为persistent connection(持续连接)"></a>在HTTP/1.1中，每个请求和响应是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送，采用前一种，被称为non-persistent connection(非持续连接)，后一种被称为persistent connection(持续连接)</h5><ol>
<li>非持续连接，必须为每一个请求的对象建立和维护一个全新的TCP连接</li>
<li>在采用HTTP/1.1持续连接(Connection:keep-alive)的情况下，服务器在发送响应后保持该TCP连接打开，后续的请求和响应报文能够通过相同的连接进行传送，如果一个连接经过一定时间间隔(一个可配置的超时间隔)仍未被使用，HTTP服务器就关闭该连接</li>
<li>HTTP/1.1的持续连接与WebSocket协议是完全不同的，前者是在HTTP/1.0的基础上进行了优化，减少连接的建立次数来提高性能，但仍然是请求-响应式的。而WebSocket是一种全双工通信，可以进行双向的实时通信，不需要每次都发送HTTP请求和响应的繁琐报文</li>
</ol>
<h5 id="HTTP报文格式的分为请求报文和相应报文"><a href="#HTTP报文格式的分为请求报文和相应报文" class="headerlink" title="HTTP报文格式的分为请求报文和相应报文"></a>HTTP报文格式的分为请求报文和相应报文</h5><ol>
<li>请求报文的格式：</li>
</ol>
<ul>
<li>request line</li>
<li>header line</li>
<li>entity body<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.some.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close8724</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilia/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>响应报文的格式：</li>
</ol>
<ul>
<li>status line</li>
<li>header line</li>
<li>entiry body<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:44:01 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.2.3 (CentOS)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tue, 18 Aug 2015 15:11:03 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="haskell">(<span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>network-socket-program</title>
    <url>/2022/08/05/network-socket-program/</url>
    <content><![CDATA[<h5 id="Socket编程样例"><a href="#Socket编程样例" class="headerlink" title="Socket编程样例"></a>Socket编程样例</h5><blockquote>
<p>TCPClient.py</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&#x27;servername&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接的过程                                                                            [1]</span></span><br><span class="line">clientSocket.connect(serverName, serverPort)</span><br><span class="line">sentence = raw_input(<span class="string">&#x27;input lowercase sentence:&#x27;</span>)</span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;From Server: &#x27;</span>, modifiedSentence.decode())</span><br><span class="line">clientSocket.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TCPServer.py</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&#x27;servername&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">socketSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">socketSocket.bind(<span class="string">&#x27;&#x27;</span>, serverPort)</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The Server is ready to receive&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># server socket调用其accept方法，在服务器中专门创建了一个connection socket由特定客户端使用  [2]</span></span><br><span class="line">	connectionSocket, addr = serverSocket.accept()</span><br><span class="line">	sentence = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">	capitalizedSentence = sentence.upper()</span><br><span class="line">	connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">	connectionSocket.close()</span><br></pre></td></tr></table></figure>

<p>以上两端代码模拟了传输层socket通信的样例</p>
<ul>
<li>[1] 表示三次握手，建立socket连接</li>
<li>[2] 表示了最原始的”阻塞式IO”处理客户端的消息的过程，这是一种比较原始且低效的做法，高效的做法是<em>IO多路复用</em>的做法参照<a href="/2023/06/12/network-io-multiplex/" title="图解多路复用">图解多路复用</a></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>图解 | 原来这就是 IO 多路复用</title>
    <url>/2023/06/12/network-io-multiplex/</url>
    <content><![CDATA[<p>进程创建和上下文切换，在Linux上是开销很大的，一次上下文切换就有好几个微妙，所以为了能够高效地对海量用户提供服务，必须让一个进程处理多个tcp连接。<br>如果某个进程保持了10000条连接，那么如何发现哪条连接有数据可读，或者有数据可写了呢？<br>我们当然可以将所有连接遍历一遍，但是太低级，我们希望，将很多连接中有IO事件发生的时候直接将其get出来，Linux给我们提供了系统调用，这就是IO多路复用，这里的复用指的是对进程的复用，一个进程就可以处理多个客户端连接。<br>Linux提供了多个IO多路复用的函数，select，poll，epoll，它们三个，epoll性能最好<br>从阻塞IO到IO多路服用的历史发展过程</p>
<h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">listenfd = socket();   <span class="comment">// 打开一个网络通信端口</span></span><br><span class="line">bind(listenfd);        <span class="comment">// 绑定</span></span><br><span class="line">listen(listenfd);      <span class="comment">// 监听</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 阻塞建立连接，一个socket连接对于操作系统来说就是最后就是一个文件，我们用文件描述符来标识它，那么操作系统就可以根据这个文件描述符来do something了</span></span><br><span class="line">  connfd = accept(listenfd);  </span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会执行得磕磕绊绊，就像这样。<br><img src="/blocking-io-1.image"></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p><img src="/blocking-io-2.image"></p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。<br><img src="/blocking-io-3.image"></p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  pthread_create(doWork);  <span class="comment">// 创建一个新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。<br><img src="/no-blocking-io-1.image"></p>
<p>不过，<em>这不叫非阻塞 IO</em>，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以<em>真正的非阻塞 IO</em>，不能是通过我们用户层的小把戏，而是要恳请操作系统为我们提供一个非阻塞的 read 函数。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line"><span class="keyword">int</span> n = (read(connfd, buffer) != SUCCESS);</span><br></pre></td></tr></table></figure>
<p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。<br><img src="/no-blocking-io-2.image"></p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图。<br><img src="/no-blocking-io-3.image"></p>
<h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。<br><img src="/multiplexing-1.image"></p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<p><code>connfdList.add(connfd);</code><br>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里涉及到，一边往connfdList中放置文件描述符connfd，一边又要遍历它</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- connfdList) &#123;</span><br><span class="line">    <span class="keyword">if</span>(read(fd) != <span class="number">-1</span>) &#123;</span><br><span class="line">      doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就成功用一个线程处理了多个客户端连接。 <em>一个线程去处理多个连接就是socket中的IO多路复用，就这么简单，其实代码写的很烂的</em><br><img src="/multiplexing-2.image"></p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：<br><img src="/multiplexing-3.image"></p>
<p>select系统调用的函数定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// nfds:监控的文件描述符集里最大文件描述符加1</span></span><br><span class="line"><span class="comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span></span><br><span class="line"><span class="comment">// timeout：定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">//  1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">//  2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br></pre></td></tr></table></figure>
<p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);</span><br><span class="line">  fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">  fdlist.add(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 把一堆文件描述符 list 传给 select 函数</span></span><br><span class="line">  <span class="comment">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span></span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  <span class="comment">// 用户层依然要遍历，只不过少了很多无效的系统调用</span></span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 只读已就绪的文件描述符</span></span><br><span class="line">      read(fd, buf);</span><br><span class="line">      <span class="comment">// 总共只有 nready 个已就绪描述符，不用过多遍历</span></span><br><span class="line">      <span class="keyword">if</span>(--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如刚刚的动图中所描述的，其直观效果如下。<br><img src="/multiplexing-3.image"></p>
<p>可以看出几个细节：</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p><em>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</em></p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>整个 select 的流程图如下。<br><img src="/multiplexing-4.image"></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 也是操作系统提供的系统调用函数。 polling在计算机中意思为：轮询</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, nfds_tnfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  intfd; <span class="comment">/*文件描述符*/</span></span><br><span class="line">  shortevents; <span class="comment">/*监控的事件*/</span></span><br><span class="line">  shortrevents; <span class="comment">/*监控事件中满足条件返回的事件*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。<em>epoll中的e代表的是event</em></p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。<em>由于计算机硬件芯片的发展，内存越来越大，可以用空间换时间了，在内存中有了一个cache map</em></p>
</li>
<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p>具体，操作系统提供了这三个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步，创建一个 epoll 句柄(Handle)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 第二步，向内核添加、修改或删除要监控的文件描述符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 第三步，类似发起了 select() 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> max events, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 使用起来，其内部原理就像如下一般丝滑。</span></span><br></pre></td></tr></table></figure>
<p><img src="/multiplexing-5.image"></p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《图解 深入揭秘 epoll 是如何实现 IO 多路复用的！》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 阻塞 IO。</p>
<p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了<em>非阻塞的 read 函数</em>，这样程序员就可以在<em>一个线程内完成多个文件描述符的读取（就有点IO多路复用的意思了）</em>，这就是 非阻塞 IO。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p>
<p>于是又在操作系统层面提供了这样的遍历文件描述符的机制，表现为<em>单个进程可以处理多个客户端连接</em>，这就是 IO 多路复用。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 前两者 的三个不足：</p>
<ol>
<li>不需要把文件描述符数组从用户态拷贝到内核态，因为内核态已经存了一份。通过epoll_create会增删改文件描述符组成的红黑树</li>
<li>内核态不需要遍历整个文件描述符集合，而是通过传入事件参数event，event可以直接定位哪个文件描述符有数据到达，就是所谓的异步IO事件唤醒</li>
<li>返回有IO事件的文件描述符，不需要用户去遍历这个文件描述符集合</li>
</ol>
<p><em>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。</em></p>
<p>如果你建立了这样的思维，很容易发现网上的一些错误。</p>
<p>比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。</p>
<p>而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。</p>
<p>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加，一个道理。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>WebSocket协议</title>
    <url>/2023/02/21/network-websocket/</url>
    <content><![CDATA[<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>The <code>WebSocket</code> protocol, described in the specification <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>, provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and the need of additional HTTP-requests.</p>
<p>WebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.</p>
<h2 id="A-simple-example"><a href="#A-simple-example" class="headerlink" title="A simple example"></a>A simple example</h2><p>To open a websocket connection, we need to create <code>new WebSocket</code> using the special protocol <code>ws</code> in the url:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;*!*ws*/!*://javascript.info&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>There’s also encrypted <code>wss://</code> protocol. It’s like HTTPS for websockets.</p>
<figure class="highlight plaintext"><figcaption><span>header</span></figcaption><table><tr><td class="code"><pre><span class="line">The `wss://` protocol is not only encrypted, but also more reliable.</span><br><span class="line"></span><br><span class="line">That&#x27;s because `ws://` data is not encrypted, visible for any intermediary. Old proxy servers do not know about WebSocket, they may see &quot;strange&quot; headers and abort the connection.</span><br><span class="line"></span><br><span class="line">On the other hand, `wss://` is WebSocket over TLS, (same as HTTPS is HTTP over TLS), the transport security layer encrypts the data at the sender and decrypts it at the receiver. So data packets are passed encrypted through proxies. They can&#x27;t see what&#x27;s inside and let them through.</span><br></pre></td></tr></table></figure>

<p>Once the socket is created, we should listen to events on it. There are totally 4 events:</p>
<ul>
<li><strong><code>open</code></strong> – connection established,</li>
<li><strong><code>message</code></strong> – data received,</li>
<li><strong><code>error</code></strong> – websocket error,</li>
<li><strong><code>close</code></strong> – connection closed.</li>
</ul>
<p>…And if we’d like to send something, then <code>socket.send(data)</code> will do that.</p>
<p>Here’s an example:</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://javascript.info/article/websocket/demo/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;[open] Connection established&quot;</span>);</span><br><span class="line">  alert(<span class="string">&quot;Sending to server&quot;</span>);</span><br><span class="line">  socket.send(<span class="string">&quot;My name is John&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`[message] Data received from server: <span class="subst">$&#123;event.data&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.wasClean) &#123;  </span><br><span class="line">    alert(<span class="string">`[close] Connection closed cleanly, code=<span class="subst">$&#123;event.code&#125;</span> reason=<span class="subst">$&#123;event.reason&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// e.g. server process killed or network down</span></span><br><span class="line">    <span class="comment">// event.code is usually 1006 in this case</span></span><br><span class="line">    alert(<span class="string">&#x27;[close] Connection died&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">`[error]`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>For demo purposes, there’s a small server <a href="demo/server.js">server.js</a> written in Node.js, for the example above, running. It responds with “Hello from server, John”, then waits 5 seconds and closes the connection.</p>
<p>So you’ll see events <code>open</code> -&gt; <code>message</code> -&gt; <code>close</code>.</p>
<p>That’s actually it, we can talk WebSocket already. Quite simple, isn’t it?</p>
<p>Now let’s talk more in-depth.</p>
<h2 id="Opening-a-websocket"><a href="#Opening-a-websocket" class="headerlink" title="Opening a websocket"></a>Opening a websocket</h2><p>When <code>new WebSocket(url)</code> is created, it starts connecting immediately.</p>
<p>During the connection, the browser (using headers) asks the server: “Do you support Websocket?” And if the server replies “yes”, then the talk continues in WebSocket protocol, which is not HTTP at all.</p>
<p><img src="/websocket-handshake.svg"></p>
<p>Here’s an example of browser headers for a request made by <code>new WebSocket(&quot;wss://javascript.info/chat&quot;)</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /chat</span><br><span class="line">Host: javascript.info</span><br><span class="line">Origin: https://javascript.info</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Origin</code> – the origin of the client page, e.g. <code>https://javascript.info</code>. WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compatibility issues. But the <code>Origin</code> header is important, as it allows the server to decide whether or not to talk WebSocket with this website.</li>
<li><code>Connection: Upgrade</code> – signals that the client would like to change the protocol.</li>
<li><code>Upgrade: websocket</code> – the requested protocol is “websocket”.</li>
<li><code>Sec-WebSocket-Key</code> – a random browser-generated key, used to ensure that the server supports WebSocket protocol. It’s random to prevent proxies from caching any following communication.</li>
<li><code>Sec-WebSocket-Version</code> – WebSocket protocol version, 13 is the current one.</li>
</ul>
<figure class="highlight plaintext"><figcaption><span>header</span></figcaption><table><tr><td class="code"><pre><span class="line">We can&#x27;t use `XMLHttpRequest` or `fetch` to make this kind of HTTP-request, because JavaScript is not allowed to set these headers.</span><br></pre></td></tr></table></figure>

<p>If the server agrees to switch to WebSocket, it should send code 101 response:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=</span><br></pre></td></tr></table></figure>

<p>Here <code>Sec-WebSocket-Accept</code> is <code>Sec-WebSocket-Key</code>, recoded using a special algorithm. Upon seeing it, the browser understands that the server really does support the WebSocket protocol.</p>
<p>Afterwards, the data is transferred using the WebSocket protocol, we’ll see its structure (“frames”) soon. And that’s not HTTP at all.</p>
<h3 id="Extensions-and-subprotocols"><a href="#Extensions-and-subprotocols" class="headerlink" title="Extensions and subprotocols"></a>Extensions and subprotocols</h3><p>There may be additional headers <code>Sec-WebSocket-Extensions</code> and <code>Sec-WebSocket-Protocol</code> that describe extensions and subprotocols.</p>
<p>For instance:</p>
<ul>
<li><p><code>Sec-WebSocket-Extensions: deflate-frame</code> means that the browser supports data compression. An extension is something related to transferring the data, functionality that extends the WebSocket protocol. The header <code>Sec-WebSocket-Extensions</code> is sent automatically by the browser, with the list of all extensions it supports.</p>
</li>
<li><p><code>Sec-WebSocket-Protocol: soap, wamp</code> means that we’d like to transfer not just any data, but the data in <a href="https://en.wikipedia.org/wiki/SOAP">SOAP</a> or WAMP (“The WebSocket Application Messaging Protocol”) protocols. WebSocket subprotocols are registered in the <a href="https://www.iana.org/assignments/websocket/websocket.xml">IANA catalogue</a>. So, this header describes the data formats that we’re going to use.</p>
<p>  This optional header is set using the second parameter of <code>new WebSocket</code>. That’s the array of subprotocols, e.g. if we’d like to use SOAP or WAMP:</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://javascript.info/chat&quot;</span>, [<span class="string">&quot;soap&quot;</span>, <span class="string">&quot;wamp&quot;</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>The server should respond with a list of protocols and extensions that it agrees to use.</p>
<p>For example, the request:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /chat</span><br><span class="line">Host: javascript.info</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: https://javascript.info</span><br><span class="line">Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">*!*</span><br><span class="line">Sec-WebSocket-Extensions: deflate-frame</span><br><span class="line">Sec-WebSocket-Protocol: soap, wamp</span><br><span class="line">*/!*</span><br></pre></td></tr></table></figure>

<p>Response:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=</span><br><span class="line">*!*</span><br><span class="line">Sec-WebSocket-Extensions: deflate-frame</span><br><span class="line">Sec-WebSocket-Protocol: soap</span><br><span class="line">*/!*</span><br></pre></td></tr></table></figure>

<p>Here the server responds that it supports the extension “deflate-frame”, and only SOAP of the requested subprotocols.</p>
<h2 id="Data-transfer"><a href="#Data-transfer" class="headerlink" title="Data transfer"></a>Data transfer</h2><p>WebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:</p>
<ul>
<li>“text frames” – contain text data that parties send to each other.</li>
<li>“binary data frames” – contain binary data that parties send to each other.</li>
<li>“ping/pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.</li>
<li>there’s also “connection close frame” and a few other service frames.</li>
</ul>
<p>In the browser, we directly work only with text or binary frames.</p>
<p><strong>WebSocket <code>.send()</code> method can send either text or binary data.</strong></p>
<p>A call <code>socket.send(body)</code> allows <code>body</code> in string or a binary format, including <code>Blob</code>, <code>ArrayBuffer</code>, etc. No settings are required: just send it out in any format.</p>
<p><strong>When we receive the data, text always comes as string. And for binary data, we can choose between <code>Blob</code> and <code>ArrayBuffer</code> formats.</strong></p>
<p>That’s set by <code>socket.binaryType</code> property, it’s <code>&quot;blob&quot;</code> by default, so binary data comes as <code>Blob</code> objects.</p>
<p><a href="info:blob">Blob</a> is a high-level binary object, it directly integrates with <code>&lt;a&gt;</code>, <code>&lt;img&gt;</code> and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to <code>&quot;arraybuffer&quot;</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.binaryType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">socket.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// event.data is either a string (if text) or arraybuffer (if binary)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Rate-limiting"><a href="#Rate-limiting" class="headerlink" title="Rate limiting"></a>Rate limiting</h2><p>Imagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile internet, outside of a city.</p>
<p>We can call <code>socket.send(data)</code> again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.</p>
<p>The <code>socket.bufferedAmount</code> property stores how many bytes remain buffered at this moment, waiting to be sent over the network.</p>
<p>We can examine it to see whether the socket is actually available for transmission.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// every 100ms examine the socket and send more data  </span></span><br><span class="line"><span class="comment">// only if all the existing data was sent out</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>) &#123;</span><br><span class="line">    socket.send(moreData());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>


<h2 id="Connection-close"><a href="#Connection-close" class="headerlink" title="Connection close"></a>Connection close</h2><p>Normally, when a party wants to close the connection (both browser and server have equal rights), they send a “connection close frame” with a numeric code and a textual reason.</p>
<p>The method for that is:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.close([code], [reason]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>code</code> is a special WebSocket closing code (optional)</li>
<li><code>reason</code> is a string that describes the reason of closing (optional)</li>
</ul>
<p>Then the other party in the <code>close</code> event handler gets the code and the reason, e.g.:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// closing party:</span></span><br><span class="line">socket.close(<span class="number">1000</span>, <span class="string">&quot;Work complete&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the other party</span></span><br><span class="line">socket.onclose = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// event.code === 1000</span></span><br><span class="line">  <span class="comment">// event.reason === &quot;Work complete&quot;</span></span><br><span class="line">  <span class="comment">// event.wasClean === true (clean close)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Most common code values:</p>
<ul>
<li><code>1000</code> – the default, normal closure (used if no <code>code</code> supplied),</li>
<li><code>1006</code> – no way to set such code manually, indicates that the connection was lost (no close frame).</li>
</ul>
<p>There are other codes like:</p>
<ul>
<li><code>1001</code> – the party is going away, e.g. server is shutting down, or a browser leaves the page,</li>
<li><code>1009</code> – the message is too big to process,</li>
<li><code>1011</code> – unexpected error on server,</li>
<li>…and so on.</li>
</ul>
<p>The full list can be found in <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1">RFC6455, §7.4.1</a>.</p>
<p>WebSocket codes are somewhat like HTTP codes, but different. In particular, codes lower than <code>1000</code> are reserved, there’ll be an error if we try to set such a code.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in case connection is broken</span></span><br><span class="line">socket.onclose = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// event.code === 1006</span></span><br><span class="line">  <span class="comment">// event.reason === &quot;&quot;</span></span><br><span class="line">  <span class="comment">// event.wasClean === false (no closing frame)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Connection-state"><a href="#Connection-state" class="headerlink" title="Connection state"></a>Connection state</h2><p>To get connection state, additionally there’s <code>socket.readyState</code> property with values:</p>
<ul>
<li><strong><code>0</code></strong> – “CONNECTING”: the connection has not yet been established,</li>
<li><strong><code>1</code></strong> – “OPEN”: communicating,</li>
<li><strong><code>2</code></strong> – “CLOSING”: the connection is closing,</li>
<li><strong><code>3</code></strong> – “CLOSED”: the connection is closed.</li>
</ul>
<h2 id="Chat-example"><a href="#Chat-example" class="headerlink" title="Chat example"></a>Chat example</h2><p>Let’s review a chat example using browser WebSocket API and Node.js WebSocket module <a href="https://github.com/websockets/ws">https://github.com/websockets/ws</a>. We’ll pay the main attention to the client side, but the server is also simple.</p>
<p>HTML: we need a <code>&lt;form&gt;</code> to send messages and a <code>&lt;div&gt;</code> for incoming messages:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- message form --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;publish&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- div with messages --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;messages&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>From JavaScript we want three things:</p>
<ol>
<li>Open the connection.</li>
<li>On form submission – <code>socket.send(message)</code> for the message.</li>
<li>On incoming message – append it to <code>div#messages</code>.</li>
</ol>
<p>Here’s the code:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://javascript.info/article/websocket/chat/ws&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// send message from the form</span></span><br><span class="line"><span class="built_in">document</span>.forms.publish.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> outgoingMessage = <span class="built_in">this</span>.message.value;</span><br><span class="line"></span><br><span class="line">  socket.send(outgoingMessage);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// message received - show the message in div#messages</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message = event.data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> messageElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  messageElem.textContent = message;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;messages&#x27;</span>).prepend(messageElem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server-side code is a little bit beyond our scope. Here we’ll use Node.js, but you don’t have to. Other platforms also have their means to work with WebSocket.</p>
<p>The server-side algorithm will be:</p>
<ol>
<li>Create <code>clients = new Set()</code> – a set of sockets.</li>
<li>For each accepted websocket, add it to the set <code>clients.add(socket)</code> and set <code>message</code> event listener to get its messages.</li>
<li>When a message is received: iterate over clients and send it to everyone.</li>
<li>When a connection is closed: <code>clients.delete(socket)</code>.</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> ws.Server(&#123;<span class="attr">noServer</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clients = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// here we only handle websocket connections</span></span><br><span class="line">  <span class="comment">// in real project we&#x27;d have some other code here to handle non-websocket requests</span></span><br><span class="line">  wss.handleUpgrade(req, req.socket, Buffer.alloc(<span class="number">0</span>), onSocketConnect);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onSocketConnect</span>(<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  clients.add(ws);</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    message = message.slice(<span class="number">0</span>, <span class="number">50</span>); <span class="comment">// max message length will be 50</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> client <span class="keyword">of</span> clients) &#123;</span><br><span class="line">      client.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clients.delete(ws);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Here’s the working example:</p>
<p>[iframe src=”chat” height=”100” zip]</p>
<p>You can also download it (upper-right button in the iframe) and run it locally. Just don’t forget to install <a href="https://nodejs.org/en/">Node.js</a> and <code>npm install ws</code> before running.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>WebSocket is a modern way to have persistent browser-server connections.</p>
<ul>
<li>WebSockets don’t have cross-origin limitations.</li>
<li>They are well-supported in browsers.</li>
<li>Can send/receive strings and binary data.</li>
</ul>
<p>The API is simple.</p>
<p>Methods:</p>
<ul>
<li><code>socket.send(data)</code>,</li>
<li><code>socket.close([code], [reason])</code>.</li>
</ul>
<p>Events:</p>
<ul>
<li><code>open</code>,</li>
<li><code>message</code>,</li>
<li><code>error</code>,</li>
<li><code>close</code>.</li>
</ul>
<p>WebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it’s also possible to implement these capabilities manually.</p>
<p>Sometimes, to integrate WebSocket into existing projects, people run a WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use <code>wss://ws.site.com</code>, a subdomain that leads to the WebSocket server, while <code>https://site.com</code> goes to the main HTTP-server.</p>
<p>Surely, other ways of integration are also possible.</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>network</title>
    <url>/2022/07/31/network/</url>
    <content><![CDATA[<h5 id="网络通信有两种体系结构：客户-服务器体系结构、P2P体系结构"><a href="#网络通信有两种体系结构：客户-服务器体系结构、P2P体系结构" class="headerlink" title="网络通信有两种体系结构：客户-服务器体系结构、P2P体系结构"></a>网络通信有两种体系结构：客户-服务器体系结构、P2P体系结构</h5><h5 id="无论那种体系结构，网络通信，实际上是进程间的通信，通过计算机网络交换message-报文-而相互通信"><a href="#无论那种体系结构，网络通信，实际上是进程间的通信，通过计算机网络交换message-报文-而相互通信" class="headerlink" title="无论那种体系结构，网络通信，实际上是进程间的通信，通过计算机网络交换message(报文)而相互通信"></a>无论那种体系结构，网络通信，实际上是进程间的通信，通过计算机网络交换message(报文)而相互通信</h5><h5 id="进程通过socket的接口向网络发送message-报文-和从网络中接收message-报文"><a href="#进程通过socket的接口向网络发送message-报文-和从网络中接收message-报文" class="headerlink" title="进程通过socket的接口向网络发送message(报文)和从网络中接收message(报文)"></a>进程通过socket的接口向网络发送message(报文)和从网络中接收message(报文)</h5><ol>
<li>socket是程序进程与传输层之间的接口</li>
<li>开发者可以控制socket在应用端的everything，但是对socket的传输层几乎没有控制权</li>
</ol>
<h5 id="packet会在计算机网络传输的过程中丢失"><a href="#packet会在计算机网络传输的过程中丢失" class="headerlink" title="packet会在计算机网络传输的过程中丢失"></a>packet会在计算机网络传输的过程中丢失</h5><ol>
<li>packet造成路由器中的缓存溢出，或者packet某些比特损坏后会被丢弃，或者底层信道出现了丢包</li>
<li>我们呼唤一种可靠的数据传输(reliable data transfer)协议</li>
<li>我们呼唤在发送时，传输层协议能够加密由发送进程传输的所有数据，在接受主机中，传输层协议将数据解密交付给接收进程</li>
</ol>
<h5 id="传输层协议是在端系统-操作系统-中实现的"><a href="#传输层协议是在端系统-操作系统-中实现的" class="headerlink" title="传输层协议是在端系统(操作系统)中实现的"></a>传输层协议是在端系统(操作系统)中实现的</h5><ol>
<li>在网络模型的协议栈中，传输层位于网络层之上。网络层提供了<em>主机之间</em>的逻辑通信，而传输层为运行在不同主机上的<em>进程之间</em>提供了逻辑通信</li>
</ol>
<h5 id="传输层将从发送进程接受到的message-报文-转换为传输层的segment"><a href="#传输层将从发送进程接受到的message-报文-转换为传输层的segment" class="headerlink" title="传输层将从发送进程接受到的message(报文)转换为传输层的segment"></a>传输层将从发送进程接受到的message(报文)转换为传输层的segment</h5><ol>
<li>实现方法是，将应用层的报文划分为小块，并未每块加上一个传输层首部生成传输层segment，然后在发送端系统中，传输层将这些segment传递给网络层，网络层(即路由器)再将其封装成网络层packet(分组)，即数据报，并向目的地发送。</li>
</ol>
<h5 id="TCP-IP网络-因特网-为提供了两种传输层协议TCP和UDP"><a href="#TCP-IP网络-因特网-为提供了两种传输层协议TCP和UDP" class="headerlink" title="TCP/IP网络(因特网)为提供了两种传输层协议TCP和UDP"></a>TCP/IP网络(因特网)为提供了两种传输层协议TCP和UDP</h5><h5 id="TCP服务模型包括两个部分：面向连接的服务-和-可靠的数据传输服务"><a href="#TCP服务模型包括两个部分：面向连接的服务-和-可靠的数据传输服务" class="headerlink" title="TCP服务模型包括两个部分：面向连接的服务 和 可靠的数据传输服务"></a>TCP服务模型包括两个部分：面向连接的服务 和 可靠的数据传输服务</h5><ol>
<li>UDP是一种不可靠、无连接的服务</li>
</ol>
<h5 id="UDP和TCP最基本的责任是，将两个系统间的IP的交付服务扩展为运行在端系统上的进程之间的服务"><a href="#UDP和TCP最基本的责任是，将两个系统间的IP的交付服务扩展为运行在端系统上的进程之间的服务" class="headerlink" title="UDP和TCP最基本的责任是，将两个系统间的IP的交付服务扩展为运行在端系统上的进程之间的服务"></a>UDP和TCP最基本的责任是，将两个系统间的IP的交付服务扩展为运行在端系统上的进程之间的服务</h5><ol>
<li>进程到进程的数据交付（交付到IP层，也叫网络层）和差错检查是两种最低限度的传输层服务，也是UDP仅有的两个服务</li>
<li>在IP交付服务的实现上，UDP无非就是对网络层协议增加了多路复用和多路分解的功能而已。将传输层segment中的数据交付到对应socket的工作称为多路分解(demultiplex)，在源主机从不同的socket中收集数据块，并为每个数据块装上首部信息，生成segment，然后将segment传递到网络层，这个过程称为多路复用(multiplex)，多路复用和分解的具体实现可以看：<a href="/2023/06/12/network-io-multiplex/" title="图解多路复用">图解多路复用</a></li>
<li>除了UDP提供的两个服务之外，TCP为应用提供了几种附加服务，包括可靠的数据传输、拥堵控制(congestion control)</li>
</ol>
<h5 id="TCP的服务包括两个方面的内容：面向连接的服务-和-可靠的数据传输服务"><a href="#TCP的服务包括两个方面的内容：面向连接的服务-和-可靠的数据传输服务" class="headerlink" title="TCP的服务包括两个方面的内容：面向连接的服务 和 可靠的数据传输服务"></a>TCP的服务包括两个方面的内容：面向连接的服务 和 可靠的数据传输服务</h5><ol>
<li>在message(报文)开始流动之前，TCP让客户端和服务器交换传输层的控制信息，这个被俗称为“握手”过程</li>
<li>握手结束后，一个TCP连接就在两个进程的socket之间建立了</li>
<li>这个连接数全双工的，即连接双方的进程可以在此连接上同时进行message(报文)的收发</li>
<li>发送进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据</li>
<li>接受进程能够依靠TCP接受所有字节，没有字节丢失和冗余</li>
</ol>
<h5 id="用SSL加强后的TCP，不仅能够做传统的TCP所作的一切，而且提供了安全服务，包括加密，数据完整性和端点鉴别"><a href="#用SSL加强后的TCP，不仅能够做传统的TCP所作的一切，而且提供了安全服务，包括加密，数据完整性和端点鉴别" class="headerlink" title="用SSL加强后的TCP，不仅能够做传统的TCP所作的一切，而且提供了安全服务，包括加密，数据完整性和端点鉴别"></a>用SSL加强后的TCP，不仅能够做传统的TCP所作的一切，而且提供了安全服务，包括加密，数据完整性和端点鉴别</h5><ol>
<li>TCP和UDP没有任何加密机制，就是说发送进程传进socket的数据与经网络传送到目的地的进程数据相同</li>
<li>这种强化是在应用层上实现的</li>
</ol>
<h5 id="构造可靠的数据传输-reliable-data-transfer-服务经历了三种模型：rdt1-0-rdt2-0-rdt3-0"><a href="#构造可靠的数据传输-reliable-data-transfer-服务经历了三种模型：rdt1-0-rdt2-0-rdt3-0" class="headerlink" title="构造可靠的数据传输(reliable data transfer)服务经历了三种模型：rdt1.0/rdt2.0/rdt3.0"></a>构造可靠的数据传输(reliable data transfer)服务经历了三种模型：rdt1.0/rdt2.0/rdt3.0</h5><p>我们的假设前提，从理想逐渐到现实。<br>首先，假定底层信道是完全可靠的，比特不会丢失，并且是有序的。那就是rdt1.0，这个模型十分简单，就是发送进程发送数据，接收进程接收数据<br>然后，把底层信道变为比特可能受损的模型。在packet传输的过程中，网络物理部件会出现比特差错，导致某个packet受损，但是按其发送顺序被接收。此时我们要引入差错检查、接收方反馈和重传机制。这对应rdt2.0</p>
<ol>
<li>差错检查，在首部信息中引入检验和的字段。</li>
<li>接受方反馈，“肯定确认packet”ACK和“否定确认packet”NCK</li>
<li>重传，接收方收到有差错的packet，发送NCK，然后发送方重传该packet<br>再者，在rdt2.0的基础上，还有一种情况，那就是ACK和NCK对应的packet受损。直观的办法是，当发送方收到一个“含糊不清（受损）”的NCK或者ACK时，只需要重传即可，也就是增加一个冗余packet，但是困难是，接收方不知道，上次发送的ACK或NCK是否被发送方收到，也就不知道当前的packet是新的还是重传的。解决这个难题的一个简单方法（几乎所有的传输层协议中都采用了这种方法），就是在packet中加入一个序号（sequence number）字段，于是接收方只需要检查序号，就知道发送方是否在重传前一个分组。<br>再者，底层信道出了比特受损意外，还会出现丢包。</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2021/11/02/pattern-chain-of-responsibility/</url>
    <content><![CDATA[<p>这篇博客需和另一篇将Spring AOP的相结合.</p>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>用这样一段OnJava8的原文来描述责任链模式</p>
<blockquote><p>In recursion, one method calls itself over and over until it reaches a termination condition; with <strong>Chain of Responsibility</strong>, a method calls the same base-class method (with a different implementation) which calls another implementation of the base-class method, etc., until it reaches a termination condition.</p>
<footer><strong>Bruce Eckel</strong><cite>OnJava8</cite></footer></blockquote>

<p>从中体会到几点: Java中使用递归调用来执行整个链条, 链条是一个List, 这个List中保存着每个子类重写父类的同一个方法, 但是它们实现逻辑不同. </p>
<p>在Spring AOP中, 对于某个Joinpoint. 要加入一个横切逻辑, 需要定义一个类实现MethodInterceptor, 重写其invoke方法, 在invoke方法体中添加横切逻辑. 其方法体中必须调用<code>invocation.proceed()</code>方法, 不然会造成”短路”. </p>
<p>有多个MethodInterceptor实现的时候, 要按照逐个执行它们的invoke方法(横切逻辑), 这些匹配到的interceptor, 最终集中到了<code>ReflectiveMethodInvocation.interceptorsAndDynamicMethodMatchers</code>这个List中, 将在<code>proceed()</code>方法中执行. 这里用到了递归, 整体是”责任链模式”</p>
<p>附上ReflectiveMethodInvocation源码来解释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring&#x27;s implementation of the AOP Alliance</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.aopalliance.intercept.MethodInvocation&#125; interface,</span></span><br><span class="line"><span class="comment"> * implementing the extended</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.aop.ProxyMethodInvocation&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Invokes the target object using reflection. Subclasses can override the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #invokeJoinpoint()&#125; method to change this behavior, so this is also</span></span><br><span class="line"><span class="comment"> * a useful base class for more specialized MethodInvocation implementations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is possible to clone an invocation, to invoke &#123;<span class="doctag">@link</span> #proceed()&#125;</span></span><br><span class="line"><span class="comment"> * repeatedly (once per clone), using the &#123;<span class="doctag">@link</span> #invocableClone()&#125; method.</span></span><br><span class="line"><span class="comment"> * It is also possible to attach custom attributes to the invocation,</span></span><br><span class="line"><span class="comment"> * using the &#123;<span class="doctag">@link</span> #setUserAttribute&#125; / &#123;<span class="doctag">@link</span> #getUserAttribute&#125; methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; This class is considered internal and should not be</span></span><br><span class="line"><span class="comment"> * directly accessed. The sole reason for it being public is compatibility</span></span><br><span class="line"><span class="comment"> * with existing framework integrations (e.g. Pitchfork). For any other</span></span><br><span class="line"><span class="comment"> * purposes, use the &#123;<span class="doctag">@link</span> ProxyMethodInvocation&#125; interface instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Adrian Colyer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #invokeJoinpoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #proceed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #invocableClone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setUserAttribute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getUserAttribute</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title">ProxyMethodInvocation</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Object proxy;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> Object[] arguments = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetClass;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Lazily initialized map of user-specific attributes for this invocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; userAttributes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * List of MethodInterceptor and InterceptorAndDynamicMethodMatcher</span></span><br><span class="line"><span class="comment">	 * that need dynamic checks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> List&lt;?&gt; interceptorsAndDynamicMethodMatchers;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Index from 0 of the current interceptor we&#x27;re invoking.</span></span><br><span class="line"><span class="comment">	 * -1 until we invoke: then the current interceptor.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> currentInterceptorIndex = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Construct a new ReflectiveMethodInvocation with the given arguments.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> proxy the proxy object that the invocation was made on</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> target the target object to invoke</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method the method to invoke</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arguments the arguments to invoke the method with</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetClass the target class, for MethodMatcher invocations</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> interceptorsAndDynamicMethodMatchers interceptors that should be applied,</span></span><br><span class="line"><span class="comment">	 * along with any InterceptorAndDynamicMethodMatchers that need evaluation at runtime.</span></span><br><span class="line"><span class="comment">	 * MethodMatchers included in this struct must already have been found to have matched</span></span><br><span class="line"><span class="comment">	 * as far as was possibly statically. Passing an array might be about 10% faster,</span></span><br><span class="line"><span class="comment">	 * but would complicate the code. And it would work only for static pointcuts.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">ReflectiveMethodInvocation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">protected</span> ReflectiveMethodInvocation(</span></span></span><br><span class="line"><span class="params"><span class="function">			Object proxy, <span class="meta">@Nullable</span> Object target, Method method, <span class="meta">@Nullable</span> Object[] arguments,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="meta">@Nullable</span> Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">		<span class="keyword">this</span>.targetClass = targetClass;</span><br><span class="line">		<span class="comment">// 找到桥接方法，作为最后执行的方法。至于什么是桥接方法，自行百度关键字：bridge method</span></span><br><span class="line">		<span class="comment">// 桥接方法是 JDK 1.5 引入泛型后，为了使Java的泛型方法生成的字节码和 1.5 版本前的字节码相兼容，由编译器自动生成的方法（子类实现父类的泛型方法时会生成桥接方法）</span></span><br><span class="line">		<span class="keyword">this</span>.method = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">		<span class="comment">// 对参数进行适配</span></span><br><span class="line">		<span class="keyword">this</span>.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments);</span><br><span class="line">		<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.target;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 此处：getStaticPart返回的就是当前得method</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AccessibleObject <span class="title">getStaticPart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意：这里返回的可能是桥接方法哦</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object[] getArguments() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.arguments;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArguments</span><span class="params">(Object... arguments)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arguments = arguments;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心在这里</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">//	We start with an index of -1 and increment early.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个方法相当于调用了目标方法</span></span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取集合中的 MethodInterceptor（并且currentInterceptorIndex + 1）</span></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">			<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">                <span class="comment">// 执行封装了横切逻辑的invoke方法</span></span><br><span class="line">                <span class="comment">// 所以在interceptor.invoke方法内部, 必须调用invocation.proceed(), 才能再次恢复递归; 否则, 会发生&quot;短路&quot;. 就无法执行上面的invokeJoinpoint();</span></span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoke the joinpoint using reflection.</span></span><br><span class="line"><span class="comment">	 * Subclasses can override this to use custom invocation.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the return value of the joinpoint</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Throwable if invoking the joinpoint resulted in an exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// this.target指的就是被代理的目标对象</span></span><br><span class="line">        <span class="comment">// 最终invokeJoinpointUsingReflection内部执行的就是method.invoke(arguments);也就是说执行了目标对象的Joinpoint</span></span><br><span class="line">		<span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的解释信息都在代码的注释中, 这里理清楚它们继承的关系, 可以看出它们是AOP Joinpoint概念实现</p>
<img  src=http://www.plantuml.com/plantuml/svg/yyhFp2i0uX85cnfTNGNFlBByvCIIpFmyBg1OQb5QOdAgWXTSJNKjaZ12BKYS2uaBDietjIGZFmMhWUXIOFqOWc1J0ehoAohn68LL7cmUTXcR6ZqzXQ3Kj9pKv9BCibHqUG00>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.intercept;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.AccessibleObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This interface represents a generic runtime joinpoint (in the AOP</span></span><br><span class="line"><span class="comment"> * terminology).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A runtime joinpoint is an &lt;i&gt;event&lt;/i&gt; that occurs on a static</span></span><br><span class="line"><span class="comment"> * joinpoint (i.e. a location in a the program). For instance, an</span></span><br><span class="line"><span class="comment"> * invocation is the runtime joinpoint on a method (static joinpoint).</span></span><br><span class="line"><span class="comment"> * The static part of a given joinpoint can be generically retrieved</span></span><br><span class="line"><span class="comment"> * using the &#123;<span class="doctag">@link</span> #getStaticPart()&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In the context of an interception framework, a runtime joinpoint</span></span><br><span class="line"><span class="comment"> * is then the reification of an access to an accessible object (a</span></span><br><span class="line"><span class="comment"> * method, a constructor, a field), i.e. the static part of the</span></span><br><span class="line"><span class="comment"> * joinpoint. It is passed to the interceptors that are installed on</span></span><br><span class="line"><span class="comment"> * the static joinpoint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Interceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Joinpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Proceed to the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The implementation and the semantics of this method depends</span></span><br><span class="line"><span class="comment">	 * on the actual joinpoint type (see the children interfaces).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> see the children interfaces&#x27; proceed definition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Throwable if the joinpoint throws an exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the object that holds the current joinpoint&#x27;s static part.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;For instance, the target object for an invocation.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the object (can be null if the accessible object is static)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getThis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the static part of this joinpoint.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The static part is an accessible object on which a chain of</span></span><br><span class="line"><span class="comment">	 * interceptors are installed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AccessibleObject <span class="title">getStaticPart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
  </entry>
  <entry>
    <title>抽象工厂</title>
    <url>/2021/07/03/pattern-factory/</url>
    <content><![CDATA[<h1 id="动态工厂"><a href="#动态工厂" class="headerlink" title="动态工厂"></a>动态工厂</h1><blockquote><p>Factories: Encapsulating Object Creation</p>
<p>A Factory forces object creation to occur through a common point, preventing creational code from appearing throught your system.</p>
<footer><strong>Bruce Eckel</strong><cite>On Java 8</cite></footer></blockquote>
<p><strong>工厂模式其实是封装对象的创建过程. 强制将让对象的创建发生在一个统一的地方, 阻止代码散落在系统中.</strong></p>
<p>静态工厂简单, 就是通过传入对象的标识, 在创建方法内部判断条件new出目标对象.<br>那么动态工厂, 就更加解耦, 通过传入的标识, 反射得到类, 然后<code>xxx.getNewInstance()</code>, 例子如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getSimpleName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">Shape <span class="title">create</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicFactory</span> <span class="keyword">implements</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shape <span class="title">create</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Shape)</span><br><span class="line">          Class.forName(<span class="string">&quot;package.name.&quot;</span> + type).getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(e.getLocalizedMessage());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shape s = <span class="keyword">new</span> DynamicFactory().create(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">    System.out.println(s.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>抽象工厂是在工厂的基础上又封装了一层, 即将”工厂”对象作为参数传入，然后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  Supplier&lt;Player&gt; player;</span><br><span class="line">  Supplier&lt;Obstacle&gt; obstacle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">  ConcreteFactory() &#123;</span><br><span class="line">    player = Player1::<span class="keyword">new</span>;</span><br><span class="line">    obstacle = Obstacle1::<span class="keyword">new</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Player p;</span><br><span class="line">  <span class="keyword">private</span> Obstacle ob;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">getInstance</span><span class="params">(AbstractFactory factory)</span> </span>&#123;</span><br><span class="line">    p = factory.player.get();</span><br><span class="line">    ob = factory.obstacle.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Factory Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次Nginx的严重错误</title>
    <url>/2022/12/24/ngnix/</url>
    <content><![CDATA[<p>nginx监听80端口代理网关应用，对应的nginx配置conf.d/gateway.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">192.168.56.10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host $host;  <span class="comment">#[1]</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://192.168.100.2:88;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring-cloud-gateway应用的配置如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">foomall-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">foomall_host_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://foomall-product</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Host=192.168.56.10</span></span><br></pre></td></tr></table></figure>
<p>此时，在地址栏输入<code>http://192.168.56.10</code>后显示404，从配置得知gateway通过Host参数来进行路由，也就是HTTP Header中的Host参数，说明其未生效。<br>原因就是Nginx在代理<code>http://192.168.56.10</code>请求时，将Host参数弄丢了，所以在<code>[1]</code>的位置加上<code>proxy_set_header Host $host;</code>，除了这个参数，Nginx在代理的过程中会丢失很多参数</p>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小技巧</title>
    <url>/2022/01/29/programing-skills/</url>
    <content><![CDATA[<h3 id="双向遍历"><a href="#双向遍历" class="headerlink" title="双向遍历"></a>双向遍历</h3><ol>
<li>单指针<br>回文字符串验证<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length/<span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] != array[array.length-<span class="number">1</span>-i]) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>双指针<br>回文字符串验证<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = array.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] != array[j]) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="判断是否是字母或者数字字符"><a href="#判断是否是字母或者数字字符" class="headerlink" title="判断是否是字母或者数字字符"></a>判断是否是字母或者数字字符</h3><p>ASCII码中简记如下：<br>A-Z 是 65-90<br>a-z 是 97-122</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大写转小写"><a href="#大写转小写" class="headerlink" title="大写转小写"></a>大写转小写</h3><p>在ASCII中大写字母A与小写字母a相差了32</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">toLowerCase</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(c + <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数字字符转为数字"><a href="#数字字符转为数字" class="headerlink" title="数字字符转为数字"></a>数字字符转为数字</h3><p>ASCII码中数字字符减去字符0可以得到十进制真是的数字，每个数字的大小都是与0之间的距离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(<span class="keyword">char</span>[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; c.length) &#123;</span><br><span class="line">        digit = digit*<span class="number">10</span> + (c[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分离整数为数组"><a href="#分离整数为数组" class="headerlink" title="分离整数为数组"></a>分离整数为数组</h3><p>将一个int类型的整数分离为int数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intToArray(<span class="keyword">int</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] digits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// int类型十进制的数值最大十位</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> digit = s % <span class="number">10</span>;</span><br><span class="line">        s = s / <span class="number">10</span>;</span><br><span class="line">        digits[i] = digit;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="continue与while"><a href="#continue与while" class="headerlink" title="continue与while"></a>continue与while</h3><p>continue逻辑判断和与while可以转化，比如，对一串字母、标点和空格组成的字符串，验证其是否是回文字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int i = <span class="number">0</span>;</span><br><span class="line">int j = array.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlpha(array[i])) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isAlpha(array[j])) &#123;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (array[i] != array[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 continue 可以用while来代替，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; !isAlpha(array[i])) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>第一段代码中，相当于continue将<code>i&lt;j</code>的情况抽出来了，走最外层的while，接着走if，然后continue。与第二段代码中的，内层的while一直循环将i执行加加，到字母字符的位置，是一个效果。<br>但是加上continue之后，代码的抽象层次更高了。</p>
]]></content>
  </entry>
  <entry>
    <title>项目中遇到的问题</title>
    <url>/2023/05/16/problems-in-project/</url>
    <content><![CDATA[<p>问题1：交易记录的表，交易id，日期，金额，买卖方向，债券代码，债券类型。但是某个债券可能会从属于多个债券类型。这时，如何进行分组统计每种债券类型的交易量？比如，我要查询2023-02-23日期，PFB、CGB和RVB对应的交易量分别是多少，由于债券类型之间有交集，所以我们不能简单的<code>select sum(qty) from table1 where biz_date = &#39;2023-02-03&#39; group by bond_type</code>。那么我在设计表的时候就要注意了，多个债券类型如何存储，使用多个字段还是，用MySQL的json还是别的？<br>首先，我们存储的时候，债券类型字段，采用逗号分隔即可，比如：”PFB,CGB,RVB”<br>|order_id|biz_date  |bond_code|qty |bond_type|<br>|1       |2023-02-23|2012.IB  |100 |PFB,CGB,RVB|<br>|2       |2023-02-23|2013.IB  |103 |GB,CGB|<br>|3       |2023-02-23|2023.IB  |190 |LGB,CGB|<br>|4       |2023-02-23|2079.IB  |212 |PFB,RVB|<br>使用sql查询时，查询多个债券类型时，无法使用<code>bond_type in (&#39;PFB&#39;, &#39;RVB&#39;)</code>可以使用MySQL中的<code>find_is_set</code>函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> (find_in_set(<span class="string">&#x27;PFB&#x27;</span>, bond_type) <span class="keyword">or</span> find_in_set(<span class="string">&#x27;RVB&#x27;</span>, bond_type))</span><br></pre></td></tr></table></figure>
<p>接下来我们需要借助代码，在程序里，将多个债券类型的同一个订单计算多次，准确地计算出每种类型的交易金额</p>
<p>问题2：文本框模糊检索，输入名称的同时，给出提示，比如输入当前的债券发行人，比如输入“银行”，会检索出“上海银行”，“工商银行股份有限公司”等，不能检索出“银河车行”。<br>MySQL中对应的表字段建立全文索引，MySQL5.7支持中文的全文索引，使用全文索引的语法进行查询 <code>MATCH(issuer_name) AGAINST( &#39;银行&#39; IN BOOLEAN MODE)</code></p>
<p>问题3：MySQL的一个表有20个字段，上百万的数据，存储的是交易数据，包括：交易id，日期，金额，买卖方向，债券代码，债券类型，剩余期限。如何在几百毫秒内，计算出最近15天，各种债券类型，各种剩余期限的净成交序列。</p>
<ol>
<li>按照某种类型拆分表</li>
<li>使用MySQL分区表</li>
<li>使用覆盖索引，将所需要查询的字段都罗列出来，一起建立索引，查询时只能包含覆盖索引中的字段，这样索引中的值就可以满足查询要求，不用根据主键回表</li>
</ol>
<p>问题4：40万条数据，进行for循环，耗时10ms以内，如果在里边加上<code>LocalDate.format(DateTimeFormatter.ISO_DATE)</code>，为什么耗时飙升到了2000ms？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 耗时2000+ms</span></span><br><span class="line"><span class="keyword">for</span> (Object obj: objList) &#123;</span><br><span class="line">	LocalDate now = LocalDate.now()</span><br><span class="line">	now.format(DateTimeFormatter.ISO_DATE)</span><br><span class="line">	<span class="comment">// nothing ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要使用<code>LocalDate.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</code>就大幅提高了效率，结果就成了100+ms</p>
<p>问题5：<code>@KafkaLinstner</code>监听并消费消息，经过计算发送websocket消息到客户端页面。后端有两个实例，同一个账户两个浏览器登录，为什么两个客户端收到的消息不一致？</p>
<ol>
<li>接受到新的消息，经过一些列逻辑判断（是否是新订单，是否旧的订单新发生了变化），将变化更新到Redis集群中，并发送通知。</li>
<li>发送通知时，会遍历当前服务器的所有的session发送通知，并不是广播</li>
<li>两台服务器都收到了kafka消息，但是必然有先后顺序，就会导致先收到消息的一台服务器，进行了Redis集群中订单的update，第二台服务器收到消息后查询Redis发现订单无变化，那么第二台服务器就不会对当前服务器上的建立websocket连接的用户发送通知，然而第一台服务器上的用户却收到了变化，所以两个客户端上显示数据不一致<br>解决方案是：同时使用本地缓存来存储订单信息，同时也在Redis中存储订单信息，如果服务器重启，在重启过程中，读取Redis并更新本地缓存。<br>技术点：</li>
</ol>
<ul>
<li>对每台服务器配置不同的消费者组ID</li>
<li>服务器启动过程中，运行更新本地缓存的代码</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Java动态代理</title>
    <url>/2021/08/01/pattern-proxy-and-dynamic/</url>
    <content><![CDATA[<h1 id="Static-Proxy"><a href="#Static-Proxy" class="headerlink" title="Static Proxy"></a>Static Proxy</h1><p>一个代理机制，可以看作是对调用目标的一个包装，这样我们对目标代码的调用不是<strong>直接</strong>发生的，而是通过代理完成。<strong>通过代理可以让调用者与实现者之间解耦。</strong></p>
<p>在代理模式中, 通常有这几种抽象概念：</p>
<ul>
<li>ISubject 该接口是对被访问资源的抽象</li>
<li>SubjectImpl 被访问资源的具体实现</li>
<li>SubjectProxy 被访问资源的代理实现</li>
<li>Client 访问者<br>SubjectImpl不会出现在SubjectProxy类中，取而代之的是ISubject被注入到SubjectProxy中，作为一个“桥梁”，就满足了调用者和实现者的解耦</li>
</ul>
<blockquote>
<p>没有代理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ISubject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        String url = ...;</span><br><span class="line">        subject.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>增加了代理之后</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    ISubject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISubject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubjectProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(String url)</span></span>&#123;</span><br><span class="line">        <span class="comment">// add pre-process logic if neccessary</span></span><br><span class="line">        String res = subject.request(url);</span><br><span class="line">        <span class="comment">// add post process logic if neccessary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Proxy:&quot;</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String url = ...;</span><br><span class="line">        <span class="comment">// 不直接使用SubjectImpl去调用，而是通过proxy去调用</span></span><br><span class="line">        ISubject proxy = SubjectProxy.getProxy();</span><br><span class="line">        proxy.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过SubjectProxy的作用不仅仅是请求的转发, 而是可以对请求添加更多的访问控制. 如注释中的, pre-process和post-process. 在请求转发给Subject之前或之后都可以根据情况插入其他处理逻辑. 这一点就和Python中的装饰器模式一样了.</p>
<h1 id="Dynamic-Proxy"><a href="#Dynamic-Proxy" class="headerlink" title="Dynamic Proxy"></a>Dynamic Proxy</h1><p>如果接口和方法很多，那么我们要手写很多（静态）代理类，通过观察研究这些代理类，我们抽象出一个<strong>高阶代理类</strong>，这个类要有这样几种行为：</p>
<ul>
<li>public static Class<?> **getProxyClass**(ClassLoader loader, Class<?>… interfaces)</li>
<li>public static Object <strong>newProxyInstance</strong>(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</li>
<li>public static InvocationHandler <strong>getInvocationHandler</strong>(Object proxy)<br>而动态代理的巧妙之处在于，可以在程序的运行期间，动态的生成不同的代理类且加载这个代理类再实例化，来完成相同的工作。<br>所以, 有了动态代理, 为指定接口在系统运行期间生成代理对象. 在执行代码的过程中，动态生成了代理类 Class 的字节码byte[]，然后通过defineClass0 加载到JVM中，简要代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance</span><br><span class="line">    ProxyClassFactory.apply</span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>动态代理机制的实现，需要Proxy类和InvocationHandler接口. Proxy类是Java提供的，如果要利用动态代理处理业务，我们要做的就是写一个类实现InvocationHandler，比如，使用动态代理实现一个”request服务时间控制”功能:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCtrlInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RequestCtrlInvocationHandler.class);</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestCtrlInvocationHandler</span><span class="params">(Objec target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Objec <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName.equal(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">            TimeOfDay startTime = <span class="keyword">new</span> TiemOfDay(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            TimeOfDay endTime = <span class="keyword">new</span> TiemOfDay(<span class="number">5</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">            TiemOfDay currentTime = <span class="keyword">new</span> TimeDay();</span><br><span class="line">            <span class="keyword">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Service is not available now.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ISubject subject = (ISubject)Proxy.newProxyInstance(ISubject.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;ISubject.class&#125;, <span class="keyword">new</span> RequestCtrlInvocationHandler(<span class="keyword">new</span> ISubjectImpl()));</span><br><span class="line">        <span class="comment">// 这里不增加doSomething方法了, 简单演示一下调用</span></span><br><span class="line">        String url = ...;</span><br><span class="line">        subject.request(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在运行期间, JVM会为我们创建class字节码, 翻译过来大概如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">ISubject</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        handler.invoke(<span class="keyword">this</span>, ISubject.class.getMethod(<span class="string">&quot;request&quot;</span>, String.class), <span class="keyword">new</span> Object[]&#123;url&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的动态代理实现方式有两种：JDK原生实现和Cglib开源实现。日常业务能够使用jdk动态代理编码的场景非常少。Spring在5.X之前默认的动态代理实现一直是JDK动态代理。但是从5.X开始，Spring就开始默认使用Cglib来作为动态代理实现。并且SpringBoot从2.X开始也转向了Cglib动态代理实现。我们可以在源码中找到对应的线索，SpringAOP的顶级接口<code>org.springframework.aop.framework.AopProxy</code>，这个接口只有两个实现类</p>
<ul>
<li>CglibAopProxy</li>
<li>JdkDynamicAopProxy</li>
</ul>
<h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><ol>
<li>为什么要用 InvocationHandler？因为sun.misc.ProxyGenerator 在生成 Proxy 字节码 byte[]时，自然希望具体的方法实现是一个模式化的code，这样才方便自动生成代码。所以<strong>将差异化的逻辑转移到了InvocationHandler中</strong>。</li>
<li>为什么JDK动态代理只支持Interface的代理？如果只有SubjectImpl没有ISubject的话，就失去了代理模式的意义，不能通过ISubject将SubjectProxy和SubjectImpl解耦。</li>
</ol>
<h1 id="JDK动态代理分析"><a href="#JDK动态代理分析" class="headerlink" title="JDK动态代理分析"></a>JDK动态代理分析</h1><p>有必要动态代理的源码扒出来加固上边的分析过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** parameter types of a proxy class constructor */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler.class &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * a cache of proxy classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">     * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment">     * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BiFunction</span>&lt;<span class="title">ClassLoader</span>, <span class="title">Class</span>&lt;?&gt;[], <span class="title">Class</span>&lt;?&gt;&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">            String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中这个newProxyInstance方法要注重说一下，大概分为四步：</p>
</blockquote>
<ul>
<li>第一步，先进行权限检测<code>checkProxyAccess</code>，主要是借助于<code>System.getSecurityManager().checkxxxPermission(...)</code>，其中权限主要涉及：文件，socket等</li>
<li>第二步，生产代理对象, <code>getProxyClass0(loader, intfs)</code>根据传入<code>newProxyInstance(...)</code>的参数得到一个代理对象，其中传入的参数有三个, 根据前两个参数到proxyClassCache中查找是否有缓存，如果没有，根据<code>ProxyClassFactory</code>生产出一个代理对象，<code>ProxyClassFactory</code>是一个静态内部类, 其中代理对象的生成过程，主要涉及<code>apply(..)</code>中的<code>ProxyGenerator.generateProxyClass(proxyName...)</code>行(以下附上了<code>ProxyGenerator</code>的部分源码)，当我打开<code>generateProxyClass</code>方法的源码才恍然大悟，<code>generateClassFile()</code>在内存中生成一个class类(文件一般不保存, 类名一般叫做<code>$Proxy0</code>)，来定义代理类.<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 生成一个简单的代理对象, 一般不需要进行.class的保存, 所以这里的`saveGeneratedFiles`为false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第三步，根据第二步生成的代理类，调用<code>cl.getConstructor(&#123; InvocationHandler.class &#125;)</code>, 相当于调用了代理类的构造方法, 在通过构造器调用<code>cons.newInstance(new RequestCtrlInvocationHandler(new ISubjectImpl()))</code>，最终强制转换ISubject对象。</li>
<li>第四步，当代理对象调用<code>ISubject</code>的<code>request</code>时，首先进入<code>RequestCtrlInvocationHandler</code>的invoke方法，在该方法的最后，通过method.invoke(…)来真正调用<code>ISubjectImpl.request</code></li>
</ul>
<h1 id="Cglib动态代理分析"><a href="#Cglib动态代理分析" class="headerlink" title="Cglib动态代理分析"></a>Cglib动态代理分析</h1><p>JDK动态代理必须让SubjectImpl实现某个接口，也就是基于接口代理（interface-based proxies），有局限性。</p>
<blockquote>
<p>注：CGLIB(Code Generation Library)是一个开源项目！是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。<br>CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</p>
</blockquote>
<p>如果可以生成一个子类继承SubjectImpl，子类重写父类的方法，将子类注入代理类中，通过子类调用父类的方法来实现代理，这就是Cglib动态代理（subclass-based proxies）。<br>使用SpringBoot时，如果Subject实现了某个接口就会使用JDK动态代理，如果实现任何接口就会使用CGLIB动态代理。我们可以在启动类上<code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>进行全局配置。<br>Spring框架中的Cglib动态代理，源码在org.springframework.cglib.proxy包下，也有对应的Proxy类和InvocationHandler接口。<br>这里我们只需要Subject类，代理它的request方法，在运行期间生成的代理类也就是子类，部分反编译的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>$$<span class="title">EnhancerBySpringCGLIB</span>$$5889<span class="title">ab8</span> <span class="keyword">extends</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">SpringProxy</span>, <span class="title">Advised</span>, <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line">  <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$request$<span class="number">0</span>$Method;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$request$<span class="number">0</span>$Proxy;</span><br><span class="line">  <span class="comment">// ... code ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK229() &#123;</span><br><span class="line">    CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">    Class var0 = Class.forName(<span class="string">&quot;com.xxx.xxx.Subject$$EnhancerBySpringCGLIB$$5889ab8&quot;</span>);</span><br><span class="line">    Class var1;</span><br><span class="line">    Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;equals&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="string">&quot;hashCode&quot;</span>, <span class="string">&quot;()I&quot;</span>, <span class="string">&quot;clone&quot;</span>, <span class="string">&quot;()Ljava/lang/Object;&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>)).getDeclaredMethods());</span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line">    CGLIB$request$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;request&quot;</span>, <span class="string">&quot;()V&quot;</span>&#125;, (var1 = Class.forName(<span class="string">&quot;com.ficc.numtalk.scheduled.Subject&quot;</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">    CGLIB$request$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">&quot;()V&quot;</span>, <span class="string">&quot;request&quot;</span>, <span class="string">&quot;CGLIB$request$0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">      <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        var10000.intercept(<span class="keyword">this</span>, CGLIB$request$<span class="number">0</span>$Method, CGLIB$emptyArgs, CGLIB$request$<span class="number">0</span>$Proxy);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.request();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error | RuntimeException var1) &#123;</span><br><span class="line">      <span class="keyword">throw</span> var1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Interpreter</title>
    <url>/2022/01/16/python-interpreter/</url>
    <content><![CDATA[<p>为什么Python不需要编译就能执行，是因为跳过了编译过程，这种说法是不对的。<br>因为任何高级语言都需要编译成低级的机器语言才能执行，python的做法不是整个编译，按照行编译并解释执行，所以它是动态语言。</p>
<h1 id="Python-Interpreter"><a href="#Python-Interpreter" class="headerlink" title="Python Interpreter"></a>Python Interpreter</h1><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p>
<h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p>当我们从Python官方网站下载并安装好Python后，我们就直接获得了一个官方版本的解释器：<strong>CPython, 这个解释器是用C语言开发的，所以叫CPython</strong>。在命令行下运行python就是启动CPython解释器。<br>CPython是使用最广的Python解释器。教程的所有代码也都在CPython下执行。</p>
<h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>IPython是基于CPython之上的一个交互式解释器，也就是说，IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了IE。<br>CPython用<code>&gt;&gt;&gt;</code>作为提示符，而IPython用In [序号]:作为提示符。</p>
<h3 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h3><p>PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。<br>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些是不同的，这就导致相同的Python代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到PyPy下执行，就需要了解PyPy和CPython的不同点。</p>
<h3 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h3><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h3 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h3><p>IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Interpreter</tag>
        <tag>CPython</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2021/08/22/serialization-deserialization/</url>
    <content><![CDATA[<p>序列化： 将数据结构或对象转换成二进制串的过程<br>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程</p>
<h1 id="Java-Serialization"><a href="#Java-Serialization" class="headerlink" title="Java Serialization"></a>Java Serialization</h1><p>Serialization is the conversion of the state of an object into a byte stream; deserialization does the opposite.<br>Stated differently, serialization is the conversion of <strong>a Java object into a static stream (sequence) of bytes</strong> which can then be saved to a database or transferred over a network.</p>
<p>if further, reference:<br><a href="https://snyk.io/blog/serialization-and-deserialization-in-java/">https://snyk.io/blog/serialization-and-deserialization-in-java/</a></p>
]]></content>
      <tags>
        <tag>Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>实时交易数据</title>
    <url>/2023/02/21/realtime-dealing/</url>
    <content><![CDATA[<p>最近遇到一个查看实时交易数据的问题。数据来自于上游的Kafka，然后在服务端经过些许处理，发送到WebSocket，前端页面实时刷新，这就是整个链路。<br>Kafka像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> KafkaDealConsumer &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@KafkaLintener(topic = &quot;$&#123;topic&#125;&quot;, containerFactory = &quot;kafkaListenerFactory&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDealMessage</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line">		String source = record.value();</span><br><span class="line">		doSendDealMessage(source);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSendDealMessage</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">		String message;</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="comment">// handle the record ...</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		dealWsServer.sendInfoToAll(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DealWsServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object lockObj = <span class="keyword">new</span> Object();</span><br><span class="line">	ConcurrentHashMap&lt;String, DealWsServer&gt; webSocketSet = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(WebSocketServer wsServer, String message)</span> </span>&#123;</span><br><span class="line">		wsServer.seesion.getBasicRemote().sendText(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@OnOpen</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(<span class="meta">@PathParam(value = &quot;sessionId&quot;)</span> String sessoinId, Session session)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sessionId = sessionId;</span><br><span class="line">		<span class="keyword">this</span>.session = session;</span><br><span class="line">		webSocketSet.put(seesionId, <span class="keyword">this</span>);</span><br><span class="line">		DealWsServer.onlineCount.getAndIncrement();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@OnMessage</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String requestMessage)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// some codes ...</span></span><br><span class="line">		<span class="comment">// 这里判断是否是初次建立连接，或者发送的是心跳</span></span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">		<span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">			init();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果是前端发送过来的参数信息，那么后端进行查询并返回结果</span></span><br><span class="line">		<span class="keyword">synchronized</span> (lockObj) &#123;</span><br><span class="line">			RequestDto request = JSONObject.parseObject(requestMessage);</span><br><span class="line">			String message;</span><br><span class="line">			<span class="comment">// 处理request并生成message;</span></span><br><span class="line">			sendMessage(<span class="keyword">this</span>, message);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@OnClose</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		webSocketSet.remove(sessionId);</span><br><span class="line">		DealWsServer.onlineCount.getAndDecrement();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@OnError</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session sesson, Throwable error)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfoToAll</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历每一个session</span></span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, DealWsServer&gt; entry : webSocketSet.entrySet()) &#123;</span><br><span class="line">			DealWsServer dealWsServer = entry.getValue();</span><br><span class="line">			<span class="keyword">synchronized</span> (dealWsServer.lockObj) &#123;</span><br><span class="line">				sendMessage(wsServer, message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
  </entry>
  <entry>
    <title>reset-centos</title>
    <url>/2023/09/06/reset-centos/</url>
    <content><![CDATA[<p>将Windows重装为centos/7</p>
<h5 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h5><ol>
<li>现在镜像<a href="https://mirrors.aliyun.com/centos-vault/centos/7.8.2003/isos/x86_64/">https://mirrors.aliyun.com/centos-vault/centos/7.8.2003/isos/x86_64/</a></li>
<li>直接下载.iso就行</li>
<li>下载U盘启动盘制作工具：UltraISO，一路选择试用</li>
<li>运行 UltraISO，选择试用，选择主界面菜单栏里的[文件] → [打开]，选择你刚下载好的 CentOS 7 镜像</li>
<li>选择菜单栏里的 [启动] → [写入硬盘映像]</li>
<li>此时如果出现：“设备忙，关闭正在运行的应用程序”等字样时，是因为U盘没有被完全格式化</li>
<li>那么，管理员运行Windows Terminal或者cmd，然后<code>diskpart</code>，然后<code>list disk</code>，然后<code>select disk 1</code>，然后<code>clean</code>，这就将U盘格式化成功了</li>
<li>然后重复4和5步骤，就可以写入成功了</li>
</ol>
<h5 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h5><ol>
<li>F12进入BIOS系统，我的电脑一般不自动识别U盘，需要启动一轮硬件检查，然后检查过程中可以直接中断，然后再次重启，F12后就会发现我的U盘(Sumsang字样)</li>
<li>选择U盘启动，选择<code>Test this mode &amp; Install CentOS 7</code></li>
<li>此时，出现了<code>Warning: /dev/root does not existed</code>，是因为找不到U盘挂载的位置，需要额外配置</li>
<li>在当前最下边命令行输入：<code>dracut:/# ls /dev</code>，查询所有文件夹。此时，如果只有一个硬盘挂载的情况下，默认U盘挂载的位置是<code>sdb4</code>，如果多个硬盘的电脑，就要借助搜索引擎了</li>
<li>然后<code>dracut:/# reboot</code>，出现选择<code>Test this mode &amp; Install CentOS 7</code>的页面</li>
<li>键盘输入<code>e</code>，进入编辑，将<code>vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\* rd.live.check quiet</code>改为<code>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sd4 quiet</code>，然后按键F10保存，继续安装</li>
<li>成功！</li>
</ol>
<h5 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h5><ol>
<li>默认的CentOS是网络服务不启动的，我们要配置其开机启动，插上网线</li>
<li>查看网卡信息<code>ip addr</code>，看看哪个网卡没有配置，一般是第二个<code>p8p1</code></li>
<li>然后<code>cd /etc/sysconfig/network-scripts/ifcfg-p8p1</code>，将<code>ONBOOT=no</code>改为<code>ONBOOT=yes</code></li>
<li>重启服务<code>systemctl restart network</code></li>
<li>然后<code>ping www.baidu.com</code>如果不行，就重启一下电脑</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>源码学习</title>
    <url>/2023/02/05/sourcecode-learning/</url>
    <content><![CDATA[<h3 id="词汇学习"><a href="#词汇学习" class="headerlink" title="词汇学习"></a>词汇学习</h3><p>DefaultListableBeanFactory 可枚举的BeanFactory<br>ConfigurableListableBeanFactory 可配置的BeanFactory<br>refresh() 刷新BeanFactory<br>hasBeanFactory()<br>customizeBeanFactory()<br>obtainFreshBeanFactory() 获得新鲜的BeanFactory<br>GenericBeanDefinition 普通BeanDefinition<br>getBean()<br>doGetBean()<br>allowCircularReferences 允许循环依赖</p>
]]></content>
  </entry>
  <entry>
    <title>Spring AntPathMatcher</title>
    <url>/2023/02/11/spring-ant-path-matcher/</url>
    <content><![CDATA[<h3 id="Ant-sytle"><a href="#Ant-sytle" class="headerlink" title="Ant-sytle"></a>Ant-sytle</h3><p>实例化<code>PathMatchingResourcePatternResolver</code>是SpringIOC容器在启动过程中的一个小步骤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line">	<span class="comment">// some code ...</span></span><br><span class="line">	<span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>AntPathMatcher</code>是借用了一些Apcache Ant中的代码，称为Ant风格路径匹配策略，首先列举常用的例子：</p>
<p>The mapping matches URLs using the following rules:<br>
<ul>
<li>{@code ?} matches one character</li>
<li>{@code *} matches zero or more characters</li>
<li>{@code **} matches zero or more <em>directories</em> in a path</li>
<li>{@code {spring:[a-z]+}} matches the regexp {@code [a-z]+} as a path variable named "spring"</li>
</ul>

<p>注：最后一条，就知道为什么<code>@PathVariable</code>可以将花括号中的值赋给一个变量了</p>
<p><em>Table Example Ant-Style Path Patterns</em><br>| Path                  |    Description |<br>| <code>/api/*.x</code>            |    匹配所有在app路径下的.x文件 |<br>| <code>/api/p?ttern</code>        |    匹配/app/pattern 和 /app/pXttern 但是不包括/app/pttern |<br>| <code>/**/example</code>         |    匹配/app/example/app/foo/example, 和 /example |<br>| <code>/api/**/dir/file.</code>   |    匹配/app/dir/file.jsp, /app/foo/dir/file.html,/app/foo/bar/dir/file.pdf, 和 /app/dir/file.java |<br>| <code>/**/*.jsp</code>           |    匹配任何的.jsp 文件 |<br>| <code>/api/&#123;id&#125;</code>           |   </p>
<p><code>@RequestMapping</code>, <code>@CompenentScan</code>, <code>@PropertySource</code>以及spring-cloud-gateway中的URL匹配等都是Ant-style</p>
<h3 id="RegEx-VS-Ant-style"><a href="#RegEx-VS-Ant-style" class="headerlink" title="RegEx VS Ant-style"></a>RegEx VS Ant-style</h3><p>正则表达式几乎所有编程语言都支持的通用模式，URL相较于普通的字符串具有很强的规律性：标准的分段式。因此，使用轻量级Ant风格表达式作为URL的匹配模式更为合适。</p>
<h3 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h3><p>很多时候，URL匹配规则写完之后不知道是否正确，用最简单的方式来测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntPathMatcherTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PathMatcher M = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String pattern = <span class="string">&quot;/api/*.html&quot;</span>;</span><br><span class="line">		 System.out.println(<span class="string">&quot;是否匹配成功：&quot;</span> + MATCHER.match(pattern, <span class="string">&quot;/api/index.html&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Ant-style</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot自动装配原理</title>
    <url>/2021/11/11/spring-autoconfigurations/</url>
    <content><![CDATA[<p>在Spring Boot项目流行之前，Spring团队有一款代码生成器就是Spring Roo项目，几分钟就可以构建一个应用，但是现实情况是，大家对此不买账，后来这个项目就永远停留在了2017年。虽然Spring Roo能够帮助生成各种代码和配置，但是总体的代码数量并没有减少。Spring团队的Josh Long一语道破：如果一个东西可以生成出来，那为什么还要生成它呢？</p>
<p>Spring Boot在SpringFramework的基础上引入了4个特性，来提高开发效率</p>
<ul>
<li>starter dependency</li>
<li>auto configuration</li>
<li>actuator</li>
<li>CLI<br>本次我只谈谈前两项。</li>
</ul>
<p>starter dependency(起步依赖)这个名字取得很差，总是让我迷惑，其实应该叫做“依赖分组”。他的目的是要解决依赖管理问题，需要引入什么依赖，版本是什么，互相之间不能有冲突。要解决这个问题根本无需写额外的代码，使用maven就能天然解决，只需要创建一个空项目，然后把同一组依赖(加上版本)放到pom.xml文件中，然后主项目依赖这个空项目即可，等我读懂这些技术以后，我十分失望，因为这是多么的弱智。</p>
<p>auto configuration(自动配置)，它的目的是省去自己动手配置的一模一样的模板配置。框架猜测你会这么配置，如果配置不是你想要的，你就再手动修改就好了。要想我们的配置要在Spring中生效，配置文件的内容要加载到一个对象中，对应一个@Configuration修饰的类。在Spring项目的根路径下，会被自动扫描到，就会加载到容器中。但是现在，它需要在某些条件下才能向Spring容器注入这个Bean，所以这就是构成了自定义配置项的基础。</p>
<p>我们以JdbcTemplateAutoConfiguration为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JdbcProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个配置类生效的条件是存在DataSource和JdbcTemplate类，且上下文中只能有一个DataSource。此外，这个自动配置需要在DataSourceAutoConfiguration之后再配置（可以用@AutoConfigure、@AutoConfigureAfter和@AutoConfigureOrder来控制配置的顺序）。这个配置类还会同时导入JdbcTemplateConfiguration，NamedParameterJdbcTemplateConfiguration里的配置。</p>
<p>更直白地说，比如，<code>@ConditionalOnClass(&#123; DataSource.class, JdbcTemplate.class &#125;)</code>的语义其实是，<code>IF EXISTS DataSource.class&amp;JdbcTemplate.class DO...</code></p>
<p>还有一个很重要的问题，普通配置类需要被扫描到才能生效，可是自动配置类并不在我们项目的扫描路径中，那么我们是如何将它们加载到容器中的呢？</p>
<p>秘密在于<code>@EnableAutoConfiguration</code>上的<code>@Import(AutoConfigurationImportSelector.class)</code>，其中的AutoConfigurationImportSelector类是ImportSelector的实现，这个接口作用就是根据特定条件决定可以导入哪些配置类。接口中的selectImports()方法返回的就是可以导入的配置的类名(String数组)。</p>
<p>AutoConfigurationImportSelector通过SpringFactoriesLoader来加载<code>/META-INF/spring.factories</code>里边的配置列表，所用的key是<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>，value是以都好分隔的自动配置类全限定的类名（包含了完整的包名与类名清单）。所以，只要在我们类上增加<code>@SpringBootApplication</code>或者<code>@EnableAutoConfiguration</code>就会自动加载所有的自动配置类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">// ...</span><br><span class="line">// 100+ more lines</span><br></pre></td></tr></table></figure>

<h1 id="自动装配核心注解-Conditional"><a href="#自动装配核心注解-Conditional" class="headerlink" title="自动装配核心注解@Conditional"></a>自动装配核心注解@Conditional</h1><p>Spring Framework’s @Conditional annotation is the core of Autoconfigurations.<br>@Conditional”系列注解”可以用在@Bean Method, @Components或者其他@Configuration注解上. 它们的作用范围都是<code>@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</code>, 比如@ConditionalOnClass, @ConditionalOnBean, @ConditionalOnMissBean等.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(OnClassCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The classes that must be present. Since this annotation is parsed by loading class</span></span><br><span class="line"><span class="comment">	 * bytecode, it is safe to specify classes here that may ultimately not be on the</span></span><br><span class="line"><span class="comment">	 * classpath, only if this annotation is directly on the affected component and</span></span><br><span class="line"><span class="comment">	 * &lt;b&gt;not&lt;/b&gt; if this annotation is used as a composed, meta-annotation. In order to</span></span><br><span class="line"><span class="comment">	 * use this annotation as a meta-annotation, only use the &#123;<span class="doctag">@link</span> #name&#125; attribute.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes that must be present</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The classes names that must be present.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class names that must be present.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] name() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些注解需要@Conditional的加持(注解不支持继承, 只能通过组合的方式), @Conditional有一个”Condition”类的参数, 这个类中必须有一个方法叫matches(继承父类SpringBootCondition得此方法), 并返回一个Boolean值</p>
<ul>
<li>True: (Further Evaluate/Register) Create that @Bean, @Component or @Configuration</li>
<li>False: (Stop Evaluating/Registering) Don’t create that @Bean, @Component or @Configuration<br>关系如下:<img  src=http://www.plantuml.com/plantuml/svg/VOon3i8m34JtV8L7a6X_01Qer0qnm0-On42arAx83I3Wtma25GR0m_bqVhus9iWnwdxTFtHXXiOqH4HJcbshYbRQ9CvvIDrFiltJvJxPkgPlIDJolcClz8OlZifipPAmKiVm1ycZuLuCv0JoppsXkQg18M5pxcKfuC1WwbvcF7MtEm00></li>
</ul>
<p>附上Condition接口源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A single &#123;<span class="doctag">@code</span> condition&#125; that must be &#123;<span class="doctag">@linkplain</span> #matches matched&#125; in order</span></span><br><span class="line"><span class="comment"> * for a component to be registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions are checked immediately before the bean-definition is due to be</span></span><br><span class="line"><span class="comment"> * registered and are free to veto registration based on any criteria that can</span></span><br><span class="line"><span class="comment"> * be determined at that point.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Conditions must follow the same restrictions as &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> * and take care to never interact with bean instances. For more fine-grained control</span></span><br><span class="line"><span class="comment"> * of conditions that interact with &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; beans consider implementing</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> ConfigurationCondition&#125; interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationCondition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Conditional</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionContext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine if the condition matches.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> metadata the metadata of the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下其中的逻辑:</p>
<blockquote><p>In short: Even though an ApplicationContextConfiguration comes with certain @Bean definitions, you as the end-user can still somewhat influence if a bean gets created or not.</p>
</blockquote>
<p>即使每个ApplicationContextConfiguration都是来自某个@Bean的定义, 但是你最为最终使用者依然拥有对Bean的创建与否的决定权.</p>
<h2 id="AutoConfiguration测试"><a href="#AutoConfiguration测试" class="headerlink" title="AutoConfiguration测试"></a>AutoConfiguration测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// equivalent to @ConditionalOnMissingBean(MyService.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When MyService(bean type) doesn&#x27;t exist, this bean will create.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">&quot;test123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试AutoConfiguration需要借助ApplicationContextRunner, ApplicationContextRunner is usually defined as field of the “test class” to gather the base, common configuration.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.multimodule.service.auto.MyService;</span><br><span class="line"><span class="keyword">import</span> com.example.multimodule.service.auto.MyServiceAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.AutoConfigurations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.runner.ApplicationContextRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// load MyServiceAutoConfiguration.class</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner =</span><br><span class="line">      <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">          .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MyService <span class="title">myCustomService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// This bean is always created.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyService(<span class="string">&quot;mine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">conditionEffectedTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @ConditionalOnMissingBean effect</span></span><br><span class="line">    <span class="keyword">this</span>.contextRunner.run(</span><br><span class="line">        (context) -&gt; &#123;</span><br><span class="line">          assertThat(context).getBean(<span class="string">&quot;myService&quot;</span>);</span><br><span class="line">          assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">          assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class="string">&quot;test123&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">conditionNotEffectedTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @ConditionalOnMissingBean effect</span></span><br><span class="line">    <span class="keyword">this</span>.contextRunner</span><br><span class="line">        .withUserConfiguration(UserConfiguration.class) <span class="comment">// add UserConfiguration into context.</span></span><br><span class="line">        .run(</span><br><span class="line">            (context -&gt; &#123;</span><br><span class="line">              assertThat(context).hasSingleBean(MyService.class);</span><br><span class="line">              assertThat(context)</span><br><span class="line">                  .getBean(<span class="string">&quot;myCustomService&quot;</span>)</span><br><span class="line">                  .isSameAs(context.getBean(MyService.class));</span><br><span class="line">              assertThat(context.getBean(MyService.class).getName()).isEqualTo(<span class="string">&quot;mine&quot;</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上例子中可以看出, 当仅仅ApplicationContext仅仅加载MyServiceAutoConfiguration类时, 注入的Bean是<code>myService</code>, 当MyServiceAutoConfiguration和UserConfiguration都加载是注入的Bean是<code>myCustomService</code>，因为UserConfiguration加载时，注入了MyService类型的Bean，当从中体现出了@ConditionalOnMissingBean的作用（<code>IF NOT EXISTS MyService.class Bean DO ...</code>）</p>
<p>更多关于Autoconfiguration相关Conditional注解的测试可以查看: <a href="https://www.baeldung.com/spring-boot-context-runner">https://www.baeldung.com/spring-boot-context-runner</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring AOP原理</title>
    <url>/2021/10/01/spring-aop/</url>
    <content><![CDATA[<h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><p>对于系统中普遍的业务关注点, OOP可以很好地对其进行分解并使之模块化, <strong>但是却无法更好地避免类似于系统需求的实现在系统中各处散落这样的问题</strong>. 所以, 我们要寻求一种更好的办法在OOP的基础上更上一层楼. 我们可以推翻OOP的概念提出一套全新的思路, 但是也可以在此基础上提供一种补足方案. 后来我们找到了AOP.</p>
<ul>
<li>静态AOP, 第一代AOP, 以AspectJ为代表. 特点是, 相应的横切关注点以Aspect形式实现之后, 会通过特定的编译器, 将实现后的Aspect编译并织入到系统的静态类中. 比如, AspectJ会使用ajc编译器将各个Aspect以Java字节码的形式编译到Java类中, Java虚拟机可以像通常一样加载Java类运行.</li>
<li>动态AOP, 第二代AOP, 通过Java语言的动态特性来实现Aspect织入到系统的过程, 比如Spring AOP.</li>
</ul>
<h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><p>首先我们需要知道在哪些执行点上进行织入操作, 这些将要在其之上进行织入操作的系统执行点, 称之为Joinpoint. 比如, 方法调用时, 执行时, 字段设置时, 异常处理时, 类初始化时等等.</p>
<h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>接下来需要知道在什么地方(Joinpoint)织入横切逻辑. 比如, 指定Joinpoint所在方法的名称, 或者利用正则表达式表述出所有符合条件的多组Joinpoint.</p>
<h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>逻辑载体, 即织入到Joinpoint的横切逻辑. 它分为几种形式:</p>
<ul>
<li>Before Advice, 在Joinpoint位置之前执行的Advice类型</li>
<li>After Advice, 在Joinpoint位置之后, 包括After returning Advice, Afterthrowing Advice等</li>
<li>Around Advice, 这里应该叫做拦截器比较好, Interceptor. 它也可以完成Before Advice和After Advice的功能.</li>
<li>Introduction</li>
</ul>
<h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>Aspect是对以上三者进行封装的AOP概念.</p>
<p>我们可以在Spring源码中看到对应关键词<code>org.springframework.aop.config.ConfigBeanDefinitionParser</code>，这个类主要用来解析xml中定义的<code>&lt;aop:config&gt;</code>等标签，以下是部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT = <span class="string">&quot;aspect&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION = <span class="string">&quot;expression&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">&quot;id&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT = <span class="string">&quot;pointcut&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_BEAN_NAME = <span class="string">&quot;adviceBeanName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVISOR = <span class="string">&quot;advisor&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_REF = <span class="string">&quot;advice-ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_REF = <span class="string">&quot;pointcut-ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REF = <span class="string">&quot;ref&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE = <span class="string">&quot;before&quot;</span>;</span><br><span class="line">    <span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>AOP是一种理论, Spring AOP是针对Spring框架落地的一种AOP实现.</p>
<h3 id="JDK动态代理与CGLIB-基于ASM"><a href="#JDK动态代理与CGLIB-基于ASM" class="headerlink" title="JDK动态代理与CGLIB(基于ASM)"></a>JDK动态代理与CGLIB(基于ASM)</h3><a href="/2021/08/01/pattern-proxy-and-dynamic/" title="动态代理">动态代理</a>，这里不在赘述.
<p>结合Spring AOP来说, 动态代理实现InvocationHandler的类是我们实现横切逻辑的地方, 它是横切逻辑的载体, 作用和Advice是一样的. 这就理解了Advice是什么了.<br>动态代理虽好, 但是不能满足所有需求. 因为动态代理机制只能对实现了相应接口的类使用, 如果某个类没有实现任何接口, 就无法使用动态代理机制为其生成相应的动态代理对象.</p>
<p>使用CGLIB动态字节码生成技术扩展对象行为的原理是, 我们可以对目标对象进行继承扩展, 为其生成相应的子类, 而子类可以通过重写来扩展父类的行为, 只要将横切逻辑放的实现放到子类中, 然后让系统使用扩展后的目标对象的子类, 就可以达到相同的目的了. CGLIB(基于ASM)可以对实现了某种接口的类, 或者没有实现任何接口的类都可以进行扩展.<br>通常我们会直接使用<code>net.sf.cglib.proxy.MethodInterceptor</code>接口(扩展了net.sf.cglib.proxy.Callback接口): </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Requestable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCtrlInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(RequestCtrlInterceptor.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;request&quot;</span>)) &#123;</span><br><span class="line">           TimeOfDay startTime = <span class="keyword">new</span> TiemOfDay(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">           TimeOfDay endTime = <span class="keyword">new</span> TiemOfDay(<span class="number">5</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">           TiemOfDay currentTime = <span class="keyword">new</span> TimeDay();</span><br><span class="line">           <span class="keyword">if</span>(currentTime.isAfter(startTime) &amp;&amp; currentTime.isBefore(endTime)) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;Service is not available now.&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> proxy.invokeSuper(object, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样, RequestCtrlInterceptor就实现了对request()方法请求进行访问控制的逻辑. 现在我们要通过CGLIB的Enhance类为目标动态生成一个类, 并将RequestCtrlInterceptor中的横切逻辑附加到该子类中, 代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(Requestable.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> RequestCtrlInterceptor());</span><br><span class="line"></span><br><span class="line">Requestable proxy = (Requestable) enhancer.create();</span><br><span class="line">proxy.request();</span><br></pre></td></tr></table></figure>
<p>这里是使用Enhancer来演示在对象中加入横切逻辑, 在后续的内容中我们将会使用经过封装的更高级的Spring AOP工具, Advisor</p>
<p>对于Joinpoint, Spring AOP仅支持方法级别的Joinpoint, 更确切的说, 仅支持方法执行(Method Execution)类型的Joinpoint, 原因有以下几点:</p>
<ul>
<li>Spring AOP设计理念是，简单而强大</li>
<li>对于类属性Field级别的Joinpoint, 完全可以使用getter/setter方法的拦截来达到同样的目的</li>
<li>如果要求十分特殊, 借助AspectJ即可(当然即使是AspectJ这样支持很多Joinpoint类型的AOP实现产品, 也无法保证能捕捉到程序流程中的任何一个点)</li>
</ul>
<p>对于Pointcut, Spring AOP提供了org.springframework.aop.Pointcut接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line">    ClassFilter getClassFilter;</span><br><span class="line">    MethodMatcher getMethodMatcher;</span><br><span class="line">    Pointcut TRUE = TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>见名知意, 不是重点, 不再赘述</p>
<p>对于Advice, Advice是实现了将织入到Pointcut规定的Joinpoint处的横切逻辑. Advice的几种类型, 重点介绍Around Advice.<br>Spring中没有直接定义Around Advice的实现接口, 而是采用AOP Alliance的标准接口, 即: <code>org.aopalliance.intercept.MethodInterceptor</code>, 该接口定义如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aopalliance.intercept;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercepts calls on an interface on its way to the target. These</span></span><br><span class="line"><span class="comment"> * are nested &quot;on top&quot; of the target.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Implement this method to perform extra treatments before and</span></span><br><span class="line"><span class="comment">	 * after the invocation. Polite implementations would certainly</span></span><br><span class="line"><span class="comment">	 * like to invoke &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> invocation the method invocation joinpoint</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the result of the call to &#123;<span class="doctag">@link</span> Joinpoint#proceed()&#125;;</span></span><br><span class="line"><span class="comment">	 * might be intercepted by the interceptor</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Throwable if the interceptors or the target object</span></span><br><span class="line"><span class="comment">	 * throws an exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的Advice能做到的事情, 它都可以做, 或者说Around Advice可以应用的场景很多, 例如: 系统安全检查/系统各处性能检测/日志记录/系统附件行为的添加等.</p>
<p>接下来是一个场景: 销售系统, 在商场优惠期间, 所有的商品一律8折, 那么我们在系统中所有取得商品价格的地方插入如下横切逻辑.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_DISCOUNT_RATIO = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span> <span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="keyword">return</span> ((Integer) returnValue) * DEFAULT_DISCOUNT_RATIO / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过MethodInvocation的invoke方法的MethodInvocation参数, 我们可以控制相应的Joinpoint的拦截行为. 通过调用MethodInvocation的proceed()方法, 可以让程序执行继续沿着调用链传播, 这是我们所希望的行为. 如果我们在哪一个MethodInterceptor中没有调用proceed(),那么程序的执行将会在MethodInterceptor处”短路”.</p>
</blockquote>
<p>我们使用了Spring框架, 并且这些Advice实现都是普通的POJO, 更多时候, 会直接将其集成到IoC容器中, 如下所示:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;discountInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...DiscountMethodInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我定义了多个MethodInterceptor时, 他们是如何执行呢?这就要用到**<a href="/2021/11/02/pattern-chain-of-responsibility/" title="责任链模式">责任链模式</a>**</p>
<h2 id="SpringAOP的织入"><a href="#SpringAOP的织入" class="headerlink" title="SpringAOP的织入"></a>SpringAOP的织入</h2><p>AspectJ使用ajc编译器作为它的织入器, 在SpringAOP中使用<code>org.springframework.aop.ProxyFactory</code>, 在Spring AOP中这是最基本的织入器.</p>
<p>总的思路是: <strong>Spring AIO是基于代理模式的AOP实现, 织入完成后, 会返回织入横切逻辑的代理对象</strong>. 也就是说ProxyFactory返回织入了横切逻辑的代理对象.</p>
<p>使用ProxyFactory需要两个基本的东西, 一个是传入进行织入的目标对象, 一个是将要应用到目标对象的Aspect(在Spring中叫做Advisor). 指定对应的Advisor, 就可以添加各种类型的Advice, 比如伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProxyFactory weaver = <span class="keyword">new</span> ProxyFactory(<span class="keyword">new</span> Executable());</span><br><span class="line">NameMatchMethodPointcutAdvisor advisor = <span class="keyword">new</span> NameMathMethodPointcutAdvisor();</span><br><span class="line">advisor.setMappedName(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">advisor.setAdvice(<span class="keyword">new</span> RequestCtrlInterceptor());</span><br><span class="line">weaver.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">weaver.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">Requestable proxyObject = (Requestable) weaver.getProxy();</span><br><span class="line">proxyObject.request();</span><br><span class="line">System.out.println(proxyObject.getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// class ...Requestable$$EnhancerByCGLIB$$9e62fc83</span></span><br><span class="line"><span class="comment">// 从输出中可以看出ProxyFactory底层还是使用了之前的Enhancer, 也可以看出通过CGLIB得到的类的命名方式与动态代理的方式不太一样, 动态代理是&quot;$Proxy0&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们知道Spring AOP在使用代理模式实现AOP的过程中采用了动态代理和CGLIB两种机制, 分别对实现了某些接口的目标类和没有实现任何接口的目标类进行代理. 当目标类没有实现任何接口时, 默认使用动态代理, 但是这里设置了<code>proxyTargetClass</code>的属性为<code>true</code>, 强制其采用基于类的代理, 即使目标类确实是基于接口的.</p>
<h3 id="探索ProxyFactory本质"><a href="#探索ProxyFactory本质" class="headerlink" title="探索ProxyFactory本质"></a>探索ProxyFactory本质</h3><p>先来看一下类之间的关系</p>
<img  src=http://www.plantuml.com/plantuml/svg/RO_12i8m44Jl-OezwgK7Zo92KKH5KF0BrissH6ksfAjOr7_NAbLRcrCoCzbv6zkpAzXkJtakGM4KHH1BlWboAMT8Ag4S0X99iCwde6ASLmu94hTpS3NmFBKA51YLwsSlRXQH-CIbVNCtxJ6ZsvDXoWcUCcrvfWf_Sbsexz8cP9DllTipAQIiRwv-fph9i2XMWfO3qFTUyJOOAjQbFKnBZqT7hx_6j0I8ejiO5luiXEh4pz7RZCCFv9y7ruwUIPgvtQ1UsJm0>

<p>其中AopProxy有Cglib2AopProxy和JdkDynamicProxy两种实现. 因为动态代理需要通过InvocationHandler提供调用拦截, 所以JdkDynamicProxy同时也要实现InvocationHandler接口.</p>
<p>AopProxy实例化代理对象的过程采用了抽象工厂模式进行封装, 即通过AopProxyFactory进行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create an &#123;<span class="doctag">@link</span> AopProxy&#125; for the given AOP configuration.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> config the AOP configuration in the form of an</span></span><br><span class="line"><span class="comment">	 * AdvisedSupport object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the corresponding AOP proxy</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> AopConfigException if the configuration is invalid</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AopProxyFactory的实现类只有一个, 就是DefaultAopProxyFactory, 在DefaultAopProxyFactory会经过一个判断来决定使用Cglib还是动态代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(config.isOptimize || config.isProxyTargetClass() || ...) &#123;</span><br><span class="line">    <span class="comment">// 创建Cglib2AopProxy实例, 返回</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 创建JdkDynamicAopProxy实例, 返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下内容定格在177页《Spring揭秘》, 关于AOP的剩余内容以后在补充.</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP不生效</title>
    <url>/2023/01/20/spring-aop-not-working/</url>
    <content><![CDATA[<a href="/2021/10/01/spring-aop/" title="Spring AOP基础">Spring AOP基础</a>，这里不在赘述.
<h3 id="AOP不生效的案例"><a href="#AOP不生效的案例" class="headerlink" title="AOP不生效的案例"></a>AOP不生效的案例</h3><p>在生产上遇到Spring Cache的注解@CacheEvict不生效，究其原因是在定时任务注解@Scheduled修饰的方法调用了其他方法，这些方法也被@CacheEvict修饰，因为这两个注解都是用Spring AOP来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时任务类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TreasuryFuturesBinJob treasuryFuturesBinJob;</span><br><span class="line">  <span class="meta">@Scheduled(cron = &quot;0 0/1 * * * ?&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treasuryFuturesProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// run方法被@CacheEvict修饰</span></span><br><span class="line">    treasuryFuturesBinJob.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreasuryFuturesBinJob</span> </span>&#123;</span><br><span class="line">  <span class="meta">@CacheEvict(cacheNames = &#123;AuthorizationMenu._TREASURYFUTURES, AuthorizationMenu._CFFEXMEMBER&#125;, allEntries = true)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不生效的原因分析"><a href="#不生效的原因分析" class="headerlink" title="不生效的原因分析"></a>不生效的原因分析</h3><p>这些注解都是利用Spring AOP机制起作用，Spring AOP要使用动态代理来实现，无论是JDK动态代理，还是CGLIB动态代理，都会生成代理类。在IOC容器管理Bean对象管理的过程中，有些Bean对象可能已经不是原始的Bean对象了。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Aware</title>
    <url>/2023/02/04/spring-aware/</url>
    <content><![CDATA[<p>Aware接口的作用<br>Spring IOC容器在创建Bean对象的过程中，如果还需要其他对象，此时可以将对象实现Aware接口，来满足需要。<br>比如，我要通过Foo的对象来获得ApplicationContext，举例如下（XML配置省略）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAwareTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplication(<span class="string">&quot;YOUR_XML_PATH&quot;</span>);</span><br><span class="line">		Foo fooBean = applicationContext.getBean(Foo.class);</span><br><span class="line">		System.out.println(bean.getApplicationContext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>org.springframework.context.ApplicationContextAware</code>继承<code>org.springframework.beans.factory.Aware</code>接口，它是一个顶级Aware接口，作用仅仅是Marker（标记），各种Aware功能的接口都要继承。<br>在实现Aware时，需要借助AOP，于是就有了<code>ApplicationContextAwareProcessor</code>，可以看到它实现了<code>BeanPostProcessor</code>，<code>BeanPostProcessor</code>是在Bean对象实例化之后进行Bean的Processor（增强）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextAwareProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">// code ...</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// code ...</span></span><br><span class="line"></span><br><span class="line">		invokeAwareInterfaces(bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware environmentAware) &#123;</span><br><span class="line">				environmentAware.setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware embeddedValueResolverAware) &#123;</span><br><span class="line">				embeddedValueResolverAware.setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware resourceLoaderAware) &#123;</span><br><span class="line">				resourceLoaderAware.setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware applicationEventPublisherAware) &#123;</span><br><span class="line">				applicationEventPublisherAware.setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware messageSourceAware) &#123;</span><br><span class="line">				messageSourceAware.setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware applicationStartupAware) &#123;</span><br><span class="line">				applicationStartupAware.setApplicationStartup(<span class="keyword">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware applicationContextAware) &#123;</span><br><span class="line">				applicationContextAware.setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Aware</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot启动简要流程</title>
    <url>/2021/09/28/spring-boot-startup/</url>
    <content><![CDATA[<p>SpringBoot的启动过程就是SpringApplication实例化并运行run方法的过程，最终返回ConfigurableApplicationContext实例。 ConfigurableApplicationContext继承了ApplicationContext。</p>
<ol>
<li>获取监听器，启动事件监听</li>
<li>获取命令行参数，准备项目环境</li>
<li>打印Banner</li>
<li>初始化ApplicationContext(对于Web应用返回AnnotationConfigServletWebServerApplicationContext)</li>
<li>prepareContext</li>
<li>刷新上下文(refreshContext)</li>
<li>afterRefresh, 三个方法完整的建立Context</li>
<li>向监听器发出执行结束的通知，返回ConfigurableApplicationContext</li>
</ol>
<p>附上run方法源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line">	DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">	ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">	configureHeadlessProperty();</span><br><span class="line">	SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">	listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);                                                 <span class="comment">// [1]</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">		ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); <span class="comment">// [2]</span></span><br><span class="line">		configureIgnoreBeanInfo(environment);</span><br><span class="line">		Banner printedBanner = printBanner(environment);                                                             <span class="comment">// [3]</span></span><br><span class="line">		context = createApplicationContext();                                                                        <span class="comment">// [4]</span></span><br><span class="line">		context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">		prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);      <span class="comment">// [5]</span></span><br><span class="line">		refreshContext(context);                                                                                     <span class="comment">// [6]</span></span><br><span class="line">		afterRefresh(context, applicationArguments);                                                                 <span class="comment">// [7]</span></span><br><span class="line">		Duration timeTakenToStartup = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">			<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);</span><br><span class="line">		&#125;</span><br><span class="line">		listeners.started(context, timeTakenToStartup);                                                              <span class="comment">// [8]</span></span><br><span class="line">		callRunners(context, applicationArguments);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, listeners);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Duration timeTakenToReady = Duration.ofNanos(System.nanoTime() - startTime);</span><br><span class="line">		listeners.ready(context, timeTakenToReady);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>IOC容器的启动过程</title>
    <url>/2023/02/12/spring-ioc-startup/</url>
    <content><![CDATA[<p><img src="/2023/02/12/spring-ioc-startup/SpringIOC-1.png" alt="IOC启动流程图"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>IoC</category>
      </categories>
  </entry>
  <entry>
    <title>spring 配置优先级</title>
    <url>/2023/07/16/spring-property-sources/</url>
    <content><![CDATA[<p>Spring Boot获取配置参数有一个顺序, 这个顺序是特殊的:</p>
<ol>
<li>Default properties (specified by setting SpringApplication.setDefaultProperties).</li>
<li><code>@PropertySource</code> annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.</li>
<li>Config data (such as application.properties files)</li>
<li>A RandomValuePropertySource that has properties only in random.*.</li>
<li>OS environment variables.</li>
<li>Java System properties (System.getProperties()).</li>
<li>JNDI attributes from java:comp/env.</li>
<li>ServletContext init parameters.</li>
<li>ServletConfig init parameters.</li>
<li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</li>
<li>@TestPropertySource annotations on your tests.</li>
<li>Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.<br>以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.<br>其中, 注解<code>@PropertySource</code>需要注意, 通过注解<code>@PropertySource</code>来定位配置文件<code>.properties</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:application.properties&quot;, ignoreResourceNotFound = true)</span></span><br></pre></td></tr></table></figure>
当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.</li>
</ol>
<blockquote>
<p>提示: Spring Boot将配置的值注入bean的属性有两种办法</p>
<ol>
<li>@Value</li>
<li>@ConfigurationProperties</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring IoC基础</title>
    <url>/2021/09/28/spring-ioc/</url>
    <content><![CDATA[<p>为了方便, 通篇的例子都采用这个模型, 订单, 订单产品, 订单地址的关系, 订单需要依赖订单地址和产品等信息. 一般需要在构造函数中构造Order</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InterfaceItem orderItem;</span><br><span class="line">    <span class="keyword">private</span> InterfaceAddress orderAddress;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Order (InterfaceItem orderItem, InterfaceAddress orderAddress, ...) &#123;</span><br><span class="line">        <span class="keyword">this</span>.orderItem = orderItem;</span><br><span class="line">        <span class="keyword">this</span>.orderAddress = orderAddress;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">persistOrderData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> AmazonOrderItem implements InterfaceItem &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> AmazonOrderAddress implements InterfaceItem &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IoC是如何诞生的"><a href="#IoC是如何诞生的" class="headerlink" title="IoC是如何诞生的"></a>IoC是如何诞生的</h2><p>IoC中文被翻译为”控制反转”, 一直都让我一头雾水, 软件工程师取名总是带着一种”我提出了一个改变世界的概念”的感觉, 不实在. 老外取得名, 在翻译为中文, 更增加了神秘感.<br>得到一个类的实例, 只有一个办法, 就是new YourClass(). 在只有没有Spring框架的时代, 随着业务逻辑的增加, 类中的属性越来越多,当我们要得到实例时, 发现要提前准备很多很多对象, 比如: new YourClass(obj_1, obj_2, obj_3, …), 这些obj_n都是通过new得到的.<br>当人们把很多项目放在一起比较发现, 这些”new操作”, 其实是一种高级别的相似, 那么就可以”抽出它们像的部分”, 让机器帮助我们干这些活.于是, 有人能够把我们需要的某个依赖对象”主动”送过来, 而不是我们自己去new, 所以就是”控制反转”.<br>达到的目的就是”依赖注入”, 将依赖对象注入到被注入对象中.<br>注入的方式有三种, 构造器注入(推荐), setter注入(推荐), Field注入(不推荐)<br>整个IoC的过程可以简化为：加载解析XML &gt; 封装BeanDefination &gt; 实例化 &gt; 放到容器中 &gt; 从容器中Get</p>
<h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p><strong>通常被大家称为IoC容器</strong>. IoC Service Provider职责只有两个, 业务对象的构建和业务对象之间的依赖绑定. 也就是记录依赖关系, 据此生成业务对象.<br>既然是容器，那么容器使用什么数据结构存储呢？必然是Map，Map的key的类型可以是String/Class，储存的value首先得是Object，另外Spring还设计了BeanFactory和BeanDefination等类型<br><strong>Spring的IoC容器是一个IoC Service Provider, 提供了两种类型的支持: BeanFactory和ApplicationContext. 其中ApplicationContext基于BeanFactory, 提供了事件发布等功能.</strong><br>Spring提倡使用POJO, 每个业务对象看做是一个JavaBean. 只有纳入Spring管理的这些类才能看做是业务对象, 如何纳入Spring管理, 就是这些类上有<code>@Configuration</code>, <code>@Component</code>, <code>@Service</code>等注解. 要是定义了一个普通的类, 那么这并不能归IoC容器管辖.</p>
<p>很久以前, 我们基本上都使用XML进行依赖关系的记录, 通过XML很好的给我们展现了,依赖的树形关系, 先完成类的声明, 然后对应编写XML, 比如: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderItem&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;amazonOrderItem&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderAddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;amazonOrderAddress&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;amazonOrderItem&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..impl.AmazonOrderItem&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;amazonOrderAddress&quot;</span> <span class="attr">class</span>=<span class="string">&quot;..impl.AmazonOrderAddress&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>org.springframework.beans.factory.BeanFactory</code>是Spring IoC中最重要类，注释中的第一句话：<em>The root interface for accessing a Spring bean container.</em><br>BeanFactory接口，部分源码。其中注释中有句话很重要，<em>Bean factory implementations should support the standard bean lifecycle interfaces as far as possible</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The root interface for accessing a Spring bean container.</span></span><br><span class="line"><span class="comment"> * This is the basic client view of a bean container;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanNameAware&#x27;s &#123;<span class="doctag">@code</span> setBeanName&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanClassLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;BeanFactoryAware&#x27;s &#123;<span class="doctag">@code</span> setBeanFactory&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EnvironmentAware&#x27;s &#123;<span class="doctag">@code</span> setEnvironment&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;EmbeddedValueResolverAware&#x27;s &#123;<span class="doctag">@code</span> setEmbeddedValueResolver&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ResourceLoaderAware&#x27;s &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationEventPublisherAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;MessageSourceAware&#x27;s &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ApplicationContextAware&#x27;s &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;ServletContextAware&#x27;s &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom &#123;<span class="doctag">@code</span> init-method&#125; definition</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span></span><br><span class="line"><span class="comment"> * &lt;ol&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;DisposableBean&#x27;s &#123;<span class="doctag">@code</span> destroy&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;a custom &#123;<span class="doctag">@code</span> destroy-method&#125; definition</span></span><br><span class="line"><span class="comment"> * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其中<code>prototype</code>, <code>singleton</code>是Spring Bean的scope的两个范围，其次还有<code>request</code>和<code>session</code>，这两个用的少</p>
<ul>
<li>prototype, 容器在接到该类型对象的请求时, 会每次都重新生成一个新的对象实例给请求方</li>
<li>singleton，即单例，全局只有一个对象，这是Spring默认的scope</li>
</ul>
</blockquote>
<p>在拥有了BeanFactory之后, 我们将”生产图纸”交给BeanFactory, 让其为我们生产一个业务对象即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanFactory container = <span class="keyword">new</span> XmlBeanFacotry(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;YOUR_XML_PATH&quot;</span>));</span><br><span class="line">Order order = (Order) container.getBean(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">order.persistOrderData();</span><br></pre></td></tr></table></figure>
<p>或者使用ApplicationContext</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext container = <span class="keyword">new</span> ClassPathXmlApplication(<span class="string">&quot;YOUR_XML_PATH&quot;</span>);</span><br><span class="line">Order order = (Order) container.getBean(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">order.persistOrderData();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：不仅仅是XML这种格式，.json/.properties/.yml都可以当作配置文件来定义Bean，只要做好规范（接口）即可，对应<code>org.springframework.beans.factory.support.BeanDefinitionReader</code>接口，不同类型的配置文件就有了规范<br>XML定义的Bean最终被“翻译”为<code>BeanDefinition</code>的一个个的实例，将这些BeanDefinition进行实例化流程中，Spring加入了很多可扩展的地方，比如：PostProcessor</p>
</blockquote>
<ul>
<li>BeanFactoryPostProcessor，增强（修改）BeanDefination信息，在xml生成BeanDefinition阶段起作用</li>
<li>BeanPostProcessor，增强（修改）Bean信息，在Bean实例化阶段起作用</li>
<li>等等</li>
</ul>
<p>接下来，明确两个概念，一个是Instantiate（实例化），一个是Initialize（初始化），对应Python中的<code>__new__()</code>和<code>__init__()</code></p>
<ul>
<li>Instantiate，是调用构造方法，在堆中开辟一个内存空间，属性赋默认值。</li>
<li>Initialize，是调用init-method，为对象赋值，比如在XML中定义Bean的时候，指定init-method</li>
</ul>
<h3 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h3><p>实现了FactoryBean接口的类，将作为一个Bean放入SpringIOC容器中，然后在某个地方调用FactoryBean.getObject()方法来进行对象的实例化。FactoryBean是Spring框架的一个扩展，方便用户自己灵活进行Bean的创建</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>这里额外介绍一下工厂模式. 在强调面向接口编程的同时, 有一点需要注意: <strong>虽然对象可以通过声明接口来避免对特定接口实现类的过度耦合</strong>, 但总归需要一种方式将声明依赖接口的对象与接口实现类关联起来,. 只依赖一个不做任何事情的接口是没有任何用处的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BarInterface barInterface;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们应该避免这样做</span></span><br><span class="line">        <span class="comment">// instance = new BarInterfaceImpl();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以上类Foo是由我们自定义的, 我们可以在其上<code>@Component</code>或者<code>@Service</code>纳入Spring IoC容器管理, 让容器帮我们解除接口和实现类之间的耦合性. 但是, 如果BarInterface来自于第三方库, 接口与实现类的耦合性需要其他方式来避免. 这是我们可以写一个工厂方法(Factory Method), 提供一个工厂类来实例化具体接口实现类. Foo类只需要依赖于工厂类, 当实现类有变更的时候, 只是变更工厂类, Foo类代码不需要做出任何变动.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BarInterface barInterface;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态工厂</span></span><br><span class="line">        <span class="comment">// barInterface = BarInterfaceFactory.getInterface()</span></span><br><span class="line">        <span class="comment">// 抽象工厂</span></span><br><span class="line">        <span class="comment">// barInterface = new BarInterfaceFactory().getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上操作实际上是在BarInterface与实现类之间加了一层而已. 美其名曰: &quot;解除耦合&quot;.</span></span><br></pre></td></tr></table></figure>
<p>在XML中, 我们可以这样声明, 将这个工厂方法交给Spring容器管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...Foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;barInterface&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;bar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...StaticBarInterfaceFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>factory-method指定工厂方法名, 然后容器调用静态方法getInstance. 也就是说, 为对象foo注入的bar对象实际是BarInterfaceImpl的实例.</p>
<h2 id="容器背后的秘密"><a href="#容器背后的秘密" class="headerlink" title="容器背后的秘密"></a>容器背后的秘密</h2><p>Spring IoC容器实现其功能, 基本上可以按照类似的流程分为两个阶段: 容器启动阶段和Bean实例化阶段</p>
<blockquote>
<p>容器启动阶段: 加载配置 &gt; 分析配置信息 &gt; 装备到BeanDefinition &gt; 其他后处理 …</p>
</blockquote>
<ul>
<li>容器需要依赖BeanDefinitionReader对加载的Configuration MetaData就行解析和处理, 最后注册到BeanDefinitionRegistory<blockquote>
<p>Bean实例化阶段: 实例化对象 &gt; 装配依赖 &gt; 生命周期回调 &gt; 对象其他处理 &gt; 注册回调接口 …</p>
</blockquote>
</li>
<li>所有的Bean定义都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中. 当某个请求通过容器getBean时, 就会触发第二阶段</li>
</ul>
<p>第一阶段是图纸装配, 第二阶段是使用装配好的生产线生产具体的产品.</p>
<blockquote>
<p>注：<a href="/2021/08/01/pattern-proxy-and-dynamic/" title="结合源码分析IOC容器的启动过程">结合源码分析IOC容器的启动过程</a></p>
</blockquote>
<h3 id="图纸装配"><a href="#图纸装配" class="headerlink" title="图纸装配"></a>图纸装配</h3><p>“图纸装配”从一般的逻辑上来讲要经历, 这几个阶段: 读文件 -&gt; 将文件中的占位符替换 -&gt; 文件中的字符串进行类型装换<br>Spring容器提供了一种叫做BeanFactoryProcessor接口, 一个容器可以有多个BeanFactoryPostProcessor. 比如: </p>
<ul>
<li>PropertyPlaceholderConfigurer, 作用是将占位符替换为properties文件中声明的值.</li>
<li>CustomEditorConfigurer, 将XML格式文件中读取的字符串形式的值进行转换. 具体实现是通过Spring内部提供的JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换, 比如: StringArrayPropertyEditor(将逗号分隔的字符串转为String[]), ClassEditor(根据String类型的class名称, 转换为相应的class对象, 相当于Class.forName(String))等等.</li>
</ul>
<blockquote>
<p>插一句, 如果让我去组织这些Processor的话, 我会采用Django框架中middleware的做法, 首先按照顺序列好这些Processor, 然后一个一个执行, PropertyPlaceholderConfigurer &gt; CustomEditorConfigurer &gt; …等等, 每个Processor完成一个步骤, 最后装配成功. 我想Spring框架也会采用这样的办法, 毕竟我们在将Bean注册到Spring容器的时候, 都是可以设置顺序的.</p>
</blockquote>
<h3 id="生产产品"><a href="#生产产品" class="headerlink" title="生产产品"></a>生产产品</h3><p>容器启动之后, 并不会马上进行实例化Bean. 容器现在拥有对象的BeanDefinition来存储实例化必要信息. 当通过BeanFactory.getBean()方法来请求某个对象实例时, 才可能触发Bean实例化阶段的活动. </p>
<h4 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h4><p>容器在内部实现的时候, 采用”策略模式(Strategy Pattern)”来决定使用何种方式初始化bean实例, 通常是通过反射或者CGLIB动态字节码来生成bean实例, 或者其子类. 默认情况下, 容器采用的是CglibSubclassingInstantiationStrategy.</p>
<p>按照正常的逻辑, 容器只需要根据BeanDefintion取得实例化信息, 结合CglibInstantiationStrategy返回对象实例. 但是, 这里的做法不是直接返回构造完成的实例, 而是以BeanWrapper对构造完成的对象实例进行包裹, 返回相应的BeanWrapper实例. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object order = Class.forName(<span class="string">&quot;package.name.Order&quot;</span>).newInstance();</span><br><span class="line">Object orderItem = Class.forName(<span class="string">&quot;package.name.AmazonOrderItem&quot;</span>).newInstance();</span><br><span class="line">Object orderAddress = Class.forName(<span class="string">&quot;package.name.AmazonOrderAddress&quot;</span>).newInstace();</span><br><span class="line"></span><br><span class="line">BeanWrapper newOrder = <span class="keyword">new</span> BeanWrapperImpl(order);</span><br><span class="line">newOrder.setPropertyValue(<span class="string">&quot;newOrderItem&quot;</span>, orderItem);</span><br><span class="line">newOrder.setPropertyValue(<span class="string">&quot;newOrderAddress&quot;</span>, orderAddress);</span><br><span class="line"></span><br><span class="line">assertTrue(newOrder.getWrappedInstance() <span class="keyword">instanceof</span> Order);</span><br><span class="line">assertSame(order, newOrder.getWrappedInstance());</span><br><span class="line">assertSame(orderItem, newOrder.getPropertyValue(<span class="string">&quot;newOrderItem&quot;</span>));</span><br><span class="line">assertSame(orderAddress, newOrder.getPropertyValue(<span class="string">&quot;newOrderAddress&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>针对以上示例, 截一段源码, BeanWrapperImpl是实现类, 这里调用的都是父类AbstractNestablePropertyAccessor的方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperImpl</span> <span class="keyword">extends</span> <span class="title">AbstractNestablePropertyAccessor</span> <span class="keyword">implements</span> <span class="title">BeanWrapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapperImpl</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(object);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractNestablePropertyAccessor</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyAccessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	Object wrappedObject;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getWrappedInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Assert.state(<span class="keyword">this</span>.wrappedObject != <span class="keyword">null</span>, <span class="string">&quot;No wrapped object&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.wrappedObject;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractNestablePropertyAccessor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		registerDefaultEditors();</span><br><span class="line">		setWrappedInstance(object);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWrappedInstance</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">		setWrappedInstance(object, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWrappedInstance</span><span class="params">(Object object, <span class="meta">@Nullable</span> String nestedPath, <span class="meta">@Nullable</span> Object rootObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.wrappedObject = ObjectUtils.unwrapOptional(object);</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(String propertyName, <span class="meta">@Nullable</span> Object value)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// ... 这里用了很多反射的方法.</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果粗略的看没有什么复杂的逻辑, 但是里边的细节很多, 要是让我去写Spring的架构, 最终要的是接口的设计, 层次的划分, 以及需求的抽象. </p>
<h4 id="给实例注入依赖对象"><a href="#给实例注入依赖对象" class="headerlink" title="给实例注入依赖对象"></a>给实例注入依赖对象</h4><p>上一步我们已经将, 属性set到了bean实例上, 但是没有赋值. Spring容器会检查当前实例实现了哪个Aware命名结尾的接口, 然后将对应Aware接口中对顶的依赖注入进去.<br>比如, BeanNameAware, 如果Spring容器检测到当前对象实例实现了该接口, 会将该对象实例的bean定义对应的beanName设置到当前实例. BeanClassLoaderAware, 会将当前bean的ClassLoader注入当前对象实例.</p>
<h4 id="对实例进行前-后-置处理"><a href="#对实例进行前-后-置处理" class="headerlink" title="对实例进行前(后)置处理"></a>对实例进行前(后)置处理</h4><p>现在依赖注入已经完成, 那么接下来可以对实例进行后置处理(hook), Spring提供了侵入的办法, 就是BeanPostProcessor.<br>BeanPostProcessor与BeanFactoryPostProcessor容器混淆. 只要记住BeanPostProcessor存在于对象实例化阶段, 而BeanFactoryPostProcessor存在于容器启动阶段. BeanPostProcessor会处理容器内所有符合条件的实例化后的对象实例. 该接口很简单, 从方法的命名上就可以看出其意义, 一个可以唤作前置处理, 一个唤作后置处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory hook that allows for custom modification of new bean instances,</span></span><br><span class="line"><span class="comment"> * e.g. checking for marker interfaces or wrapping them with proxies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;ApplicationContexts can autodetect BeanPostProcessor beans in their</span></span><br><span class="line"><span class="comment"> * bean definitions and apply them to any beans subsequently created.</span></span><br><span class="line"><span class="comment"> * Plain bean factories allow for programmatic registration of post-processors,</span></span><br><span class="line"><span class="comment"> * applying to all beans created through this factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces</span></span><br><span class="line"><span class="comment"> * or the like will implement &#123;<span class="doctag">@link</span> #postProcessBeforeInitialization&#125;,</span></span><br><span class="line"><span class="comment"> * while post-processors that wrap beans with proxies will normally</span></span><br><span class="line"><span class="comment"> * implement &#123;<span class="doctag">@link</span> #postProcessAfterInitialization&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 10.10.2003</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> InstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DestructionAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableBeanFactory#addBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns the given &#123;<span class="doctag">@code</span> bean&#125; as-is.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean&#x27;s &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class="line"><span class="comment">	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class="line"><span class="comment">	 * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class="line"><span class="comment">	 * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class="line"><span class="comment">	 * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns the given &#123;<span class="doctag">@code</span> bean&#125; as-is.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以自定义BeanPostProcessor, 定义一个类implements BeanPostProcessor, 来把自己的逻辑侵入到bean实例化的过程当中去.</p>
<h4 id="InitialzingBean和init-method"><a href="#InitialzingBean和init-method" class="headerlink" title="InitialzingBean和init-method"></a>InitialzingBean和init-method</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to be implemented by beans that need to react once all their properties</span></span><br><span class="line"><span class="comment"> * have been set by a &#123;<span class="doctag">@link</span> BeanFactory&#125;: e.g. to perform custom initialization,</span></span><br><span class="line"><span class="comment"> * or merely to check that all mandatory properties have been set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An alternative to implementing &#123;<span class="doctag">@code</span> InitializingBean&#125; is specifying a custom</span></span><br><span class="line"><span class="comment"> * init method, for example in an XML bean definition. For a list of all bean</span></span><br><span class="line"><span class="comment"> * lifecycle methods, see the &#123;<span class="doctag">@link</span> BeanFactory BeanFactory javadocs&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DisposableBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.config.BeanDefinition#getPropertyValues()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.support.AbstractBeanDefinition#getInitMethodName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoked by the containing &#123;<span class="doctag">@code</span> BeanFactory&#125; after it has set all bean properties</span></span><br><span class="line"><span class="comment">	 * and satisfied &#123;<span class="doctag">@link</span> BeanFactoryAware&#125;, &#123;<span class="doctag">@code</span> ApplicationContextAware&#125; etc.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This method allows the bean instance to perform validation of its overall</span></span><br><span class="line"><span class="comment">	 * configuration and final initialization when all bean properties have been set.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such as failure to set an</span></span><br><span class="line"><span class="comment">	 * essential property) or if initialization fails for any other reason</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InitializingBean的作用在于, 对象实例化调用过”BeanPostProcessor的前置处理”方法之后, 会接着检测对象是否实现了InitializingBean接口, 如果是, 就会调用afterPropertiesSet()方法进一步调整对象实例的状态.<br>但是, 以上操作显得Spring容器比较具有侵入性, 那么Spring还提供了另一种方式, 那就是在XML的<code>&lt;bean&gt;</code>标签中配置init-method, 可以认为在InitializingBean和init-method中任选其一帮助你完成类似的初始化工作.</p>
<blockquote>
<p>到这里我不仅感叹, 这篇博客是我对《Spring揭秘》的读书和实践的笔记, 可能大部分书籍的文字都来源于对Spring源码中注释的解读.</p>
</blockquote>
<h4 id="DisposableBean与destroy-method"><a href="#DisposableBean与destroy-method" class="headerlink" title="DisposableBean与destroy-method"></a>DisposableBean与destroy-method</h4><p>同样地, 当所有的一切, 该设置的设置, 该注入的注入, 该调用的调用完成之后, 容器会检查singleton类型的bean实例, 是否实现了DisposableBean接口. 或者对应的bean在<code>&lt;bean&gt;</code>里定义了destory-method. 是的话, 就会为该实例注册一个用于对象销毁的回调(Callback), 以便这些singleton类型的对象实例销毁之前, 执行销毁逻辑.</p>
<blockquote>
<p>容器不会去管理, scope为prototype类型的bean实例.</p>
</blockquote>
<h2 id="使用注解代替XML"><a href="#使用注解代替XML" class="headerlink" title="使用注解代替XML"></a>使用注解代替XML</h2><p>在XML配置成功的基础上, 引入了注解来减少冗余操作.<br><code>@Autowired</code>四基于注解的依赖注入的核心注解. 它们都是触发容器对相应对象给与依赖注入的标志. <code>@Autowired</code>是按照类型匹配进行依赖注入的. 现在, 容器的配置文件就只剩下一个个孤零零的bean定义了.</p>
<p>有了注解必须得有Annotation Processor, 要不然注解和注释没什么区别, Spring提供了AutowiredAnnotationBeanPostProcessor来得到这一目的. 通过反射检查每个bean定义对应的类上的各种可能位置上的<code>@Autowired</code>. 存在, 就从当前容器管理的对象中获取符合条件的对象, 设置给<code>@Autowired</code>锁标注的属性或方法. 伪代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] beans = ...;</span><br><span class="line"><span class="keyword">for</span> (Objec bean: beans) &#123;</span><br><span class="line">    <span class="keyword">if</span>(autowiredExistsOnField(bean))&#123;</span><br><span class="line">        Field f = getQulifiedField(bean);</span><br><span class="line">        setAccessiableIfNeccessary(f);</span><br><span class="line">        f.set(getBeanByTypeFromContainer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(autowiredExistsOnMethod(bean)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前的<code>@Autowired</code>标注的依赖在容器中找到了两个以上的实例的话, 就需要@Qualifier的配合, 出入自定义的name(String)条件作出进一步限定. <code>@Qualifier</code>实际上是byName自动绑定的注解版.</p>
<h4 id="classpath-scanning"><a href="#classpath-scanning" class="headerlink" title="classpath-scanning"></a>classpath-scanning</h4><p>到目前为止, 我们已经通过注解将依赖关系xml定义转移到了源码中. 为了”一套代码, 一处定义”的理念, 要将革命进行彻底. classpath-scanning的诞生!<br>使用相应的注解(<code>@Component</code>, <code>@Service</code>, <code>@Configuration</code>)进行标注之后, classpath-scanning功能从某一顶层包(base package)开始扫描, 当扫描到相应的注解之后, 就会提取该类的信息, 构建对应的BeanDefinition, 然后把构建完成的BeanDefinition注册到容器.<br>classpath-scanning由<code>&lt;context:component-scan&gt;</code>决定. <code>&lt;context:component-scan&gt;</code>默认扫描的注解时<code>@Component</code>. 其中, 在@Component语义的基础上细化后又有了<code>@Repository</code>, <code>@Service</code>/<code>@Controller</code>, 他们同样都会被扫描. <code>@Component</code>的语义更宽泛, 而<code>@Service</code>以及<code>@Repository</code>等更具体. 另外, 对于服务层类定义来说, 使用<code>@Service</code>标注它, 比<code>@Component</code>更加确切.</p>
<p>学习Spring框架, 是不是要抓住Spring中几个大的接口来进行, 比如BeanFactory, BeanPostProcessor等, 毕竟是面向接口的编程. </p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>IoC</category>
      </categories>
  </entry>
  <entry>
    <title>Sublime Text Usage</title>
    <url>/2022/10/01/sublime-text-usage/</url>
    <content><![CDATA[<h2 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h2><p>Perferences &gt; Settings</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;bold_folder_labels&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;caret_extra_bottom&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;caret_extra_top&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;caret_extra_width&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;color_scheme&quot;</span>: <span class="string">&quot;Packages/Color Scheme - Default/Monokai.sublime-color-scheme&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;front_size&quot;</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;highlight_line&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;line_padding_bottom&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;line_padding_top&quot;</span>: <span class="number">1</span></span><br><span class="line">    <span class="comment">// Install Package Control Steps:</span></span><br><span class="line">    <span class="comment">// Preferences &gt; Browse Packages</span></span><br><span class="line">    <span class="comment">// Open Git Bash and Run: git clone https://github.com/wbond/package_control.git &quot;Package Control&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Key-Map"><a href="#Key-Map" class="headerlink" title="Key Map"></a>Key Map</h2><h4 id="Multiple-Selection"><a href="#Multiple-Selection" class="headerlink" title="Multiple Selection"></a>Multiple Selection</h4><pre><code>- `Ctrl+Shift+L` (`Ctrl+U` backwards)
- `Ctrl+D` (`Ctrl+U` backwards) select the hole word, and then to anyone hole words
- `Alt+F3` Find All
- `Ctrl+Alt+Up` or `Ctrl+Alt+Down`
</code></pre>
<h4 id="Tab"><a href="#Tab" class="headerlink" title="Tab"></a>Tab</h4><pre><code>- `Ctrl+W` Close the Tab
- `Ctrl+N` New a Tab, or New a File(in Jetbrains)
</code></pre>
<h4 id="Indent"><a href="#Indent" class="headerlink" title="Indent"></a>Indent</h4><pre><code>- `Ctrl+[` or `Ctrl+]` Indent Line
- `Edit &gt; Line &gt; Reindent`
</code></pre>
<h4 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h4><pre><code>- `File &gt; Open Folder` and `View &gt; Side Bar &gt; Show Side Bar`
- `Ctrl+P` Go to file in project
- `Ctrl+R` Go to text in File, or Go to a Method in Java Class File(in Jetbrains)
- `Ctrl+P` input name and select a file, then `Put &#39;:&#39; + Line Number` Go to the Line
- 
</code></pre>
<h4 id="Speed-Edit"><a href="#Speed-Edit" class="headerlink" title="Speed Edit"></a>Speed Edit</h4><pre><code>- `Edit &gt; Convert Case` or `Ctrl+Shift+P` search &#39;Convert Case&#39; to select Case
- `Ctrl+Shift+D` Copy this Line to new Line
- `Alt+Shift+W` Surround with HTML tag
</code></pre>
<h4 id="Move-Cusor"><a href="#Move-Cusor" class="headerlink" title="Move Cusor"></a>Move Cusor</h4><pre><code>- `Alt+Left` and `Alt+Right`
</code></pre>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><pre><code>- `Alt+Shift+2` Columns 2, and `Alt+Shift+1` return 1
- `Alt+Shift+3` Columns 3, and `Alt+Shift+1` return 1
- ...
</code></pre>
]]></content>
      <categories>
        <category>Sublime Text</category>
      </categories>
  </entry>
  <entry>
    <title>图灵完备</title>
    <url>/2021/11/30/theory-turing-completeness/</url>
    <content><![CDATA[<p>这是一篇旨在帮助理解图灵完备及相关概念是什么，而非证明其正确性的回答，它包含以下内容：<br>什么是图灵机图灵机<br>可以解决什么问题<br>什么是图灵完备<br>直观理解图灵完备——Brainfuck语言</p>
<h1 id="什么是图灵机"><a href="#什么是图灵机" class="headerlink" title="什么是图灵机"></a>什么是图灵机</h1><p>图灵机（Turing Machine）是图灵在1936年发表的 “On Computable Numbers, with an Application to the Entscheidungsproblem”（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。既然是数学模型，它就并非一个实体概念，而是架空的一个想法。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。</p>
<p>图灵机的结构包括以下几个部分：一条无限长的纸带（tape），纸带被分成一个个相邻的格子（square），每个格子都可以写上至多一个字符（symbol）。一个字符表（alphabet），即字符的集合，它包含纸带上可能出现的所有字符。其中包含一个特殊的空白字符（blank），意思是此格子没有任何字符。一个读写头（head），可理解为指向其中一个格子的指针。它可以读取/擦除/写入当前格子的内容，此外也可以每次向左/右移动一个格子。一个状态寄存器（state register），它追踪着每一步运算过程中，整个机器所处的状态（运行/终止）。当这个状态从运行变为终止，则运算结束，机器停机并交回控制权。如果你了解有限状态机，它便对应着有限状态机里的状态。一个有限的指令集（instructions table），它记录着读写头在特定情况下应该执行的行为。可以想象读写头随身有一本操作指南，里面记录着很多条类似于“当你身处编号53的格子并看到其内容为0时，擦除，改写为1，并向右移一格。此外，令下一状态为运行。”这样的命令。其实某种意义上，这个指令集就对应着程序员所写下的程序了。</p>
<p>在计算开始前，纸带可以是完全空白，也可以在某些格子里预先就有写上部分字符作为输入。运算开始时，读写头从某一位置开始，严格按照此刻的配置（configuration），即：</p>
<ul>
<li>当前所处位置</li>
<li>当前格子内容</li>
</ul>
<p>来一步步的对照着指令集去进行操作，直到状态变为停止，运算结束。而后纸带上留下的信息，即字符的序列（比如类似“…011001…”）便作为输出，由人来解码为自然语言。</p>
<p>要重申一下，以上只是图灵机模型的内容，而非具体的实现。所谓的纸带和读写头都只是图灵提出的抽象概念。为便于理解打一个比方。算盘虽然不是图灵机（因为它没有无限长的纸带，即无限的存储空间），但它的行为与图灵机一致。每一串算珠都是纸带上的一格，一串算珠上展示的数字便记录着当前格中的字符（可以是空白，可以是 12345 ）。人类的手即是读写头，可以更改每串算珠的状态。算盘的运行遵循人脑中的算法，当算法结束，算盘停机。</p>
<h1 id="图灵机可以解决什么问题"><a href="#图灵机可以解决什么问题" class="headerlink" title="图灵机可以解决什么问题"></a>图灵机可以解决什么问题</h1><p>在文章中，图灵所做的事是证明了，假设上述模型里所说的功能都能被以某种形式物理实现，那么任意可计算问题都可以被解决。这里所说的可计算问题，涉及到计算理论（Computation Theory）的概念。这个领域的概念很繁杂，先简单梳理一下。<br>在计算机领域，或者说自动机领域，我们研究的一切问题都是计算问题（Computational Problem）。它泛指一切与计算相关的问题。</p>
<blockquote>
<p>A computational problem is a mathematical object representing a collection of questions that computers might be able to solve.</p>
</blockquote>
<p>计算问题的一些举例：</p>
<ul>
<li>给定一个正整数 n，判断它是否是质数</li>
<li>给定一个 01 序列，把它们按位取反</li>
<li>给定一个字符串，判断某个字符是否存在，及查找存在位置</li>
<li>给定一个逻辑蕴含的命题，求它的逆否命题<br>非计算问题的例子：</li>
<li>今晚吃什么</li>
<li>为什么太阳从东边升起</li>
</ul>
<p>计算问题有的可以解决，有的不可解决。这就引出了计算问题的可计算性（Computability）。它可以被理解为“是否存在一个算法，能解决在任何输入下的此计算问题”。如上面的问题 1，我们当然可以找到一个算法来解决判断任意正整数 n 是否为质数的问题（比如从2遍历到 n-1，看 n 是否可以整除它）。所以，问题 1 就是可计算的。</p>
<p>也有一些不可计算的计算问题，比如著名的停机问题（Halting Problem）。它的表述是这样的：给定一段程序的描述和该程序的一个有效输入，运行此程序，那么程序最终是会终止，还是会死循环下去？</p>
<blockquote>
<p>Halting Problem: given the description of an arbitrary program and a finite input, decide whether the program finishes running or will run forever. </p>
</blockquote>
<p>这个问题很绕人，有点像那个著名的理发师悖论，但它确实是一个计算问题。更具体的，它是一个不可判定问题（Undecidable Problem）。即不存在一个通用算法，可以在任意输入下解决此问题。图灵在文章里很优雅的用反证法推翻了假设“假设有这么一个算法可以解决任何停机问题”，从而证明了这样的算法并不存在。具体证明过程网上的资料非常丰富，我就不再花篇幅了。</p>
<p>回到这一节的主题。简而言之，对于一个问题，对于任意输入，只要人类可以保证算出结果（不管花多少时间），那么图灵机就可以保证算出结果（不管花多少时间）。</p>
<h1 id="什么是图灵完备"><a href="#什么是图灵完备" class="headerlink" title="什么是图灵完备"></a>什么是图灵完备</h1><p>图灵完备性（Turing Completeness）是针对一套数据操作规则而言的概念。数据操作规则可以是一门编程语言，也可以是计算机里具体实现了的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称它具有图灵完备性。直白一点说，图灵完备性就是我给你一工具箱的东西，包括无限内存、if/else 控制流、while 循环……那么你现在图灵完备了吗？</p>
<p>概念本身倒是非常直观，但整件事似乎还是让人云里雾里。我曾经一直不懂的就是为什么图灵给出的那个命题是正确的。换句话说，凭什么有了纸带以及其他的那一套东西，就可以自信解决任意可计算问题呢？尽管我不能通读他的那篇论文里的证明，但是通过一门叫做 Brainfuck 的编程语言，还是可以获得一些直觉。</p>
<h1 id="直观理解图灵完备——Brainfuck-语言"><a href="#直观理解图灵完备——Brainfuck-语言" class="headerlink" title="直观理解图灵完备——Brainfuck 语言"></a>直观理解图灵完备——Brainfuck 语言</h1><p>如今主流的编程语言（C++，Java，Python，以及等等等等）都是图灵完备的语言。关于语言优劣之争也只是在其封装、优化等方面，以及因为这些区别而产生的“不同语言适用于不同情况”的争执。如果我们回到最底层，就会发现它们可以实现的功能其实完全一样，并且本质上就是一个图灵机。在1993年，Urban Müller 发明了 Brainfuck 语言。这门语言可以说是编程语言界的 helloworld 了——它一共只含有 8 个有效字符，每个有效字符就是一条指令。语言虽然极致轻量，它却是一门图灵完备的编程语言。如果能理解它的工作原理，那么对于理解图灵机是有很大帮助的。</p>
<blockquote>
<p>Brainfuck is fully Turing-complete.</p>
</blockquote>
<p>先贴上一段 BF 的代码，体验一下它的画风：</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;++&gt;++<span class="literal">+</span>&gt;++<span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span>&gt;<span class="literal">+</span>&gt;<span class="literal">+</span>&gt;<span class="literal">-</span>&gt;&gt;<span class="literal">+</span><span class="title">[</span>&lt;<span class="title">]</span>&lt;<span class="literal">-</span><span class="title">]</span>&gt;&gt;<span class="string">.</span>&gt;--<span class="literal">-</span><span class="string">.</span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>&gt;&gt;<span class="string">.</span>&lt;<span class="literal">-</span><span class="string">.</span>&lt;<span class="string">.</span>++<span class="literal">+</span></span><br><span class="line"><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;&gt;<span class="literal">+</span><span class="string">.</span>&gt;++<span class="string">.</span></span><br></pre></td></tr></table></figure>
<p>这个程序编译运行后，控制台打印 “Hello World!”。</p>
<p>BF 的工作机制与图灵机高度一致。首先它存储数据的方式是一个不限长的一维整数数组，里面的数值全部初始化为 0。此外，有一数据指针，每一时刻都指向数组的某一任意元素。指针可以向左/右移动，也可以读取/修改当前值。</p>
<p>语言里的 8 个有效字符分别是：</p>
<ul>
<li><code>&gt;</code> —- 指针向右移动一格</li>
<li><code>&lt;</code> —- 指针向左移动一格</li>
<li><code>+</code> —- 使指针当前格数值加一</li>
<li><code>-</code> —- 使指针当前格数值减一</li>
<li><code>.</code> —- 把当前格数值按 ASCII 表输出到终端</li>
<li><code>,</code> —- 从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</li>
<li><code>[</code> —- 当指针当前值为 0 时，程序跳转至与之对应的 <code>]</code> 之后；否则程序正常执行</li>
<li><code>]</code> —- 程序跳转回与之对应的 <code>[</code> 处</li>
</ul>
<p>有了这些工具，我们可以很快做出一个计算乘法的程序。因为 ASCII 表中 ‘A’ 对应的值为 65，可以使用 5 * 13 算出 65 并输出得到字符 ‘A’。</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span></span><br><span class="line"><span class="title">[</span></span><br><span class="line">&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span></span><br><span class="line">&lt;<span class="literal">-</span></span><br><span class="line"><span class="title">]</span></span><br><span class="line">&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>把指针初始处的格子命名为 cell 0，cell 0 右边的那个格子命名为 cell 1。那么第一句将其递增 5 次变为 5。然后，循环执行“右移指针，递增 13 次， 左移指针，递减 1 次”。当 cell 0 的值最终被递减为 0 的时候，循环结束。此时 cell 1 的值执行了 5 次“递增 13 次”的操作，即 65。指针右移至 cell 1，输出此格子，则在终端会看到 ‘A’。</p>
<p>编译运行上述代码块我写这个例子的目的是演示只用图灵机的模型，就可以确实计算出乘法的结果。那么自然更加复杂的计算也可以被拆解成图灵机操作（尽管可能非常琐碎）。此外，这个语言因为简洁，也是第一次练习写编译器的一个非常好的选择。</p>
]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>Turing</tag>
      </tags>
  </entry>
  <entry>
    <title>trader-course</title>
    <url>/2023/08/18/trader-course/</url>
    <content><![CDATA[<h5 id="14天债券交易员集训"><a href="#14天债券交易员集训" class="headerlink" title="14天债券交易员集训"></a>14天债券交易员集训</h5><p>11月14日</p>
<ul>
<li>债券市场基础知识（一），债券历史，一级市场概述<br>11月15日</li>
<li>债券市场基础知识（二），二级市场概述，债券收益率曲线、久期和凸性<br>在债券投资里，以净价来交易，但以全价进行结算，债券的全价=净价+应计利息<br>债券投资，如果把时间拉的足够长，那么收益的70%以上都来自于稳定的票息收益<br>R=无风险利率+预期通货膨胀率+期限利差+信用利差+流动性溢价，其中“期限利差”，听起来像是再说Yield and Spread</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>VS Code最佳实践</title>
    <url>/2022/01/22/vscode-guide/</url>
    <content><![CDATA[<h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p>下载vs code<br>下载nodejs<br>配置npm的registry url为淘宝镜像地址<br>使用npm下载cnpm</p>
<h1 id="vue开发常用插件列表"><a href="#vue开发常用插件列表" class="headerlink" title="vue开发常用插件列表"></a>vue开发常用插件列表</h1>]]></content>
      <tags>
        <tag>Virtual Box</tag>
      </tags>
  </entry>
  <entry>
    <title>1.程序的本质</title>
    <url>/2023/06/11/xzg-program-beauty-01/</url>
    <content><![CDATA[<p>本节我们就来探究一下，代码是如何被执行的？在执行过程中，CPU、操作系统和虚拟机都起到了什么作用？</p>
<h2 id="一、解释型、编译型、混合型语言"><a href="#一、解释型、编译型、混合型语言" class="headerlink" title="一、解释型、编译型、混合型语言"></a>一、解释型、编译型、混合型语言</h2><p>要回答上述问题，要从基础开始讲起。</p>
<p>我们知道，CPU只认识机器指令（也叫做CPU指令、机器码），用像Python、C++、Java这样的高级语言编写的代码，需要编译（编译的意思实际上就是“翻译”）为机器指令之后，才能被CPU执行。而不同类型的语言，其编译过程也是不同的，据此我们将其分为三类。</p>
<h4 id="1）编译型语言"><a href="#1）编译型语言" class="headerlink" title="1）编译型语言"></a>1）编译型语言</h4><p><strong>对于类似C++这样的编译型语言，代码会事先被编译成机器指令（可执行文件），然后再一股脑儿交给CPU来执行。在执行时，CPU面对是已经编译好的机器指令，直接逐条执行即可，执行效率比较高。</strong>但因为每种类型的CPU（比如Intel、ARM等<br>）支持的CPU指令集不同，并且程序还有可能调用操作系统提供的API，所以，编译之后的可执行文件<strong>只能在特定的操作系统和机器上执行</strong>，换一种操作系统或机器，编译之后的可执行文件就无法执行了。</p>
<h4 id="2）解释型语言"><a href="#2）解释型语言" class="headerlink" title="2）解释型语言"></a>2）解释型语言</h4><p>对于类似Python这样的解释型语言，代码并不会被事先编译成机器指令，而是在执行的过程中，<strong>由Python虚拟机（也叫做解释器）逐条取出程序中的代码，编译成机器指令，交由CPU执行，完成之后，再取出下一条代码，重复上述的编译、执行过程。</strong>这种一边编译一边执行的过程，叫做解释执行。解释型语言相对于编译型语言，执行速度会慢一些。因为程序是在执行的过程中一边编译一边执行的，所以，程序整体的执行时间包含了程序编译的时间。不过，使用解释性语言编写的代码，可移植性更好。<br>程序在执行的过程中，虚拟机可以根据当前所在机器的CPU类型和操作系统类型，翻译成不同的CPU指令。这样，同一份代码就可以运行在不同类型的机器和不同类型的操作系统上。这就是常听到的“一次编写，多处运行”。</p>
<h4 id="3）混合型语言"><a href="#3）混合型语言" class="headerlink" title="3）混合型语言"></a>3）混合型语言</h4><p>Java语言比较特殊，它属于混合型语言，既包含编译执行也包含解释执行。<strong>Java编译器会先将代码（.java文件）编译成字节码（.class文件）而非机器码，字节码算是Java代码的一种中间状态，其跟平台无关，但又可以快速地被翻译成机器码。编译之后的字节码在执行时，仍然是解释执行的，也就是逐行读出字节码，然后翻译成机器码，再交给CPU执行。</strong>只不过，从字节码到机器码的翻译过程，比从高级语言到机器码的翻译过程，耗时要少。这样既保证了Java代码的可移植性（同一份代码可以运行在不同的CPU和操作系统上）又避免了解释执行效率低的问题。</p>
<p><strong>实际上，在解释执行时，也存在编译执行。Java虚拟机会将热点字节码（反复多次执行的代码，类似缓存中的热点数据），编译成机器码缓存起来，以供反复执行，这样就避免了热点<br>字节码反复编译，进一步节省了解释执行的时间。这就是著名的JIT编译（Just In Time Compile，即时编译），</strong>这部分内容会在专栏的第三部分中详细讲解，这里就暂不展开。</p>
<h2 id="二、CPU、操作系统、虚拟机"><a href="#二、CPU、操作系统、虚拟机" class="headerlink" title="二、CPU、操作系统、虚拟机"></a>二、CPU、操作系统、虚拟机</h2><p>上面反复提到了CPU、操作系统、虚拟机，现在，我们就来看下它们在程序的执行过程中，扮演了什么角色。CPU的工作非常明确，用来执行编译好的机器指令，我们重点看下操作系统和虚拟机。</p>
<h4 id="1）操作系统在程序执行中的作用"><a href="#1）操作系统在程序执行中的作用" class="headerlink" title="1）操作系统在程序执行中的作用"></a>1）操作系统在程序执行中的作用</h4><p>早期的计算机还没有高级语言和操作系统，程序员用机器指令编写的代码，通过纸带打卡方式记录下来，传输给计算机（可以理解为CPU）直接执行。</p>
<p>随着硬件资源越来越丰富，计算机中开始集成各种硬件设备，比如内存、硬盘、各种输入输出（键盘、鼠标、显示器等），并且，人们希望多个程序能在计算机中并发执行（比如听歌的同时还能打字），于是，操作系统就诞生了。</p>
<p>操作系统用来管理硬件资源和调度程序的执行。打个比如，CPU等硬件就好比车间中的机器，工人就像操作系统，一个个程序就像一个个待执行的任务。工人（操作系统）调度机器（CPU等硬件）来执行各个任务（程序）。</p>
<p>除此之外，操作系统还担当了类库的作用。对于通用的功能代码，比如读写硬盘等，没必要在每个程序中都从零编写一遍。操作系统将这些通用的功能代码，封装成API（专业名称叫做系统调用），供我们在编写应用程序时直接调用。也就是说，在应用程序的执行过程中，CPU可能会跳转去执行操作系统中的某段代码。当然，这段代码肯定是已经编译好的机器指令。</p>
<h4 id="2）虚拟机在程序执行中的作用"><a href="#2）虚拟机在程序执行中的作用" class="headerlink" title="2）虚拟机在程序执行中的作用"></a>2）虚拟机在程序执行中的作用</h4><p>我们先下来对比一下，C++代码、Python代码、Java代码编译和执行的命令。如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// C++</span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ helloword.cpp -o helloworld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./helloword</span></span><br><span class="line"></span><br><span class="line">// Python</span><br><span class="line"><span class="meta">$</span><span class="bash"> python helloworld.py</span></span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line"><span class="meta">$</span><span class="bash"> javac HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java HelloWorld</span></span><br></pre></td></tr></table></figure>
<p>仔细观察上述命令行的区别，我们可以看出，C++编译之后的代码直接就可以执行，而Python和Java代码的执行，需要依赖其他程序，也就是虚拟机，表现在命令行中就是前面有python、java字样。</p>
<p>使用解释型和混合型语言编写的代码，执行过程都需要虚拟机的参与。实际上，虚拟机本身也可以看做一个程序，而且它已经是CPU可以执行的机器指令了。程序员编写的代码相当于嵌套在虚拟机程序中一个插件（或者功能模块），只不过，它跟虚拟机本身的代码有点不同，无法直接交给CPU执行。虚拟机将字节码翻译成CPU指令，放到固定的内存位置，再通过修改CPU寄存器中存储的地址的方式，引导CPU执行这块内存中存储的CPU指令（关于这一部分，我们待会会详细讲解）。</p>
<p>如果你是一名经验丰富的Java工程师，不知道你有没有感觉到，虚拟机的这套解释执行的机制，跟Java的反射语法异曲同工，反射是在代码的执行过程中，将字符串（类名、方法名等）转化成代码之后再被执行。而虚拟机的解释执行是将字节码（也可以看做是字符串）转化成CPU指令再执行。</p>
<p>站在操作系统和CPU的角度，<strong>Java程序编译之后的字节码跟虚拟机合并在一起，才算是一个完整的程序，才相当于C++编译之后的可执行文件。CPU在执行程序员编写的代码的同时，也在执行虚拟机代码。而且是先执行虚拟机代码，然后才是引导执行程序员编写的代码。</strong></p>
<h2 id="三、CPU指令、汇编语言、字节码"><a href="#三、CPU指令、汇编语言、字节码" class="headerlink" title="三、CPU指令、汇编语言、字节码"></a>三、CPU指令、汇编语言、字节码</h2><p>前面反复提到CPU指令、字节码，估计你对此会很好奇，它们到底长什么样子。现在，我们就来具体看下。不过，提到CPU指令，免不了要讲一下汇编语言，所以，接下来，我们也会一并讲一下汇编语言。</p>
<h4 id="1）CPU指令"><a href="#1）CPU指令" class="headerlink" title="1）CPU指令"></a>1）CPU指令</h4><p>前面提到，我们经常说的CPU指令、机器码、机器指令，实际上都是一个东西，就是CPU可以完成的操作。一条CPU指令包含的信息主要有：操作码、地址、数据三种，指明所要执行的操作、数据来源、操作结果去向。</p>
<p>CPU可以完成的所有的操作，叫做指令集。常见的指令集有X86、X86-64、ARM、MIPS等。不同的CPU支持的指令集可能不同（Intel CPU支持的X86指令集，ARM CPU支持指令集ARM）。当然，不同的CPU支持的指令集也可以相同（比如Intel和AMD的CPU都支持X86和X86-64指令集）。同一个CPU也可以支持多种指令集（Intel CPU支持的指令集有X86、X86-64以及其他扩展指令集）。CPU支持的指令集一般都非常庞大，例如Intel CPU支持2000多条指令，可以完成诸多不同类型的操作。</p>
<h4 id="2）汇编语言"><a href="#2）汇编语言" class="headerlink" title="2）汇编语言"></a>2）汇编语言</h4><p>前面提到，在计算机发展的早期，程序员直接使用机器码来编写程序。但是，因为机器码是二进制码，所以，编写起来复杂、可读性也不好。为了解决这个问题，汇编语言就被发明出来了。汇编语言由一组汇编指令构成，汇编指令跟CPU指令一一对应，但汇编指令采用字符串而非二进制数来表示指令，所以，可读性好很多。实际上，CPU指令和汇编指令之间的关系，就类似IP地址和域名之间的关系，IP地址和域名一一对应，域名的可读性比IP地址好。</p>
<p>程序员使用汇编语言编写的代码，需要经过编译，翻译成机器码才能被CPU执行。这个编译过程有个特殊的名称，叫做“汇编”。C/C++语言的编译过程，实际上就包含汇编这一步骤。编译器先将C/C++代码编译成汇编代码，然后再汇编成机器码。</p>
<p>我们拿一段C语言代码来举例，如下所示，看看编译之后的汇编代码长什么样子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// hello.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">  int b = 2;</span><br><span class="line">  int c = a + b;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码编译成汇编代码，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.s</span></span><br><span class="line"></span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># %bb.0:</span></span></span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp,%rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	movl	$0,-4(%rbp)</span><br><span class="line">	movl	$1,-8(%rbp)</span><br><span class="line">	movl	$2, -12(%rbp)</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	addl	-12(%rbp), %eax</span><br><span class="line">	movl	%eax, -16(%rbp)</span><br><span class="line">	movl	-16(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br></pre></td></tr></table></figure>

<p>有同学可能有疑问，这个汇编代码跟他见过的不大一样，实际上，汇编指令跟CPU指令一一对应，相同指令集对应的汇编指令集都是一样的（比如上面的代码是Intel的CPU支持的X86指令集对应的汇编代码）<br>，只不过语法格式<br>有可能不同。汇编语言主要有两种语法格式，一种是Intel风格的，一种是AT&amp;T风格的。上述汇编代码是AT&amp;T风格，对应的Intel风格如下所示。对比上下两段汇编<br>代码，唯一的区别就是格式不同而已。注意下面这段代码添加了部分注释，汇编中的注释以分号开头。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S -masm=intel hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.s</span></span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># %bb.0:</span></span></span><br><span class="line">	push	rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset rbp, -16</span><br><span class="line">	mov	rbp, rsp</span><br><span class="line">	.cfi_def_cfa_register rbp</span><br><span class="line">	mov	dword ptr [rbp - 4], 0  ;安全word，没有实际意义</span><br><span class="line">	mov	dword ptr [rbp - 8], 1  ;int a = 1; 存储在栈中rbp-8的位置</span><br><span class="line">	mov	dword ptr [rbp - 12], 2 ;int b = 2; 存储在栈中rpb-12的位置</span><br><span class="line">	mov	eax, dword ptr [rbp - 8] ;a的值累加在寄存器eax上</span><br><span class="line">	add	eax, dword ptr [rbp - 12] ;b的值累加在寄存器eax上</span><br><span class="line">	mov	dword ptr [rbp - 16], eax ;int c = a+b</span><br><span class="line">	mov	eax, dword ptr [rbp - 16] ;return c。返回值通过eax返回给上层。</span><br><span class="line">        ;所以，把c值赋值给eax。因为上一句指令结束之后，</span><br><span class="line">        ;有可能还有其他运算还会用到eax（本程序比较简单，没有其他运算了），</span><br><span class="line">        ;所以eax中的值有可能会被改变，所以程序返回时重新将c值重新赋值给eax。</span><br><span class="line">	pop	rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>对于没学习过汇编语言的同学，完全理解上述汇编代码可能比较困难。不过，这里，我们只需要简单了解汇编代码长什么样子，有个直观的认识即可。关于以上汇编代码的具体解释，我们在下一节会讲到。</p>
<h4 id="3）字节码"><a href="#3）字节码" class="headerlink" title="3）字节码"></a>3）字节码</h4><p>我们常说，Java语言是跨平台的，”write once, run anywhere”（一次编写，多处运行）。程序员编写的代码，在不需要任何修改的情况下，就可以运行在不同的平台上（不同的操作系统和CPU）。</p>
<p><strong>有人认为，Java语言之所以能跨平台，是字节码的功劳。因为字节码跟平台无关，我们在一个平台上编译得到的字节码，可以运行在其他平台上。实际上，这样的观点是不确切的。毕竟没有字节码的解释型语言也可以跨平台。字节码诞生的目的是，克服解释型语言解释执行速度慢的缺点（字节码是介于高级语言和机器码之间的形态，比高级语言解释执行更快）。字节码跟平台无关，是为了让Java语言保留解释型语言跨平台的优点，而不是促使Java语言跨平台的最根本原因。这一点要搞清楚。之所以Java语言能做到跨平台，最根本原是有虚拟机的存在。</strong></p>
<p><strong>Java代码跟平台无关，字节码跟平台无关，在编译执行过程中，总要有一个环节跟平台有关，不然，跟平台有关的、最终可以被CPU执行的机器码从何而来。</strong>俗话说的好，哪有什么岁月静好，只是有人帮你负重前行。跟平台有关的环节就是解释执行环节，而这个环节的主导者就是虚拟机。</p>
<p>虚拟机是已经编译好的可以被CPU执行的机器码，而机器码又是跟平台有关的，因此虚拟机必须跟平台有关。这也是为什么在不同的平台（操作系统和CPU）上，我们需要下载不同的Java虚拟机的原因。</p>
<p>明确了字节码的作用之后，我们通过一个简单的例子，来看下字节码到底长什么样子？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">222222</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，我们使用javac命令编译之后，会得到一个后缀为.class的文件HelloWorld.class，这个文件里保存的一堆二进制码就是字节码。为了方便查看，我们用vi打开转化成16进制格式之后，如下所示：<br><img src="/2023/06/11/xzg-program-beauty-01/1.jpeg"><br>这堆二进制码看似天书，实则有固定格式。下图是class文件的大体格式。例如，前4个字节为魔数（Magic Number），为固定值：0xCAFEBABE，用以表示此文件为字节码文件。紧跟着的4个字节表示编译器的JDK版本（major version和minor version）。当然，还有很多细节无法展示在下图中，在本节中，我们不展开介绍，在后面的内容中，慢慢学习。<br><img src="/2023/06/11/xzg-program-beauty-01/2.png"></p>
<p>显然，这样的二进制文件是交给虚拟机解析的，人类阅读起来非常费劲。我们可以使用javap工具，将class文件解析成适合人类阅读的格式，如下所示。这个过程被叫做反编译。为啥叫做反编译呢？我们可以跟“编译”对比着理解。编译是将贴近人阅读的内容，翻译成贴近机器阅读的内容的过程。对应地，反编译就是将贴近机器阅读的内容，翻译成贴近人阅读的内容的<br>过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javap -verbose HelloWorld </span><br><span class="line">Classfile /Users/wangzheng/Desktop/HelloWorld.class</span><br><span class="line">  Last modified 2022-3-20; size 291 bytes</span><br><span class="line">  MD5 checksum ea48b76348ad4f0c07a2bf96840e8e00</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#13         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">  #2 = Integer            222222</span><br><span class="line">  #3 = Class              #14            // HelloWorld</span><br><span class="line">  #4 = Class              #15            // java/lang/Object</span><br><span class="line">  #5 = Utf8               &amp;lt;init&amp;gt;</span><br><span class="line">  #6 = Utf8               ()V</span><br><span class="line">  #7 = Utf8               Code</span><br><span class="line">  #8 = Utf8               LineNumberTable</span><br><span class="line">  #9 = Utf8               main</span><br><span class="line">  #10 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #11 = Utf8               SourceFile</span><br><span class="line">  #12 = Utf8               HelloWorld.java</span><br><span class="line">  #13 = NameAndType        #5:#6          // &quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">  #14 = Utf8               HelloWorld</span><br><span class="line">  #15 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1   // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">        4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">        0: iconst_1</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: ldc           #2     // int 222222</span><br><span class="line">        4: istore_2</span><br><span class="line">        5: iload_1</span><br><span class="line">        6: iload_2</span><br><span class="line">        7: iadd</span><br><span class="line">        8: istore_3</span><br><span class="line">        9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 2</span><br><span class="line">        line 5: 5</span><br><span class="line">        line 6: 9</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure>
<p>不过，你有没有产生过这样的好奇，class文件为什么叫字节码？跟字节（byte）有什么关系呢？实际上，class文件里包含了很多类的信息，而其中main()函数中的代码对应的字节码指令（字节码指令是二进制的，下面的是反编译之后的助记符）<br>只有下面这几行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: iconst_1  //把int型1入栈</span><br><span class="line">1: istore_1  //把栈顶int型数值存入第一个变量，也就是a</span><br><span class="line">2: ldc #2    //将常量池中的#2号常量222222入栈</span><br><span class="line">4: istore_2  //把栈顶int型数值存入第二个变量，也就是b</span><br><span class="line">5: iload_1   //把第一个变量的值入栈</span><br><span class="line">6: iload_2   //把第二个变量的值入栈</span><br><span class="line">7: iadd      //将栈顶的两个int型数据相加，结果压入栈</span><br><span class="line">8: istore_3  //将栈顶int型数值存入第三个变量，也就是c</span><br><span class="line">9: return    //程序返回</span><br></pre></td></tr></table></figure>

<p>一条字节码指令有些包含操作码和操作数两部分，有些只包含操作码这一部分。因为操作码长度为一个字节，所以，这种指令格式被叫做字节码。从另一个角度，我们也可以得知，字节码的操作码类型不超过256个（2^8）。相对于CPU指令和汇编指令，字节码指令少很多。这是因为字节码指令相对于CPU指令来说，抽象程度更高。一条字节码指令完成的逻辑，比一条CPU指令完成的逻辑，更加复杂。</p>
<p>Java8的字节码指令集点击此处查看。</p>
<p>顺道提一句，在上述字节码中，a、b两个变量要先入栈中再计算，计算的结果也会放到栈中。为什么Java将c=a+b代码翻译成基于栈来运算的几条字节码呢？关于这一点，我们今天不展开讲解，在本专栏的JVM部分的基于栈的执行引擎中会给出答案。</p>
<h2 id="四、代码是如何被CPU执行的？"><a href="#四、代码是如何被CPU执行的？" class="headerlink" title="四、代码是如何被CPU执行的？"></a>四、代码是如何被CPU执行的？</h2><p>有了以上铺垫，我们最后讲解一下：“代码是如何被CPU执行的”。</p>
<p>不管是使用哪种类型的编程语言（编译型、解释型、混合型）编写的代码，不管经历什么样的编译、解释过程，最终交给CPU执行的都是机器码。</p>
<p><strong>提到CPU，就不得不提寄存器。</strong></p>
<p><strong>我们知道，内存的读写速度比起CPU指令的执行速度要慢很多。从内存中读取32位二进制数据所耗费的时间，相当于CPU执行上百条指令所耗费的时间。所以，CPU在执行指令时，如果依赖内存来存储计算过程中的中间数据，那么，CPU总是在等待读写内存操作的完成，势必非常会影响CPU的计算速度。为了解决这个问题，寄存器就被发明出来了。</strong></p>
<p>寄存器读写速度非常快，能够跟CPU指令执行速度相匹配。所以，数据会先读取到寄存器中再参与计算。<strong>不过，你可能会说了，数据在计算前需要先从内存读取到寄存器，计算之后存储在寄存器中的结果也要写入到内存，寄存器的存在并没有避免掉内存的读写，使用寄存器是不是多此一举呢？实际上，尽管最初数据来源于内存，最后计算结果也要写入内存，但中间的计算过程涉及到一些临时结果的存取，都可以在寄存器中完成，不用跟非常慢速的内存进行交互。顺便说一句，计算机为了提高CPU读写内存的速度，还引入了L1、L2、L3这三级缓存。</strong></p>
<p>寄存器为了做到能让CPU高速访问，硬件设计比较特殊（高成本、高能耗），且与CPU距离很近（相对于内存来说，寄存器直接跟CPU集成在一起），这些也决定了寄存器的个数不会很多。不同的CPU包含的寄存器会有所不同。常见的寄存器有以下几类。</p>
<h4 id="1）通用寄存器：AX，BX，CX，DX"><a href="#1）通用寄存器：AX，BX，CX，DX" class="headerlink" title="1）通用寄存器：AX，BX，CX，DX"></a>1）通用寄存器：AX，BX，CX，DX</h4><p>通用寄存器区别于下面要讲到的特殊寄存器，它们一般用来存储普通数据。AX，BX，CX，DX这四种通用寄存器的用途又有所区别，比如AX是累加器，这些细节我们就不展开讲解了。</p>
<h4 id="2）指针寄存器：BP，SP，SI，DI，IP"><a href="#2）指针寄存器：BP，SP，SI，DI，IP" class="headerlink" title="2）指针寄存器：BP，SP，SI，DI，IP"></a>2）指针寄存器：BP，SP，SI，DI，IP</h4><p>BP（Base Pointer Register）和SP（Stack Pointer Register）是用于存储栈空间地址的寄存器，SP存储栈顶地址，BP比较特殊，一般存储栈中一个栈帧的栈底地址。这一部分在下一节讲解函数的执行过程时再详细讲解。</p>
<p>SI（Source Index Register）源地址寄存器和DI（Destination Index Register）目的地址寄存器，分别用来存储读取和写入数据的内存地址。</p>
<p>IP（Instruction Pointer Register）指令指针寄存器存储下一条将要执行的指令的内存地址（此处的描述不够准确，下文解释）。</p>
<h3 id="3）段寄存器：CS，DS，SS"><a href="#3）段寄存器：CS，DS，SS" class="headerlink" title="3）段寄存器：CS，DS，SS"></a>3）段寄存器：CS，DS，SS</h3><p>程序由一组指令和一堆数据组成。指令存储在某块内存中（这块内存被称为代码段），由CPU逐一读取执行。数据也存储在某块内存中（这块内存被称为数据段）。指令执行的过程中，会操作<br>（读取或写入）这块内存中的数据。</p>
<p>CS（Code Segment Register）代码段地址寄存器存储了代码段的起始地址。上文中讲到，IP寄存器中存储的是下一条将要执行的指令的内存地址，实际上，这样的说法是不准确的。CS和IP两个寄存器中存储的内容如下计算，才能得到一个真正的物理内存地址。<br><code>物理内存地址 = 段地址（如CS） * 16 + 偏移地址（如IP）</code></p>
<p>我们拿8086 CPU（早期16位的X86 CPU）举例解释。8086CPU具有20位地址总线，支持1MB内存的寻址能力。对于16位的IP寄存器，只能存储64K（2^16）个内存地址，一个字节占一个地址，那么只能支持64KB大小内存的寻址。为了扩大寻址能力，计算机使用段地址和偏移地址相结合的方式来确定一个物理内存地址。</p>
<p>对于存储下一条将要执行的指令的地址的寄存器，你或许还听到过PC寄存器（Program Counter egister）这种叫法。实际上，PC寄存器是一个抽象概念，CS寄存器和IP寄存器是具体寄存器的名称。我们可以简单理解为PC寄存器就是CS寄存器和IP寄存器的抽象统称。</p>
<p>DS（Data Segment Register）数据段地址寄存器存储了数据段的起始地址，同理，它跟DI或SI结合才能确定一个数据段中的内存地址。</p>
<p>SS（Stack Segment Register）栈寄存器存储的是栈的起始地址，同理，它跟SP结合才能确定栈顶的内存地址，跟BP结合才能确定栈中某个中间位置的内存地址。有些同学看到这里可能会有疑问，数据段是存储数据的，栈也是存储数据，这两者有什么联系呢？关于这个问题，我们在下一节文章中会讲到。</p>
<h4 id="4）指令寄存器：IR"><a href="#4）指令寄存器：IR" class="headerlink" title="4）指令寄存器：IR"></a>4）指令寄存器：IR</h4><p>IR（Instruction Register）指令寄存器用来存放当前正在执行的指令。指令为一串二进制码，指令译码器需要从指令中解析出操作码和操作地址或操作数。所以，指令需要暂存在指令寄存器中等待译码处理。</p>
<h4 id="5）标志寄存器"><a href="#5）标志寄存器" class="headerlink" title="5）标志寄存器"></a>5）标志寄存器</h4><p>FR（Flag Register）标志寄存器，也叫做程序状态字寄存器（Program Status Word，PSW）,在这个寄存器中的每一个二进制位记录一类状态。比如cmp比较大小指令的运算结果会存储在ZF零标志位或CF进位标志位中。关于更多细节，我们不展开讲解。</p>
<p>以上寄存器都是用来辅助完成CPU的各种指令。注意，以上是16位的寄存器，32位的寄存器名称在对应的16位寄存器名称前加E（例如EAX，EBP，ESP，EIP），64位的寄存器名称在对应的16位寄存器名称前加R（例如RAX，RBP，RSP，RIP）。在下一节中，在讲解编程语言基本语法的底层实现原理时，我们还会提到更多寄存器的使用细节。</p>
<p><strong>了解了CPU指令执行的重要部件寄存器之后，我们来看下CPU执行指令的流程。</strong></p>
<p>对于编译型语言，操作系统会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据放入内存中的数据段，并且设置好各个寄存器的初始值，如DS、CS等。IP寄存器中存储代码段中第一条指令的内存地址相对于CS的偏移地址。</p>
<p>CPU根据PC寄存器（CS寄存器和IP寄存器的总称）存储的内存地址，从对应的内存单元中取出一条CPU指令，放到IR指令寄存器中，然后将IP寄存器中的地址+4（也就是下一条指令在代码段中的偏移地址。内存中的每一个字节都对应一个地址。对于32位CPU，一条指令长度为4字节，下一条指令地址=当前指令地址+4。对于64位CPU，一条指令长度是8字节，下一条指令地址=当前指令地址+8）。一条指令执行完成之后，再通过PC寄存器中的地址，取下一条指令继续执行。循环往复，直到所有的指令都执行完成。</p>
<p>对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段，然后一条一条地被CPU执行。这部分被执行的指令对应的功能，就包括把程序员编写的程序解释成机器码这一功能。虚拟机把解释好的机器码会放到某段内存中，然后将PC寄存器的地址设置为这段内存的首地址，于是，CPU就被虚拟机引导去执行程序员编写的代码了。</p>
<p>在本节中，我们把程序用到的内存，粗略地分为代码段和数据段，对于Java语言来说，其虚拟机对内存还做了更加细致的划分，这部分内容我们在专栏的JVM部分讲解。</p>
<p>五、课后思考题<br>1）在你熟悉的语言中，有哪些是解释型语言？哪些是编译型语言？哪些是混合型语言？<br>2）本节中提到，C/C++代码会先编译成汇编代码，再汇编成机器码，才能被执行。按理来说，汇编代码跟机器码一一对应，为什么C/C++代码不直接编译成机器码呢？先编译成汇编代码不是多此一举吗？<br>注：对于课后思考题，你都可以在专栏中找到答案，比如今天的第二道题目，在本专栏的JVM部分的第一篇文章中就会讲解。</p>
]]></content>
      <categories>
        <category>编程之美（王争）</category>
      </categories>
  </entry>
  <entry>
    <title>19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？</title>
    <url>/2023/06/12/xzg-program-beauty-19/</url>
    <content><![CDATA[<p>相对于其他Java基础知识，大部分程序员对Java I/O可能没那么了解，毕竟平时的工作很少会编写I/O相关的代码，比如读写文件、网络编程等。跟Java容器类似，java.io类库，也非常庞大，如此多类看得眼花缭乱，想要清晰的掌握，需要对其有个系统性的认识。本节，我就带你一块剖析一下java.io类库，给你构建一个java.io类库的全景图。</p>
<h2 id="一、io类库整体结构"><a href="#一、io类库整体结构" class="headerlink" title="一、io类库整体结构"></a>一、io类库整体结构</h2><p>I/O全称为Input/Output，中文为输入/输出。在计算机中，常用的I/O设备有硬盘、网络、键盘、显示器等，在操作系统层面，I/O系统有文件、网络、标准输入和输出（对应键盘和显示器）、管道等。Java提供的I/O类库就是用来读写这些I/O系统的。Java I/O类库主要有两个：java.io类库和java.nio类库。</p>
<p>在JDK1.4之前，Java引入了java.io类库。在JDK1.4中，<strong>Java引入了java.nio类库，支持非阻塞I/O模型的开发。在JDK7中，Java对java.nio类库进行了升级，引入了更多的类，支持异步I/O模型的开发。</strong>关于java.nio和I/O模型，我们下一节再讲。本节聚焦在java.io类库上。</p>
<p>java.io类库中包含的类非常多。在介绍Java容器时，我们画了一张比较复杂的类图，当时，我也提醒你说，一定要将它搞清楚。对于java.io类库，我们同样花了一张类图，如下图所示，也比较复杂，同理，你也要搞搞清楚。搞清楚了这张图，基本上也就掌握了java.io类库。</p>
<p><img src="/2023/06/12/xzg-program-beauty-19/1.png" alt="java.io.png"></p>
<p>上图包含的类比较多，我们分类讲解。从不同的维度，java.io类库有不同的分类方式。我们按照不同的分类方式，拆解整个java.io类库，并逐一讲解。</p>
<h2 id="二、输入流和输出流"><a href="#二、输入流和输出流" class="headerlink" title="二、输入流和输出流"></a>二、输入流和输出流</h2><p>按照<strong>数据流向</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）输入流：InputStream、Reader"><a href="#1）输入流：InputStream、Reader" class="headerlink" title="1）输入流：InputStream、Reader"></a>1）输入流：InputStream、Reader</h4><h4 id="2）输出流：OutputStream、Writer"><a href="#2）输出流：OutputStream、Writer" class="headerlink" title="2）输出流：OutputStream、Writer"></a>2）输出流：OutputStream、Writer</h4><p><strong>所谓输入流，指的是将文件、网络、标准输入（System.in）、管道中的数据，输入到内存中。所谓输出流，指的是将内存中的数据输出到文件、网络、标准输出（System.out、System.err）、管道中。</strong></p>
<p>输入流的读取方式，如下示例代码所示。<strong>我们通过try-catch-resources语句打开InputStream，这样在try代码块结束后，JVM会自动调用InputStream的close()函数关闭输入流。</strong>为了简化代码编写，本节后续示例代码均省略异常的捕获处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (in.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出流的写入方式，如下示例代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">new</span>  FileOutputStream(<span class="string">&quot;/Users/wangzheng/out.txt&quot;</span>)；</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line">out.write(data);</span><br></pre></td></tr></table></figure>


<h2 id="三、字节流和字符流"><a href="#三、字节流和字符流" class="headerlink" title="三、字节流和字符流"></a>三、字节流和字符流</h2><p>按照数据流的<strong>读写单位</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）字节流：InputStream、OutputStream"><a href="#1）字节流：InputStream、OutputStream" class="headerlink" title="1）字节流：InputStream、OutputStream"></a>1）字节流：InputStream、OutputStream</h4><h4 id="2）字符流：Reader、Writer"><a href="#2）字符流：Reader、Writer" class="headerlink" title="2）字符流：Reader、Writer"></a>2）字符流：Reader、Writer</h4><p>所谓字节流，指的是一个字节一个字节的从输入流中读取数据，或者将数据写入输出流。<strong>所谓字符流，指的是一个字符一个字符的从输入流中读取数据，或者将数据写入输出流。实际上，字符流比起字节流来说，只是多了一个字符编码转换的环节。</strong>我们拿文件读写来举例解释。</p>
<p>前面讲过，<strong>Java中的char类型数据使用UTF16编码，而文件的编码方式有可能是UTF8、GBK等，所以，当从文件中读取数据到Java内存中的char数组时，我们需要将其从文件的编码方式转换为UTF16编码方式，同理，当我们将Java内存中的字符串写入到文件时，需要将UTF16编码转化为文件的编码方式。</strong>示例代码如下所示。在写入完成之后，我们打开a.txt文件，查看文件内容的16进制格式，发现存储的是“王a争”这几个字符的UTF-8编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">String s = <span class="string">&quot;王a争&quot;</span>;</span><br><span class="line">writer.write(s);</span><br></pre></td></tr></table></figure>

<p>从java.io类图中，我们可以发现，Java分别为字符流和字节流设计了两套类。这两套类在代码实现上有些重复，毕竟I/O读写操作都是相同的，唯一的区别只是数据解析的方式不同。实际上，为了字节流和字符流设计两套类完全是没有必要的。java.nio利用“组合优于继承”的设计思想，引入Channel和Buffer的概念，对此设计进行了优化，关于这一点，我们在下节中会详细讲解。</p>
<h2 id="四、原始类和装饰器类"><a href="#四、原始类和装饰器类" class="headerlink" title="四、原始类和装饰器类"></a>四、原始类和装饰器类</h2><p><strong>java.io类库的设计用到了设计模式中的装饰器模式，从这个角度，我们可以将java.io类库中的类分为原始类和装饰器类。</strong>在《设计模式之美》一书中，我详细介绍了java.io类库如何使用装饰器模式简化类的设计，建议你去读一下。这里我们就不再赘述。装饰器类和原始类的区别在于，装饰器类是对原始类的功能增强，不能独立使用。<strong>比如，FileInputStream为原始类，可以独立使用，BufferedInputStream为装饰器类，支持缓存功能，不能独立使用，必须嵌套原始类或其他装饰器类。</strong>示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、原始类分类介绍"><a href="#五、原始类分类介绍" class="headerlink" title="五、原始类分类介绍"></a>五、原始类分类介绍</h2><p>对于原始类，我们还可以按照读写的I/O系统的不同，将其分为如下几类。注意这里不涉及装饰器类，因为装饰器类主要用于增强功能。</p>
<h4 id="1）文件"><a href="#1）文件" class="headerlink" title="1）文件"></a>1）文件</h4><p>跟文件读写相关的类有FileInputStream、FileOutputStream、FileReader、FileWriter。前面已经给出了一些文件读写的示例代码。这里就不再赘述。</p>
<h4 id="2）网络"><a href="#2）网络" class="headerlink" title="2）网络"></a>2）网络</h4><p>实际上，java.io类库并没有提供专门的类用于网络I/O的读写，而是直接复用InputStream类、OutputStream类进行网络I/O的读写。除此之外，单独使用java.io类库也并不能完成网络编程，需要借助java.net类库的配合。java.net类库用来管理网络连接，比如创建连接、关闭连接、监听连接等。java.io类库只负责读写已经建立的网络连接。示例代码如下所示。java.io类库在网络编程中的表现非常差劲，正因为如此，才有了java.nio类库的出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Socket类位于java.net包中</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.29.2.4&quot;</span>, <span class="number">8090</span>);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;hi~&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (in.read(data) != - <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，从java.io的类图中，我们也可以发现，InputStream、OutputStream是所有字节流类的父类，它既可以读写文件，也可以读写网络，还可以读写其他I/O。这充分体现了“抽象”的设计思想。尽管深入到硬件层面，各个I/O设备的读写方式各不相同，但是，上层应用开发并不关系底层实现细节，大部分I/O设备的访问都可以抽象为打开、读、写、关闭等这几个操作。因此，Java将所有的I/O设备都抽象为“Stream（流）”，并为不同I/O设备的读写设计了一套统一的接口。从而对于不同I/O设备的读写，我们可以使用同样的代码实现，代码更加统一、简洁。</p>
<h4 id="3）内存"><a href="#3）内存" class="headerlink" title="3）内存"></a>3）内存</h4><p>跟内存读写相关的类有：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、StringReader、StringWriter。我们将内存看做一种特殊的I/O系统，也可以像文件一样，当作Stream来读写。</p>
<p>在大部分情况下，我们都不需要这些内存读写类，直接对byte数组、char数组进行读写即可，没必要将它们封装成流来操作。这些类的主要作用是实现兼容。比如，我们使用第三方类库中的某个函数，来处理byte数组中的数据，但这个函数的输入参数是InputStream类型的，为了兼容这个函数的定义，我们就可以将待处理的byte数组，封装成ByteArrayInputStream对象，再传递给这个函数处理，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] source = <span class="string">&quot;学技术信小争哥就对了&quot;</span>.getBytes();</span><br><span class="line">InputStream in = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line"><span class="comment">// 接下来就可以跟处理其他InputStream一样处理source了</span></span><br></pre></td></tr></table></figure>


<p>在编写单元测试时，这些内存读写类也非常有用，可以替代文件或网络，将测试数据放置于内存，准备起来更加容易。如下代码所示，假设要为readFromFile()这个函数编写单元测试代码，我们需要创建文件，写入测试数据，并且放置到合适的地方，做一堆准备工作才能完成测试。如果使用ByteArrayInputStream，我们便可以在内存中构建测试数据，这样就方便了很多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readFromFile</span><span class="params">(InputStream inputStream)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_readFromFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] testData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">  <span class="comment">//...构建测试数据，填入testData数组...</span></span><br><span class="line">  InputStream in = <span class="keyword">new</span> ByteIntputStream(testData);</span><br><span class="line">  <span class="keyword">int</span> res = readFromFile(in);</span><br><span class="line">  <span class="comment">//...assert...判断返回值是否符合预期...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4）管道"><a href="#4）管道" class="headerlink" title="4）管道"></a>4）管道</h4><p>跟管道读写相关的类有：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter。<strong>这里的管道跟Unix操作系统中的管道不同，Unix操作系统中的管道是进程间通信的工具，而这里的管道是Java提供的为同一个进程内两个线程之间通信的工具。一个线程通过PipedOutputStream写入的数据，另一个线程就可以通过PipedInputStream读取数据，示例代码如下所示。尽管Java已经提供了很多线程间通信的方式，比如常用的有共享变量，但是，一般来说，对于两个线程之间非对象的原始数据的传输，我们更倾向于使用管道来实现。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PipedOutputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">PipedInputStream in = <span class="keyword">new</span> PipedInputStream(out);</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      out.write(<span class="string">&quot;Hi wangzheng~&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in.read(buffer);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h4 id="5）标准输入输出"><a href="#5）标准输入输出" class="headerlink" title="5）标准输入输出"></a>5）标准输入输出</h4><p><strong>在操作系统中，一般会有三个标准I/O系统：标准输入、标准输出、标准错误输出。标准输入对应I/O设备中的键盘，标准输出和标准错误输出对应I/O设备中的屏幕。</strong>Java中的标准输入为System.in，它是一个定义在System类中的静态InputStream对象。Java中的标准输出和标准错误输出分别为System.out和System.err，它们都是定义在System类中的PrintStream对象。PrintStream为装饰器类，需要嵌套OutputStream来使用，支持按照格式输出数据，待会会讲到。System.in、System.out、System.err的使用示例如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br><span class="line"><span class="comment">//System.err显示的字符串为红色，以表示出错</span></span><br><span class="line">System.err.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br></pre></td></tr></table></figure>



<h2 id="六、装饰器类分类介绍"><a href="#六、装饰器类分类介绍" class="headerlink" title="六、装饰器类分类介绍"></a>六、装饰器类分类介绍</h2><p>装饰器类用于增强原始类的功能。我们按照功能的不同分类讲解装饰器类。</p>
<h4 id="1）支持读写缓存功能的装饰器类"><a href="#1）支持读写缓存功能的装饰器类" class="headerlink" title="1）支持读写缓存功能的装饰器类"></a>1）支持读写缓存功能的装饰器类</h4><p>支持读写缓存功能的装饰器类有：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。这4个类的作用非常相似，我们拿BufferedInputStream、BufferedOutputStream举例讲解。</p>
<p><strong>对比InputStream，BufferedInputStream会在内存中维护一个8192字节大小的缓存。如果缓存中没有足够的数据，那么read()函数会向操作系统内核请求数据</strong>（关于I/O读写的实现原理，我们在第21节中讲解），读取8192字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，不再请求操作系统。</p>
<p><strong>读取同样多的数据，利用BufferedInputStream，向操作系统内核请求数据的次数减少。我们知道，向操作系统内核请求数据，需要使用系统调用，引起用户态和内核态的切换，是非常耗时的，所以，尽量减少系统调用，会提高程序的性能</strong>（关于这一部分内容的详细介绍，我们留在第21节中讲解）。<strong>不过，如果read()函数每次请求的数据量都大于等于8192字节，那么BufferedInputStream就不起作用了。</strong></p>
<p>如下代码所示，如果文件中的数据大小是8192字节，那么，读取所有数据需要调用8次read()函数，但因为缓存的存在，所以仅需要向操作系统内核请求一次数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>));</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，针对OutputStream，java.io类库提供了BufferedOutputStream，用来缓存写入的数据，当积攒到一定量（默认为8192字节）时，再一次性将其写入操作系统内核缓冲区，减少系统调用次数，提高程序的性能。</p>
<h4 id="2）支持基本类型数据读写的装饰器类"><a href="#2）支持基本类型数据读写的装饰器类" class="headerlink" title="2）支持基本类型数据读写的装饰器类"></a>2）支持基本类型数据读写的装饰器类</h4><p>DataInputStream支持将从输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeInt(<span class="number">12</span>);</span><br><span class="line">out.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">out.writeFloat(<span class="number">12.12f</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">System.out.println(in.readInt());</span><br><span class="line">System.out.println(in.readChar());</span><br><span class="line">System.out.println(in.readFloat());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>调用DataOutputStream的readChar()、writeChar()函数，我们也可以按字符为单位读取、写入数据，但跟字符流类不同的地方是，DataOutputStream类一次只能处理一个字符，而字符流类可以处理char数组，并且字符流类提供的函数更多，功能更加丰富。</p>
<h4 id="3）支持对象读写的装饰器类"><a href="#3）支持对象读写的装饰器类" class="headerlink" title="3）支持对象读写的装饰器类"></a>3）支持对象读写的装饰器类</h4><p>ObjectInputStream支持将从输入流中读取的数据反序列化为对象，ObjectOutputStream支持将对象序列化之后写入到输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">&quot;wangzheng&quot;</span>));</span><br><span class="line"></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">Person p = (Person) in.readObject();</span><br><span class="line">System.out.println(p.getId());</span><br><span class="line">System.out.println(p.getName());</span><br></pre></td></tr></table></figure>


<h4 id="4）支持格式化打印数据的装饰器类"><a href="#4）支持格式化打印数据的装饰器类" class="headerlink" title="4）支持格式化打印数据的装饰器类"></a>4）支持格式化打印数据的装饰器类</h4><p>PrintStream和PrintWriter可以将数据按照一定的格式，转化为字符串，写入到输出流。前面讲到System.out、System.err就是PrintStream类型的。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream printStream =<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">printStream.print(<span class="number">124</span>); <span class="comment">//int-&gt;Integer-&gt;toString(), 写入字符串&quot;124&quot;</span></span><br><span class="line">printStream.printf(<span class="string">&quot;hello %d&quot;</span>, <span class="number">43</span>); <span class="comment">//写入字符串&quot;hello 43&quot;</span></span><br></pre></td></tr></table></figure>


<p>除了以上装饰器类之外，还有一组原始类，其功能非常类似装饰器类，那就是InputStreamReader、OutputStreamWriter。InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类。它们可以将字节流转化为字符流。示例代码如下所示。从这一点上，我们也可以看出，java.io类库的设计有很多不合理的地方，更晚开发的java.nio类库在设计上明显要合理很多，下节会详细讲到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStream outStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(outStream, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;王a争&quot;</span>); <span class="comment">//按照gbk编码将字符串写入文件</span></span><br></pre></td></tr></table></figure>


<p>对于其他装饰器类，比如PushbackInputStream、PushbackReader、SequenceInputStream、LineNumberReader，因为使用的比较少，我们就不再介绍了，如果感兴趣，可以自行查阅。</p>
<p>七、课后思考题<br>在本节中，我们频繁提到“Stream（流）”这个字眼，比如输入流、输出流、字节流、字符流等，这里的“流”到底是什么意思？为什么把I/O看作“流”？</p>
]]></content>
      <categories>
        <category>编程之美（王争）</category>
      </categories>
  </entry>
  <entry>
    <title>专业词汇</title>
    <url>/2021/10/05/professional-dictionary/</url>
    <content><![CDATA[<blockquote>
<p>inference 推断 n.</p>
</blockquote>
<p>Lambda expressions include a form of type inference in Java.<br>Lambda表达式包含一种类型推导.</p>
<blockquote>
<p>assign 指派 v.</p>
</blockquote>
<p><code>Shape s = new Circle();</code>  This creates a Circle object, and the resulting reference is immediately assigned to a Shape.<br>这里翻译为”指派”, <code>s</code>被指派(指定)了一个类型Shape.</p>
<blockquote>
<p>oriented 导向的，定向的adj.</p>
</blockquote>
<blockquote>
<p>object-oriented [计]面向对象的adj.</p>
</blockquote>
<blockquote>
<p>Connector 端口，连接头n.</p>
</blockquote>
<blockquote>
<p>Configure 配置v.</p>
</blockquote>
<blockquote>
<p>Specified 指定的adj.</p>
</blockquote>
<blockquote>
<p>Deploy 部署v.</p>
</blockquote>
<blockquote>
<p>Undeploy 卸载v.</p>
</blockquote>
<blockquote>
<p>Expire 终止v.</p>
</blockquote>
<blockquote>
<p>Session 学期，一段时间n.</p>
</blockquote>
<blockquote>
<p>Dynamic 动态的adj.</p>
</blockquote>
<blockquote>
<p>Module 组件，单元，模块n.</p>
</blockquote>
<blockquote>
<p>Directory 路径n.</p>
</blockquote>
<blockquote>
<p>Descriptor 描述符n.</p>
</blockquote>
<blockquote>
<p>Install 安装v.</p>
</blockquote>
<blockquote>
<p>Synchronize 使同步v.</p>
</blockquote>
<blockquote>
<p>Meta 元，meta语言n.</p>
</blockquote>
<blockquote>
<p>Charset 字符集n.</p>
</blockquote>
<blockquote>
<p>Charater 字符n.</p>
</blockquote>
<blockquote>
<p>Flush 冲洗v.</p>
</blockquote>
<blockquote>
<p>Mapping 映射n.</p>
</blockquote>
<blockquote>
<p>Protocol 协议n.</p>
</blockquote>
<blockquote>
<p>Generic 普通的；一般的adj.</p>
</blockquote>
<blockquote>
<p>Initialize 初始化v.</p>
</blockquote>
<blockquote>
<p>Sequence 一系列, 列表n.</p>
</blockquote>
<blockquote>
<p>In addition to 除….之外</p>
</blockquote>
<blockquote>
<p>Thread 线n.</p>
</blockquote>
<blockquote>
<p>Timeout 超时，过期n.</p>
</blockquote>
<blockquote>
<p>Summary 摘要n.</p>
</blockquote>
<blockquote>
<p>Contain 容纳，限制v.</p>
</blockquote>
<blockquote>
<p>Subclass 子类n.</p>
</blockquote>
<blockquote>
<p>Declare 声明v.</p>
</blockquote>
<blockquote>
<p>Dispatch 派遣，发送v.</p>
</blockquote>
<blockquote>
<p>Additional 附加的，额外的adj.</p>
</blockquote>
<blockquote>
<p>Stream 流n.   </p>
</blockquote>
<blockquote>
<p>Input stream输入流</p>
</blockquote>
<blockquote>
<p>Encode 编码v.</p>
</blockquote>
<blockquote>
<p>URL 统一资源定位符</p>
</blockquote>
<blockquote>
<p>URI 统一资源标识符</p>
</blockquote>
<blockquote>
<p>Invalidate 使销毁，使作废v.</p>
</blockquote>
<blockquote>
<p>Layer 层n.</p>
</blockquote>
<blockquote>
<p>Prefix 前缀n.</p>
</blockquote>
<blockquote>
<p>Tag标签 n.</p>
</blockquote>
<blockquote>
<p>Wrapper 包装用品n.</p>
</blockquote>
<blockquote>
<p>Filter 过滤器n.</p>
</blockquote>
<blockquote>
<p>Chain 链条n.</p>
</blockquote>
<blockquote>
<p>Notation 记号；表示法；记法n.</p>
</blockquote>
<blockquote>
<p>Serialize　使连载v.</p>
</blockquote>
<blockquote>
<p>Plugins 插件n.</p>
</blockquote>
<blockquote>
<p>Validate 使生效v.</p>
</blockquote>
<blockquote>
<p>Panel 面板；仪表盘n.</p>
</blockquote>
<blockquote>
<p>Literal 字面上的；文字的adj.  </p>
</blockquote>
<blockquote>
<p>Constant 不变的adj. 常量，恒量；n.</p>
</blockquote>
<blockquote>
<p>Mutable 可变的adj.</p>
</blockquote>
<blockquote>
<p>Specified 指定的；规定的adj.</p>
</blockquote>
<blockquote>
<p>Collapsible 可折叠的，可收缩的adj.</p>
</blockquote>
<blockquote>
<p>Icon 图标[计]；象征；偶像adj.</p>
</blockquote>
<blockquote>
<p>Combo 组合物n.</p>
</blockquote>
<blockquote>
<p>Handler 处理器n.</p>
</blockquote>
<blockquote>
<p>Grid 格子，网格n.</p>
</blockquote>
<blockquote>
<p>Validate 使生效；证实v.</p>
</blockquote>
<blockquote>
<p>Required 必须的adj.</p>
</blockquote>
<blockquote>
<p>Parse 解析v.   从语法上分析n.</p>
</blockquote>
<blockquote>
<p>Separator 分隔符n.</p>
</blockquote>
<blockquote>
<p>Interrupt 中断n.</p>
</blockquote>
<blockquote>
<p>Runnable 可捕捉的，可猎取的 adj.</p>
</blockquote>
<blockquote>
<p>Daemon 守护神，[计]守护线程n.</p>
</blockquote>
<blockquote>
<p>Priority 优先级，优先权，优先顺序n.</p>
</blockquote>
<blockquote>
<p>Notify 通知，报告v.</p>
</blockquote>
<blockquote>
<p>Invoke引起v.</p>
</blockquote>
<blockquote>
<p>Split 分裂，分离v.</p>
</blockquote>
<blockquote>
<p>Deprecated 过时的adj.</p>
</blockquote>
<blockquote>
<p>Suppress禁止，压制v.</p>
</blockquote>
<blockquote>
<p>Retention 保持力，保存期限n.</p>
</blockquote>
<blockquote>
<p>Annotation 注解，注释n.</p>
</blockquote>
<blockquote>
<p>Nickname 昵称，绰号n.</p>
</blockquote>
<blockquote>
<p>Invocation [计]调用；（法律的）实施；祈祷n.</p>
</blockquote>
<blockquote>
<p>Template 样板，模板n.</p>
</blockquote>
<blockquote>
<p>Intersect 交叉，相交v.</p>
</blockquote>
<blockquote>
<p>Minus 减号，减去n.</p>
</blockquote>
<blockquote>
<p>Increment 增加v.</p>
</blockquote>
<blockquote>
<p>Validate 使..生效，确认；v.</p>
</blockquote>
<blockquote>
<p>Encapsulation 包装，封装n.</p>
</blockquote>
<blockquote>
<p>Polymorphism 多态性n.</p>
</blockquote>
<blockquote>
<p>Catalog 目录n.</p>
</blockquote>
<blockquote>
<p>Detached 游离的，分离的；adj.</p>
</blockquote>
<blockquote>
<p>Persistent 持久的；adj.</p>
</blockquote>
<blockquote>
<p>Transient 瞬时的；adj.</p>
</blockquote>
<blockquote>
<p>Dependency 从属n.</p>
</blockquote>
<blockquote>
<p>Injection 注射n.</p>
</blockquote>
<blockquote>
<p>Component 成分，组件n.</p>
</blockquote>
<blockquote>
<p>Schema [计]模式，范式n.</p>
</blockquote>
<blockquote>
<p>Scheme 计划n.</p>
</blockquote>
<blockquote>
<p>Suffix 后缀，下标n.</p>
</blockquote>
<blockquote>
<p>Mechanism 机制，原理n.</p>
</blockquote>
<blockquote>
<p>Facet 面，方面n.</p>
</blockquote>
<blockquote>
<p>Validation 确认，批准，生效n.</p>
</blockquote>
<blockquote>
<p>Duplicate 复制v.</p>
</blockquote>
<blockquote>
<p>Invalid 无效的adj.</p>
</blockquote>
<blockquote>
<p>Submission 投降，提交n.</p>
</blockquote>
<blockquote>
<p>Alias 别名n.</p>
</blockquote>
<blockquote>
<p>Argument 参数n.</p>
</blockquote>
<blockquote>
<p>Requirements 需求，要求n.</p>
</blockquote>
<blockquote>
<p>Neglect 疏忽，忽视vt.</p>
</blockquote>
<blockquote>
<p>Term 术语n.</p>
</blockquote>
<blockquote>
<p>Allocate 分配vt.</p>
</blockquote>
<blockquote>
<p>Validate 验证，确认（表现为一般的检查）vt.</p>
</blockquote>
<blockquote>
<p>Compile 编译vt.</p>
</blockquote>
<blockquote>
<p>Verify 核实，查证（表现为要付出一段程序化的核实过程）vt.</p>
</blockquote>
<blockquote>
<p>Repository 仓库，资源库，版本库n.</p>
</blockquote>
<blockquote>
<p>Plugins 插件，外挂n.</p>
</blockquote>
<blockquote>
<p>Procedure [计算机]过程 n.</p>
</blockquote>
<blockquote>
<p>Retain 保持vt.</p>
</blockquote>
<blockquote>
<p>Clause 从句 n.</p>
</blockquote>
<blockquote>
<p>Via 通过 n.f</p>
</blockquote>
<blockquote>
<p>Along with 连同，以及，和……一起</p>
</blockquote>
<blockquote>
<p>Excluding 除……之外，不包括 prep.</p>
</blockquote>
<blockquote>
<p>Standalone 单独的，独立的adj.</p>
</blockquote>
<blockquote>
<p>Cluster 集群，簇n.</p>
</blockquote>
<blockquote>
<p>Aggregation 集成，聚集n.</p>
</blockquote>
<blockquote>
<p>Excerpt 摘录，摘要n.</p>
</blockquote>
<blockquote>
<p>Integration 整合，集成n.</p>
</blockquote>
<blockquote>
<p>Expectation 期待，盼望n.</p>
</blockquote>
<blockquote>
<p>Composite 合成的adj. 使合成vt.</p>
</blockquote>
<blockquote>
<p>Interaction 相互作用，相互影响n.</p>
</blockquote>
<blockquote>
<p>Doubt 怀疑，不信n.vt.</p>
</blockquote>
<blockquote>
<p>Field 字段，域n.</p>
</blockquote>
<blockquote>
<p>Intermediate 起媒介作用vi. 中间的adj. 媒介n.</p>
</blockquote>
<blockquote>
<p>Authorization 授权，认可n.</p>
</blockquote>
<blockquote>
<p>Demarcation 界限，划分n.</p>
</blockquote>
<blockquote>
<p>Conscious 意识到的adj.</p>
</blockquote>
<blockquote>
<p>Retrieve 检索vt.</p>
</blockquote>
<blockquote>
<p>Traverse 穿过，横越；[计]遍历vt.</p>
</blockquote>
<blockquote>
<p>Breadth 宽度，广度n.</p>
</blockquote>
<blockquote>
<p>Breadth First广度优先n.</p>
</blockquote>
<blockquote>
<p>Evaluate 评价，评估vt.</p>
</blockquote>
<blockquote>
<p>Perform 执行，机器运转，表演vt.</p>
</blockquote>
<blockquote>
<p>Depth 深度n.</p>
</blockquote>
<blockquote>
<p>Instantiate 实例化vt.</p>
</blockquote>
<blockquote>
<p>Custom 习惯，惯例，风俗n.</p>
</blockquote>
<blockquote>
<p>In this case 在这种情况下，在这个案例中</p>
</blockquote>
<blockquote>
<p>Descent 下降n.</p>
</blockquote>
<blockquote>
<p>Descendant 子孙，下降</p>
</blockquote>
<blockquote>
<p>Mutable 可变的，不定的adj.</p>
</blockquote>
<blockquote>
<p>Immutable 不可变的adj.</p>
</blockquote>
<blockquote>
<p>Expand 扩张，使膨胀vt.</p>
</blockquote>
<blockquote>
<p>In term of 根据</p>
</blockquote>
<blockquote>
<p>Explanation 说明，解释n.</p>
</blockquote>
<blockquote>
<p>Regardless of 不管，不顾</p>
</blockquote>
<blockquote>
<p>Latter 后者n.</p>
</blockquote>
<blockquote>
<p>Prune 剪枝n.</p>
</blockquote>
<blockquote>
<p>Fluent 流动的adj.</p>
</blockquote>
<blockquote>
<p>Manual 手工的，手动的adj.</p>
</blockquote>
<blockquote>
<p>Notification 通知，通告n.</p>
</blockquote>
<blockquote>
<p>Entity 实体n.</p>
</blockquote>
<blockquote>
<p>Whereas 然而，反之n.</p>
</blockquote>
<blockquote>
<p>In case 万一</p>
</blockquote>
<blockquote>
<p>Persist 坚持，固执vi.</p>
</blockquote>
<blockquote>
<p>Snapshot 快照n.</p>
</blockquote>
<blockquote>
<p>Assert 断言n.</p>
</blockquote>
<blockquote>
<p>Quote 引号n.</p>
</blockquote>
<blockquote>
<p>Coroutine 协同程序n.</p>
</blockquote>
<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>词汇</category>
      </categories>
  </entry>
  <entry>
    <title>20. nio类库：BIO、NIO、AIO三种Java I/O模型的实现原理和区别</title>
    <url>/2023/06/12/xzg-program-beauty-20/</url>
    <content><![CDATA[<p>这篇文章和<a href="#">Post not found: xzg-program-beauty-20-1 图解I/O多路复用</a>一起读</p>
<p>Java中的I/O类库除了java.io之外，还包括java.nio。既然已经有了java.io了，为什么还要再开发一个新的java.nio呢？java.nio跟java.io有何区别？在平时的开发中，什么时候使用java.io？什么时候使用java.nio？面试中常被问到的BIO、NIO、AIO又是什么东西？带着这些问题，我们来学习本节的内容：java.nio。</p>
<h2 id="一、java-nio类库"><a href="#一、java-nio类库" class="headerlink" title="一、java.nio类库"></a>一、java.nio类库</h2><p>java.nio类库在JDK1.4中引入，nio的全称为New I/O，不过，因为其相对于java.io来说，对I/O提供了非阻塞的访问方式（这个待会再讲），所以，很多人也把nio解读为Non-blocking I/O。除此之外，尽管从功能上java.nio可以完全替代java.io，但在平时的开发中，对于普通的文件读写，我们更倾向于使用简单的java.io，<strong>java.nio发挥作用的场合更多的是网络编程。</strong>所以，还有人把nio解读为Network I/O。</p>
<p>上一节中讲到，在java.io中，Stream是一个核心的概念，所有的I/O都抽象为Stream，读写Stream就等同于读写I/O。<strong>在java.nio中，已经没有了Stream，转而引入了Channel。Channel类似Stream，也是对I/O的抽象。除此之外，java.nio还引入了一个新的概念：Buffer，用来存储待写入或读取的数据。</strong></p>
<p>我们先拿一个比较简单的文件读写的例子，来看一下Channel和Buffer是如何使用的，让你对java.nio有个最初步的直观的认识。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>));</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">while</span> (channel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理buffer中的数据data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>除了上面提到的Buffer、Channel之外，java.nio中还有两个重要的概念：Selector和AsynchronousChannel，接下来，我们就详细介绍一下java.nio中的这4个核心概念。</p>
<h4 id="1）Buffer"><a href="#1）Buffer" class="headerlink" title="1）Buffer"></a>1）Buffer</h4><p>Buffer本质上就是一块内存，就相当于在使用java.io编程时申请的byte数组。常用到Buffer有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、MappedByteBuffer。这些Buffer的不同之处在于：解析数据的方式不同，比如CharBuffer按照字符来解析数据，有点类似java.io中的字符流。</p>
<p>上一节我们讲到，java.io的设计有诸多问题，而java.nio的设计要优于java.io。上一节讲到，java.io分别为字符流和字节流设计了不同的类库，在代码实现上有些重复，毕竟I/O读写操作都是相同的，唯一的区别只是数据的解析方式不同。字节流类按照字节解析数据。字符流类按照字符解析数据。java.nio将解析这部分功能抽取出来，独立到Buffer类中。不同的Channel跟不同的Buffer组合在一起，可以实现不同的IO读写需求。比如，将FileChannel跟ByteBuffer组合起来，就相当于java.io中的文件字节流类（FileInputStream、FileOutputStream），将FileChannel跟CharBuffer组合起来，就相当于java.io中的文件字符流类（FileReader、FileWriter）。</p>
<p>实际上，Channel和Buffer独立开发，组合起来使用，这种设计思路应用的就是面向对象中“组合优于继承”的设计思想，通过组合来替代继承，避免了继承带来的组合爆炸问题。正因如此，实现相同甚至更多功能的情况下，java.nio中的类的个数却比java.io中的类的个数少。关于“组合优于继承”这一设计思想的详细介绍，你可以阅读我的《设计模式之美》这本书。</p>
<h4 id="2）Channel"><a href="#2）Channel" class="headerlink" title="2）Channel"></a>2）Channel</h4><p>常用的Channel有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel用于文件读写。DatagramChannel、SocketChannel、ServerSocketChannel用于网络编程。DatagramChannel用来读写UDP数据，SocketChannel和ServerSocketChannel用来读写TCP数据。<strong>SocketChannel和ServerSocketChannel的区别在于，ServerSocketChannel用于服务器编程，可以使用accept()函数监听客户端（SocketChannel）的连接请求。</strong></p>
<p>java.nio中的Channel既可以读，也可以写，而java.io中的Stream要么只能读，要么只能写，这也是java.nio比java.io类少的另一个重要原因。除此之外，Channel的设计也利用了“组合优于继承”的设计思想。 java.nio中包含大量的Channel接口，每个接口定义了一种功能。每个Channel类通过实现不同的接口组合，来支持不同的功能组合。如下图所示。其中，FileChannel实现了3个接口，支持3种不同的功能。<br><img src="/2023/06/12/xzg-program-beauty-20/1.png" alt="java.nio.png"></p>
<p><strong>Channel有两种运行模式：阻塞模式和非阻塞模式。</strong>其中，FileChannel只支持阻塞模式。DatagramChannel、SocketChannel、ServerSocketChannel支持阻塞和非阻塞两种模式，默认为阻塞模式。我们可以调用configureBlocking(false)函数将其设置为非阻塞模式。<strong>非阻塞Channel一般会配合Selector，用于实现多路复用I/O模型。</strong></p>
<p>那么，到底什么是阻塞模式？什么是非阻塞模式呢？</p>
<p><strong>线程在调用read()或write()函数对I/O进行读写时，如果I/O不可读或者不可写（待会解释这两个的意思），那么，在阻塞模式下，read()或write()函数会等待，直到读取到数据或者写入完成时才会返回，在非阻塞模式下，read()或write()函数会直接返回，并报告读取或写入未成功。</strong></p>
<p>上一节，我们提到，<strong>在操作系统层面，主要的I/O有：文件、网络、标准输入输出、管道。文件是没有非阻塞模式的。毕竟文件不存在不可读和不可写的情况。网络、标准输入输出、管道都存在阻塞和非阻塞两种模式。</strong>我们拿最常用的网络来举例。</p>
<p><strong>一般来讲，应用程序调用read()或write()函数读取或写入数据，数据会在应用程序缓冲区、内核缓冲区、I/O设备这三者之间拷贝传递。</strong>如下图所示。关于这点，我们下一节详细介绍。<br><img src="/2023/06/12/xzg-program-beauty-20/2.png" alt="copy.png"></p>
<p><strong>当调用read()函数时，如果内核读缓冲区中没有数据可读，比如网络连接的对方此时并未发送数据过来，那么，在阻塞模式下，read()函数会等待，直到对方发送数据过来，内核读缓冲区中有数据可读时，才会将内核读缓冲区中的数据拷贝到应用程序缓存中，然后read()函数才返回，在非阻塞模式下，read()函数会直接返回，并报告读取情况。</strong></p>
<p><strong>当调用write()函数时，如果内核写缓冲区中没有足够空间承载应用程序缓存中的数据，比如网络不好，原来的数据还没来得及发送出去，那么，在阻塞模式下，write()函数会等待，直到内核写缓冲区中有足够空间，应用程序缓冲区中的数据全部写入内核写缓冲区，write()函数才会返回。在非阻塞模式下，write()函数会能写多少写多少，即便还有一部分未能写入内核写缓冲区，也不会等待，直接返回，并报告写入情况。</strong></p>
<p><strong>实际上，除了read()和write()函数有阻塞和非阻塞这两种模式之外，ServerSocketChannel中用于服务器接收客户端的连接的accpet()函数，也有阻塞和非阻塞两种模式。在阻塞模式下，调用accept()函数会等待，直到有客户端连接到来才返回。在非阻塞模式下，调用accept()函数，如果没有客户端连接到来，会直接返回。</strong></p>
<h4 id="3）Selector"><a href="#3）Selector" class="headerlink" title="3）Selector"></a>3）Selector</h4><p>在网络编程中，使用非阻塞模式，线程需要通过while循环，不停轮询调用read()、write()、accept()函数，查看是否有数据可读、是否可写、是否有客户端连接到来。如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">SocketChannel clientChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (clientChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">  clientChannel = serverChannel.accept();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (clientChannel.read(buffer) == -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">buffer.flip(); <span class="comment">//将buffer从&quot;用于读&quot;变成&quot;用于写&quot;</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">  clientChannel.write(buffer); <span class="comment">// echo,读了啥就写啥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码充斥着while轮询，显然不够优雅。多路复用I/O模型便用来解决这个问题。</p>
<p><strong>多路复用I/O模型是网络编程中非常经典的一种I/O模型。为了实现多路复用I/O模型，Unix提供了epoll库，Windows提供了iocp库，BSD提供了kequeue库…Java作为一种跨平台语言，对不同操作系统的实现方式进行了封装，提供了统一的Selector。</strong></p>
<p><strong>我们可以将需要监听的Channel，调用register()函数，注册到Selector中。Selector底层会通过轮询的方式，查看哪些Channel可读、可写、可连接等，并将其返回处理。</strong>关于Selector的使用示例代码，我们在接下来的「Java I/O模型」小节中给出。</p>
<h4 id="4）异步Channel"><a href="#4）异步Channel" class="headerlink" title="4）异步Channel"></a>4）异步Channel</h4><p>尽管使用Selector可以避免程序员自己手写轮询代码，但是Selector底层仍然依赖轮询来实现。在JDK7中，java.nio类库做了升级，引入了支持异步模式的Channel，主要包括：AsynchronousFileChannel、AsynchronousSocketChannel、AsynchronousServerSocketChannel。而前面讲到的Channel都是同步模式的。</p>
<blockquote>
<p>那么，什么是同步模式？什么是异步模式呢？同步和异步这两个概念，跟阻塞和非阻塞又是否有联系呢？我们通过一个生活中的例子来给你形象解释一下。<br>假设你去一家餐厅就餐，因为就餐的人太多，需要取号等位。取号之后，如果你站在餐厅门口一直等待被叫号，啥都不干，那么，这就是阻塞模式。如果你先去商场里逛一逛，一会回来看一下有没有轮到你，没有就继续再去逛，那么，这就是非阻塞模式。<br>如果你在取号时，登记了手机号码，那么你就可以放心去逛商场了，等叫到你的号时，服务员会打电话通知你，这就是异步模式。相反，如果需要自己去查看有没有轮到你，不管是阻塞模式还是非阻塞模式，都是同步模式。<br>实际上，异步模式下也可以有阻塞和非阻塞之分。如果在没有收到通知时，尽管你可以去干其他事情，但你偏偏就啥都不干，就站在门口等着被叫号，那么这就是阻塞异步模式，如果你选择享受通知服务，去干其他事情，那么这就是非阻塞异步模式。</p>
</blockquote>
<p>从上面的解释，我们可以发现，同步、异步跟阻塞、非阻塞没有直接关系。</p>
<p><strong>在异步模式下，Channel不再注册到Selector，而是注册到操作系统内核中，由内核来通知某个Channel可读、可写或可连接，java.nio收到通知之后，为了不阻塞主线程，会使用线程池去执行事先注册的回调函数。</strong>关于异步模式的用法，我们也是在「Java I/O模型」小节中展示。</p>
<h4 id="二、Java-IO模型"><a href="#二、Java-IO模型" class="headerlink" title="二、Java IO模型"></a>二、Java IO模型</h4><p><strong>在面试和工作中，我们经常听到“I/O模型”这个概念。I/O模型一般用于网络编程中，所以，“I/O模型”的全称是“网络I/O模型”。</strong>除此之外，I/O模型多数都用来指导服务器开发。相比服务器开发，客户端开发不需要处理多个并发连接的情况，往往会简单一些，也就不需要这些复杂的模型。</p>
<p>Java中常被提及的I/O模型有三个：阻塞I/O模型（BIO）、非阻塞I/O模型（NIO）、异步I/O模型（AIO）。我们依次看下这3种常见的I/O模型。</p>
<h4 id="1）阻塞I-O模型（BIO）"><a href="#1）阻塞I-O模型（BIO）" class="headerlink" title="1）阻塞I/O模型（BIO）"></a>1）阻塞I/O模型（BIO）</h4><p>前面讲过，I/O访问模式有两种：阻塞模式和非阻塞模式。阻塞I/O模型指的是利用阻塞模式来实现服务器。一般来说，这种模型需要配合多线程来实现。</p>
<p>一般来讲，服务器需要连接大量客户端，因为read()函数是阻塞函数，所以，为了实时接收客户端发来的数据，服务器需要创建大量线程，每个线程负责等待读取（调用read()函数）一个客户端的数据。因为java.io支持阻塞模式，java.nio既支持阻塞模式又支持非阻塞模式，所以，java.io和java.nio都可以实现阻塞I/O模型。我们使用java.io来编写示例代码，如下所示。注意，使用java.io进行网络编程，需要配合java.net类库。比如在下面代码中，Socket、ServerSocket都是java.net包中的类。java.net类库用于管理连接，java.io用于读写数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">    serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// accept()为阻塞函数，直到有连接到来才返回</span></span><br><span class="line">      Socket clientSocket = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 为了每个客户端单独创建一个线程处理</span></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientHandler(clientSocket)).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//持续接收客户端发来的数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// read()为阻塞函数，直到读取到数据再返回</span></span><br><span class="line">          socket.getInputStream().read(data);</span><br><span class="line">          <span class="comment">// write()为阻塞函数，全部写完成才会返回</span></span><br><span class="line">          socket.getOutputStream().write(data); <span class="comment">//echo</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// log and exit</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数。除此之外，因为accept()函数也是阻塞函数，所以也独占一个线程。当连接的客户端非常多时，服务器需要创建大量线程，而每个线程会分配一个线程栈，需要占用一定的内存空间。当线程比较多时，内存资源的消耗就会比较大。大量线程来回切换，也会导致服务器整体处理性能的下降。除此之外，大部分线程可能都阻塞在read()函数上，等待数据的到来，什么都不做但又要白白占用内存和线程资源，非常浪费。</strong></p>
<h4 id="2）非阻塞I-O模型（NIO）"><a href="#2）非阻塞I-O模型（NIO）" class="headerlink" title="2）非阻塞I/O模型（NIO）"></a>2）非阻塞I/O模型（NIO）</h4><p><strong>非阻塞I/O模型指的是利用非阻塞模式来开发服务器，一般需要配合Selector多路复用器，所以，这种模型也叫做多路复用I/O模型。</strong>不过，这两种叫法都有点以偏概全，所以，你不必太纠结于名称，知道这种模型具体是如何实现的即可。</p>
<p>因为java.io只支持阻塞模式，所以，这种模型只能通过java.nio来实现。非阻塞I/O模型的示例代码如下所示。利用java.nio进行网络编程，也像java.io那样，需要java.net类库的配合，比如代码中的InetSocketAddress就是java.net中的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Selector</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create serverChannel and register to selector</span></span><br><span class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">    serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> channelCount = selector.select();</span><br><span class="line">      <span class="keyword">if</span> (channelCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iterator.next();</span><br><span class="line">          <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// create clientChannel and register to selector</span></span><br><span class="line">            SocketChannel clientChannel = serverChannel.accept();</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">            clientChannel.read(buffer);</span><br><span class="line">            buffer.flip(); <span class="comment">//从&quot;用于读&quot;变为&quot;用于写&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.hasRemaining()) &#123; <span class="comment">//也可以注册到selector中</span></span><br><span class="line">              clientChannel.write(buffer); <span class="comment">//echo</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear(); <span class="comment">//重复利用</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>在NioEchoServer类中，如果有n个客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作。</strong></p>
<p>如上代码所示，大部分情况下，我们都不需要监听Channel是否可写，毕竟网络写入跟文件写入类似，大部分情况下都不需要等待。只有当写入出现问题时，比如write()函数返回0，表示网络拥塞，此时才需要如下代码所示，将Channel注册到Selector中，等待可写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clientChannel.register(selector, SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，并不是所有的Channel都可以注册到Selector中被监听，只有实现了SelectableChannel接口的Channel才可以，比如DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel因为没有实现SelectableChannel，并且不支持非阻塞模式，所以，无法被Selector监听。</p>
<p><em><strong>多路复用I/O模型只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。不过，这种模型依然存在问题。如果某些clientChannel读写的数据量比较大，或者逻辑操作比较复杂，耗时比较久，因为所有的工作都在一个线程中完成，那么其他clientChannel便迟迟得不到处理，最终的效果就是，服务器响应客户端的延迟很大。</strong></em></p>
<p><strong>为了解决这个问题，我们可以引入线程池，对于Selector检测到有数据可读的clientChannel，我们从线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。我们知道，阻塞I/O模型也用到了多线程，跟这里的区别在于，不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高。</strong></p>
<h4 id="3）异步I-O模型（AIO）"><a href="#3）异步I-O模型（AIO）" class="headerlink" title="3）异步I/O模型（AIO）"></a>3）异步I/O模型（AIO）</h4><p>实际上，上述问题使用java.nio的异步Channel实现起来更加优雅。如下代码所示。通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">    serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    <span class="comment">// 异步accept()</span></span><br><span class="line">    serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptCompletionHandler(serverChannel));</span><br><span class="line">    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptCompletionHandler</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptCompletionHandler</span><span class="params">(AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.serverChannel = serverChannel; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel clientChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// in order to accept other client&#x27;s connections</span></span><br><span class="line">      serverChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 异步read()</span></span><br><span class="line">      clientChannel.read(buffer, buffer, <span class="keyword">new</span> ReadCompletionHandler(clientChannel)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// log exc exception</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCompletionHandler</span> </span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCompletionHandler</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clientChannel = clientChannel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">      buffer.flip();</span><br><span class="line">      <span class="comment">// 异步write()。回调函数为null，写入完成就不用回调了</span></span><br><span class="line">      clientChannel.write(buffer, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// echo</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// log exc exception</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实际上，<strong>在平时的开发中，我们一般不会直接使用底层的java.nio类库，而是使用Netty等框架来进行网络编程，这些框架封装了网络编程的复杂性，使用起来更加简单，开发效率更高。</strong>除了以上三种常见的I/O模型之外，实际上，还有更多更加复杂的I/O模型，比如<strong>Netty框架提供的Reactor模型。</strong>关于Netty等网络编程知识，我们就不深入讲解了。毕竟专栏的重点不在这里。</p>
<p>你可能还听过其他I/O模型的分类，比如在《Unix网络编程》一书中，介绍了Unix操作系统的5种I/O模型：阻塞I/O模型、非阻塞I/O模型、多路复用I/O模型、信号驱动I/O模型、异步I/O模型。那么，Unix操作系统下的I/O模型跟Java I/O模型有什么联系呢？</p>
<p><strong>实际上，不同的操作系统会提供不同的I/O模型。Java是一种跨平台语言，为了屏蔽各个操作系统I/O模型的差异，设计了3种新的I/O模型：BIO（阻塞I/O）、NIO（非阻塞I/O）、AIO（异步I/O），并且提供了I/O类库来支持这3种I/O模型的代码实现。而Java的I/O类库底层需要依赖操作系统的I/O接口（专业名称为系统调用）来实现，因此，从本质上来讲，Java I/O模型只是对操作系统I/O模型的重新封装。</strong></p>
<h2 id="三、对比java-io与java-nio"><a href="#三、对比java-io与java-nio" class="headerlink" title="三、对比java.io与java.nio"></a>三、对比java.io与java.nio</h2><p>在功能上来看，java.nio完全可以替代java.io，那么，在平时开发中，我们是不是应该首选java.nio呢？在新开发的项目中，是不是就不应该使用老的java.io呢？</p>
<p>实际上，在某些情况下，我们确实必须使用java.nio，比如网络编程。尽管使用java.io，并配合java.net，也可以进行网络编程，但java.io只支持阻塞模式，只能实现阻塞I/O模型，对于大部分网络编程来说，都是不够的。而java.nio提供了非阻塞模式、Selector多路复用器、异步模式，能够实现更加高性能的网络模型，比如非阻塞I/O模型、异步I/O模型。相比java.io而言，在网络编程方面，java.nio的优势更加明显。</p>
<p>但是，在某些情况下，到底使用java.io还是java.nio，会有一些争论，比如文件读写。前面提到，文件读写只支持阻塞模式，因此，使用java.io或java.nio都可以。有些人认为，使用java.io进行文件读写，代码编写更加简单。有些人则认为，java.nio的文件读写功能更加丰富。我个人认为，既然有争论，就说明两者没有哪个更有绝对优势，不然也就不会有争论了。因此，对于使用java.io还是java.nio进行文件读写，按照你的喜好或者团队的编程习惯来选择就好。</p>
<p><strong>总结一下的话，对于网络编程，我们首选java.nio，对于文件读写，java.io和java.nio都可以。</strong></p>
<p>四、课后思考题<br>java.io提供了BufferedInputStream、BufferedOutputStream，用于支持缓存的文件读写，那么，类似功能，java.nio是如何实现的呢？</p>
]]></content>
      <categories>
        <category>编程之美（王争）</category>
      </categories>
  </entry>
  <entry>
    <title>青年人，请珍惜你们的迷惘</title>
    <url>/2023/04/16/young-confusion/</url>
    <content><![CDATA[<p>人一辈子，最难忘的其实只有两个阶段，一个是童年，一个是青春期。对于大多数人来说，其他的时光简直就像嚼过了的甘蔗渣，淡而无味，而且一年一年地越过越觉得过得快。所以历来就有人认为，青年时代以后的日子都不必过了。</p>
<p>马其顿的亚历山大大帝于33岁时死于征战途中，被黑格尔称为“一幅最美的景象”，因为 “要使他永远以一个青年出现于后世人眼前，他就不得不在年纪轻轻的时候早死”。</p>
<p>我国“五四”时期的“新青年”则有人提出，人过40都该杀。这都是当一个社会处于青年时代所流行的议论，生于这样一个时代的年轻人是最幸运的，因为只有他们最有作为。</p>
<p>但一个社会不可能永远处于青春期，而是要么走向成熟，要么迅速老化。所以，在人类历史上的大部分时间里，青年人的常态就是处于动摇和迷惘之中，他们常常羡慕前人年纪轻轻就干出了丰功伟绩，震撼了世界，而自己身处一个普遍平庸的时代，不要说没有建功立业的条件和机遇，就连一个站得住脚的理想都失去了。</p>
<p>不过，尽管今天有不少青年看起来比老年人更老于世故，但青年之所以是青年，正在于他们并不满足于自己和自己时代的现状，在内心中有一番挣扎和探索，想要参透人生的意义。</p>
<p>青春的迷惘，其实正是对人生意义的迷惘，对自己“从何处来、向何处去”的迷惘。以前看过一本苏联小说叫《你到底要什么》，讲的是苏联“解冻”后的 60年代青年寻欢作乐之余的怅然若失心态。</p>
<p><strong>记得当时我还在农村当知青，几乎所有同龄人考虑的都是“我将会成为什么”，却极少有人考虑“我到底要什么”。是啊，我将会成为什么自然会成为什么，可是我到底要什么呢？这个问题不搞清，我将成为的那个“什么”很可能是我根本不想“要”的，到那时如果我再明白自己真正要什么，那就晚了。</strong></p>
<p>当时眼前的确是一片漆黑。这不仅是指对我这种“出身不好”的青年来说，招工和“工农兵推荐”上大学绝无希望，只能打算一辈子务农；而且更重要的是，没有任何人能够给我指一条精神上的出路。现行的一切理论、宣传、口号和指示都成了明显的骗局，我渴望找到一位老师、兄长或父辈，能够在做人和思想方面给我立一个榜样，或提出一些有益的忠告。</p>
<p>但我最终是绝望了。我终于明白了，除了靠自己，谁也不能帮我。那时，未来在我心中完全是一个未知数，整个国家的命运同样如此。我在迷惘中奋起，在迷惘中读书学习，在迷惘中探求人生的意义和国家的前途。</p>
<p>经常会有一种空虚感和底气不足的怅惘向我袭来，其中交织着朦胧的战栗、神秘的预感、暗暗的焦虑和莫名其妙的恐慌。但它并没有将我击倒，而是迫使我带着深深的忧郁和伤感，游向知识的大海。</p>
<p>今天想来，我要感谢青春的迷惘，虽然当时感到自己像掉进了无底的深渊。我怀念自己的青春时代，主要就是怀念这种迷惘的心情。</p>
<p>的确，正是在40岁上（“不惑”之年或“该杀”之年），我开始不再迷惘了，而代之以一种紧迫感。经历了考研、读研、留校任教的一连串“时来运转”之后，那一年我突然发现，人生苦短，我这一生要做的事恐怕是永远也做不完了，所以要赶紧做，现在就做。</p>
<p>我放下了一切爱好，一切郊游的机会，除了讲课之外就是埋头于书斋，抓紧一切时间，拼命追赶着某颗遥远的命运之星，经常梦见自己误了火车。<br>我终于知道自己“到底要什么”了：<strong>我要搞清一切真相，历史的真相，社会的真相，人类的真相，人性的真相，最终是自己的真相。</strong>人生中充满了欺骗、自欺和虚伪，我不愿意度过一个虚假的人生。</p>
<p>当然，完全搞清真相是不可能的，否则人就成上帝了。但我认定人的生命之不同于动物，就在于他有这一点灵明，或者说神性，他类似于上帝。最近十多年来，我的生活过得平静而无纷扰，与我青年时代的动荡不安形成鲜明的对比，所以，从自己的时间感觉上来说，这十几年过得简直就像只有三个月。</p>
<p>但我感到自豪的是，我没有虚度光阴，我把我的一生都凝聚在我青年时代所选定的一点上了，为此我要再次感谢当年的青春的迷惘。</p>
<p>每个人的青春都是不同的，他的选择自然也与别人不同，这一点在今天这个多元化的时代更是如此。但很可能，世世代代的奋发有为的年轻人对自己的青春会有共同的或类似的感受，他们所体验到的青春的迷惘并不是特殊的风景，而是人性结构中的一个必要的层次：</p>
<p>它带给人生以痛苦，但同时也为人生积聚着力量。</p>
<p>青年时代的迷惘，“是人性结构中一个必要的层次”。</p>
<p>有迷惘，也有觉醒；有探索，也有前行。</p>
<p>青年节是为纪念百年之前那个时代里一场浩大的前行和抗争而设立的节日。</p>
<p>在这个节日，我们纪念一百年前的先贤。</p>
<p>他们为真理苦苦求索，他们为心中对真理的信念一往无前。</p>
<p>“<strong>愿中国青年都摆脱冷气，只是向上走，不必听自暴自弃者流的话。</strong>能做事的做事，能发声的发声。有一分热，发一分光，就令萤火一般，也可以在黑暗里发一点光，不必等候炬火。</p>
<p>此后如竟没有炬火：我便是唯一的光。”</p>
<p>文/邓晓芒</p>
]]></content>
      <categories>
        <category>Thought</category>
      </categories>
  </entry>
  <entry>
    <title>24.反射：为什么通过反射创建对象要比new创建对象慢</title>
    <url>/2023/06/11/xzg-program-beauty-24/</url>
    <content><![CDATA[<p>尽管在平时的业务开发中，我们很少会用到反射、注解、动态代理这些比较高级的Java语法，但是，在框架开发中，它们却非常常用，可以说是支撑框架开发的核心技术。比如，我们常用的Spring框架，其中的IOC就是基于反射实现的，AOP就是基于动态代理实现的，配置就是基于注解实现的。<br>尽管在业务开发中，我们不常用到它们，但是，要想<br>阅读开源框架的源码，掌握这些技术是必不可少的。接下来，我们就来讲讲反射、注解、动态代理。本节我们重点讲下反射。</p>
<h2 id="一、反射的作用"><a href="#一、反射的作用" class="headerlink" title="一、反射的作用"></a>一、反射的作用</h2><p>反射的作用主要有3个：创建对象、执行方法、获取类信息。</p>
<h4 id="1）创建对象"><a href="#1）创建对象" class="headerlink" title="1）创建对象"></a>1）创建对象</h4><p>在编写代码的时候，我们通过new语句用来创建对象。代码中有多少条new语句，JVM就会创建多少个对象。但是，并不是所有的对象的创建，都是在编写代码时事先知道的。如果在代码的运行过程中，我们需要根据配置、输入、执行结果等，动态创建一些额外的对象，这个时候我们无法使用new语句了。<strong>我们需要有一种新的方法，在程序运行期间，动态地告知JVM去创建某个类的对象。这种方法就是反射。</strong><br>不管是new还是反射，对象的创建都是在运行时进行的，不过申请创建对象的时机却是不同的。通过new来创建对象，其创建对象的需求是在代码编写时确定的，<strong>而通过反射来创建对象，其创建对象的需求是在运行时是确定的。</strong>因此，我们把通过new语句的方式来创建对象叫做静态申请对象创建，我们把通过反射的方式来创建对象叫做动态申请对象创建。</p>
<h4 id="2）执行方法"><a href="#2）执行方法" class="headerlink" title="2）执行方法"></a>2）执行方法</h4><p><strong>除了在程序运行期间动态申请对象创建之外，程序还可以动态申请执行方法。跟创建对象类似，尽管执行方法总是发生在运行时，但是申请执行方法的时机却可以不同</strong>。一般来讲，程序会执行哪些方法，在代码编写时就确定了。但是，如果在运行时，额外申请新的要执行的方法，这个时候，就只能依靠反射来实现了。稍后讲到的动态代理，实际上，就是依赖反射可以动态执行方法来实现的。<br><strong>不管是反射创建对象，还是执行方法，实际上，跟普通的对象创建和方法执行，本质上没有太大区别。只不过是告知JVM的时机和方式不同而已。</strong></p>
<h4 id="3）获取类信息"><a href="#3）获取类信息" class="headerlink" title="3）获取类信息"></a>3）获取类信息</h4><p>除了创建对象、执行方法之外，反射还能够获取对象的类信息，包括类中的构造函数、方法、成员变量等信息。稍后要讲到的注解，实际上，就是依赖反射的这个作用。</p>
<h2 id="二、反射的用法"><a href="#二、反射的用法" class="headerlink" title="二、反射的用法"></a>二、反射的用法</h2><p>实现上述反射的这3个作用需要4个类：Class、Method、Constructor、Field，这也是反射所涉及的核心类，接下来，我们依次来介绍一下这4个类。</p>
<h4 id="1）Class"><a href="#1）Class" class="headerlink" title="1）Class"></a>1）Class</h4><p>Class跟关键字class容易混淆，Class实际上跟Person、String等一样，也是一个类，只是其比较特殊，存储的是类的信息。<br>Class类提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等。我们将重要的常用到方法罗列如下，当然，你也可以查看java.lang.Class源码来了解更多细节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取类信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)；</span><br><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSimpleName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取package信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">getPackage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取接口信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt;[] <span class="title">getInterfaces</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员的变量，包含私有成员变量，不包含父类成员变量</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量，只包含公有成员变量，包含父类成员变量</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的方法，包括私有方法，不包含父类方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的方法，只包含公有方法，包含父类方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数，只包含公共构造函数</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getConstructors();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数，包含私有构造函数</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类上的注解</span></span><br><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations();</span><br></pre></td></tr></table></figure>

<p>除了获取类信息的方法之外，Class类还提供了方法来创建对象，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般来讲，我们有以下3种方式来创建Class类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：使用forName()+类名全称</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Student&quot;</span>);</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">Class&lt;?&gt; clazz = Student.class;</span><br><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">Class&lt;?&gt; clazz = student.getClass();</span><br></pre></td></tr></table></figure>

<p>从上述代码，我们可以发现，<strong>实际上，Class类是一个<code>泛型类</code>。如果我们无法提前知道获取的类的信息是哪个类的，那么我们就可以使用<code>?</code>通配符来具体化泛型类。如果我们可以明确获取的是哪个类的信息，那么我们可以直接使用具体类型具体化泛型类。</strong>不过，方法一、方法三并不能像下面这样具体化Class类，因为forName()函数和getClass()函数在函数定义中的返回值本来就是Class<?>，Class<?>类型的返回值不能赋值给<code>Class&lt;Student&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不正确的使用方法</span></span><br><span class="line">Class&lt;Student&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Student&quot;</span>);</span><br><span class="line">Class&lt;Student&gt; clazz = student.getClass(); </span><br></pre></td></tr></table></figure>

<h4 id="2）Constructor"><a href="#2）Constructor" class="headerlink" title="2）Constructor"></a>2）Constructor</h4><p>Constructor用来存储构造函数的信息。如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数所包含的信息</span></span><br><span class="line"><span class="comment">// 在Constructor中，以下信息都有相应的方法来获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          exceptionTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String    signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConstructorRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              parameterAnnotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Constructor类也提供了一些方法来获取以上信息，这里我们就不一一列举了，你可以查看java.lang.reflect.Constructor类源码去自行了解。这里介绍一下Constructor类中常用的newInstance()方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过newInstance()方法，我们可以调用构造函数来创建对象。你应该也已经注意到，Class类中也包含newInstance()方法。区别在于，Class类上的newInstance()方法只能通过无参构造函数来创建对象，如果想要使用有参构造函数创建对象，我们需要先获取对应的Constructor类对象，然后再调用其上的newInstance()方法。稍后会有代码示例。</p>
<h4 id="3）Method"><a href="#3）Method" class="headerlink" title="3）Method"></a>3）Method</h4><p>Method存储的是方法的信息。如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="comment">// This is guaranteed to be interned by the VM in the 1.4</span></span><br><span class="line">    <span class="comment">// reflection implementation</span></span><br><span class="line">    <span class="keyword">private</span> String              name;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            returnType;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          exceptionTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String              signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> MethodRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              parameterAnnotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotationDefault;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，Method类也提供了大量方法来获取以上信息，这里我们也不一一罗列了。感兴趣的话，你可以查看java.lang.reflect.Method类的源码。这里我们介绍一下常用的invoke()方法，如下所示，调用此方法可以执行对应方法。稍后会有代码示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4）Field"><a href="#4）Field" class="headerlink" title="4）Field"></a>4）Field</h4><p>Filed用来存储成员变量的信息，如下所示。同样，<br>Field类也提供了大量方法来获取以下信息，这里我们也不一一罗列了。感兴趣的话，你可以查看java.lang.reflect.Field类的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="comment">// This is guaranteed to be interned by the VM in the 1.4</span></span><br><span class="line">    <span class="comment">// reflection implementation</span></span><br><span class="line">    <span class="keyword">private</span> String              name;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String    signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> FieldRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="comment">// Cached field accessor created without override</span></span><br><span class="line">    <span class="keyword">private</span> FieldAccessor fieldAccessor;</span><br><span class="line">    <span class="comment">// Cached field accessor created with override</span></span><br><span class="line">    <span class="keyword">private</span> FieldAccessor overrideFieldAccessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、反射攻击"><a href="#三、反射攻击" class="headerlink" title="三、反射攻击"></a>三、反射攻击</h2><p>上面罗列了Class、Constructor、Method、Field中的常用方法，<strong>实际上，在Constructor、Method、Field类中，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限，</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用这个方法，我们可以将私有的构造函数、方法、成员变量设置为可访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Demo$Person&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person pobj = (Person) constructor.newInstance();</span><br><span class="line">    Field field = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    field.set(pobj, <span class="number">10</span>);</span><br><span class="line">    Method method = clazz.getDeclaredMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    method.invoke(pobj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在《设计模式之美》中，我们有讲到单例模式。单例模式只允许单例类实例化一个对象。单例模式有很多实现方式，其中一种实现方法如下所示，我们通过将构造函数设置为私有的，来禁止外部代码创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; <span class="comment">//单例</span></span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，通过反射，我们仍然可以绕开代码中的访问权限控制，调用私有的构造函数，实例化新的对象，如下所示，<strong>这种打破单例类只能实例化一个对象的限制的情况，就叫做反射攻击。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.IdGenerator&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    IdGenerator idGenerator = (IdGenerator) constructor.newInstance();</span><br><span class="line">    System.out.println(idGenerator.getId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、反射的应用"><a href="#四、反射的应用" class="headerlink" title="四、反射的应用"></a>四、反射的应用</h2><p>在《设计模式之美》中，我们讲到，Spring可以作为一种IOC容器（也叫做DI容器，依赖注入容器），<strong>实际上，IOC容器就是一个大的工厂类，负责在程序启动时，根据配置，事先创建好对象。</strong>当应用程序需要使用某个对象时，直接从容器中获取即可。</p>
<p><strong>在普通的工厂模式中，工厂类要创建哪个对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，IOC容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。应用程序通过配置文件，定义好需要创建的对象。IOC容器读取配置文件，并将每个要创建的对象信息，解析为一定的内存结构：BeanDefinition，然后根据BeanDefinition中的信息，通过反射创建对象。</strong><br>对于IOC容器的完整实现，我们在《设计模式之美》中有详细介绍。这里，我们重点展示跟反射有关的部分，也就是根据BeanDefinition创建对象。代码如下所示。在下列代码中，我们使用Class.forName()来创建对象，对于无参构造，我们使用Class对象上的newInstance()来创建对象，对于有参构造，我们先获取对应的Constructor对象，然后调用Constructor对象上的newInstance()来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects  = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="keyword">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition beanDefinition = beanDefinitions.get(beanId);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class beanClass = Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">      <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">        bean = beanClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class[] argClasses = <span class="keyword">new</span> Class[args.size()];</span><br><span class="line">        Object[] argObjects = <span class="keyword">new</span> Object[args.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg = args.get(i);</span><br><span class="line">          <span class="keyword">if</span> (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] = arg.getType();</span><br><span class="line">            argObjects[i] = arg.getArg();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());</span><br><span class="line">            <span class="keyword">if</span> (refBeanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationFailureException(<span class="string">&quot;Create Bean failed: &quot;</span> + beanDefinition.getId(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、反射的原理"><a href="#五、反射的原理" class="headerlink" title="五、反射的原理"></a>五、反射的原理</h2><p>前面我们提到，使用反射来创建对象，跟使用new创建对象，大体的流程是一样，只不过向JVM申请创建对象的方式不同而已。但是，我们还经常听说，使用反射来创建对象，要比使用new创建对象，要慢很多。那这到底又是为什么呢？接下来，我们先做个实验来验证一下情况是否属实。测试代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用new创建对象</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      C c = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">    <span class="comment">// 使用反射创建对象</span></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = C.class;</span><br><span class="line">      Object obj = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行上述代码，得到结果为：通过new创建对象的耗时为3ms，通过反射创建对象的耗时为31ms，差不多10倍的差距。</strong>尽管耗时有10倍的差距，但从耗时的绝对值上来看，通过反射创建1000万个对象，耗时才只有31ms，对于大部分应用程序来说都是可以接受的，<strong>绝大部分情况下，通过反射创建对象都不会是应用程序的性能瓶颈，我们不需要为反射带来的一丢丢性能损耗而担忧。</strong></p>
<p>前面讲到，使用反射还可以动态的执行方法，那么，相比于直接执行方法，使用反射执行方法会不会也很慢呢？为了测试使用反射执行方法的性能，我们对上面的测试代码稍作修改，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方法调用</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      c.f();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">    <span class="comment">// 使用反射执行方法</span></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    Class&lt;?&gt; clazz = C.class;</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      Method method = clazz.getMethod(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">      method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行上述代码，得到的结果为：普通方法调用的耗时为3ms，而使用反射执行方法的耗时为1259ms，有几百倍的差距。这个差距就比较大了。尽管性能差距如此大，但我们也不必为使用反射导致方法执行性能下降而担忧。这是为什么呢？</strong></p>
<p><strong>原因有二。其一是：使用反射执行方法，并不会让方法内部逻辑的执行速度变慢，只是增加了一些额外耗时而已，这部分额外的耗时是固定的，跟方法内部逻辑的复杂程度无关。其二是：1000万次方法调用才耗时1259ms，平均执行一次方法的增加的额外耗时为0.0001259ms，非常小，对于大部分方法来说，特别是一些包含IO操作的方法（比如访问数据库），方法本身内部逻辑执行的耗时远远大于使用反射而额外增加的耗时，因此，在大部分情况下，我们也并不需要担心使用反射执行方法导致的一丢丢性能下降。</strong></p>
<p>那么，相比普通的对象创建和执行，使用反射创建对象和执行方法，增加的额外耗时产生在哪里呢？</p>
<h4 id="1）安全性检查"><a href="#1）安全性检查" class="headerlink" title="1）安全性检查"></a>1）安全性检查</h4><p><strong>对于普通的对象创建和执行，大量的安全性检查，比如传入某个方法的数据类型必须与参数类型匹配、在某个对象上调用某个方法必须确保这个对象有这个方法，这些都是在编译时完成的，不占用运行时间，但是，对于反射，因为其是在运行时才确定创建什么对象、执行什么方法的，所以，安全性检查无法在编译时执行，只能在运行时真正创建创建、执行方法时再完成，那么这就会增加额外的运行时间。</strong></p>
<h4 id="2）类、方法查找"><a href="#2）类、方法查找" class="headerlink" title="2）类、方法查找"></a>2）类、方法查找</h4><p><strong>当我们使用反射创建对象或执行方法时，我们需要通过类名、方法名去查找对应的类或方法，而类名、方法名都是字符串，字符串匹配相对来说比较慢速。而正常情况下，代码经过编译之后，得到的字节码中，每个类和方法都会分配一个对应的编号，保存在常量池中，代码中所有出现类或方法的地方，都会被替换为编号。相比于通过类名、方法名字符串来查找类和方法，通过编号来查找对应的类或方法，显然要快得多。</strong><br>我们再通过一个简单的例子进一步解释一下，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码经过编译之后，得到的字节码如下所示，其中，常量池（Constant pool）中保存了各个类、方法的编号。类创建通过“new #编码”来实现，方法执行通过“invokespecial #编<br>号”来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 53</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: (0<span class="title">x0021</span>) <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class">  <span class="title">this_class</span>: #2                          // <span class="title">Demo</span></span></span><br><span class="line"><span class="class">  <span class="title">super_class</span>: #5                         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="class">  <span class="title">interfaces</span>: 0, <span class="title">fields</span>: 0, <span class="title">methods</span>: 3, <span class="title">attributes</span>: 1</span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">  #1 </span>= Methodref          #<span class="number">5.</span>#<span class="number">15</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">2</span> = Class              #<span class="number">16</span>            <span class="comment">// Demo</span></span><br><span class="line">  #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">15</span>         <span class="comment">// Demo.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">17</span>         <span class="comment">// Demo.f:()V</span></span><br><span class="line">  #<span class="number">5</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">8</span> = Utf8               Code</span><br><span class="line">  #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               main</span><br><span class="line">  #<span class="number">11</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">12</span> = Utf8               f</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               Demo.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               Demo</span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">12</span>:#<span class="number">7</span>         <span class="comment">// f:()V</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>     <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class Demo</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">7</span>: astore_1</span><br><span class="line">        <span class="number">8</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method f:()V</span></span><br><span class="line">        <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">11</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>六、课后思考题<br>单例模式有多种实现方式，其他实现方式是否也存在可能被反射攻击的问题呢？</p>
]]></content>
      <categories>
        <category>编程之美（王争）</category>
      </categories>
  </entry>
</search>
