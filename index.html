<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"the-rings.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
<meta property="og:type" content="website">
<meta property="og:title" content="免逸">
<meta property="og:url" content="https://the-rings.github.io/index.html">
<meta property="og:site_name" content="免逸">
<meta property="og:description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="The Rings">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://the-rings.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>免逸</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">免逸</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">下一代web开发是什么样的？下一代类报表系统是什么样的？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">The Rings</p>
  <div class="site-description" itemprop="description">软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/09/06/reset-centos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/06/reset-centos/" class="post-title-link" itemprop="url">reset-centos</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-06 23:59:17" itemprop="dateCreated datePublished" datetime="2023-09-06T23:59:17+08:00">2023-09-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>将Windows重装为centos/7</p>
<h5 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h5><ol>
<li>现在镜像<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/centos-vault/centos/7.8.2003/isos/x86_64/">https://mirrors.aliyun.com/centos-vault/centos/7.8.2003/isos/x86_64/</a></li>
<li>直接下载.iso就行</li>
<li>下载U盘启动盘制作工具：UltraISO，一路选择试用</li>
<li>运行 UltraISO，选择试用，选择主界面菜单栏里的[文件] → [打开]，选择你刚下载好的 CentOS 7 镜像</li>
<li>选择菜单栏里的 [启动] → [写入硬盘映像]</li>
<li>此时如果出现：“设备忙，关闭正在运行的应用程序”等字样时，是因为U盘没有被完全格式化</li>
<li>那么，管理员运行Windows Terminal或者cmd，然后<code>diskpart</code>，然后<code>list disk</code>，然后<code>select disk 1</code>，然后<code>clean</code>，这就将U盘格式化成功了</li>
<li>然后重复4和5步骤，就可以写入成功了</li>
</ol>
<h5 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h5><ol>
<li>F12进入BIOS系统，我的电脑一般不自动识别U盘，需要启动一轮硬件检查，然后检查过程中可以直接中断，然后再次重启，F12后就会发现我的U盘(Sumsang字样)</li>
<li>选择U盘启动，选择<code>Test this mode &amp; Install CentOS 7</code></li>
<li>此时，出现了<code>Warning: /dev/root does not existed</code>，是因为找不到U盘挂载的位置，需要额外配置</li>
<li>在当前最下边命令行输入：<code>dracut:/# ls /dev</code>，查询所有文件夹。此时，如果只有一个硬盘挂载的情况下，默认U盘挂载的位置是<code>sdb4</code>，如果多个硬盘的电脑，就要借助搜索引擎了</li>
<li>然后<code>dracut:/# reboot</code>，出现选择<code>Test this mode &amp; Install CentOS 7</code>的页面</li>
<li>键盘输入<code>e</code>，进入编辑，将<code>vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\* rd.live.check quiet</code>改为<code>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sd4 quiet</code>，然后按键F10保存，继续安装</li>
<li>成功！</li>
</ol>
<h5 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h5><ol>
<li>默认的CentOS是网络服务不启动的，我们要配置其开机启动，插上网线</li>
<li>查看网卡信息<code>ip addr</code>，看看哪个网卡没有配置，一般是第二个<code>p8p1</code></li>
<li>然后<code>cd /etc/sysconfig/network-scripts/ifcfg-p8p1</code>，将<code>ONBOOT=no</code>改为<code>ONBOOT=yes</code></li>
<li>重启服务<code>systemctl restart network</code></li>
<li>然后<code>ping www.baidu.com</code>如果不行，就重启一下电脑</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/08/18/trader-course/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/18/trader-course/" class="post-title-link" itemprop="url">trader-course</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-18 18:51:30" itemprop="dateCreated datePublished" datetime="2023-08-18T18:51:30+08:00">2023-08-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="14天债券交易员集训"><a href="#14天债券交易员集训" class="headerlink" title="14天债券交易员集训"></a>14天债券交易员集训</h5><p>11月14日</p>
<ul>
<li>债券市场基础知识（一），债券历史，一级市场概述<br>11月15日</li>
<li>债券市场基础知识（二），二级市场概述，债券收益率曲线、久期和凸性<br>在债券投资里，以净价来交易，但以全价进行结算，债券的全价=净价+应计利息<br>债券投资，如果把时间拉的足够长，那么收益的70%以上都来自于稳定的票息收益<br>R=无风险利率+预期通货膨胀率+期限利差+信用利差+流动性溢价，其中“期限利差”，听起来像是再说Yield and Spread</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/08/07/network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/07/network/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-07 21:28:49" itemprop="dateCreated datePublished" datetime="2023-08-07T21:28:49+08:00">2023-08-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="categories" content="">
<meta name="date" content="2022-07-31 21:14:47"><style>body {
  max-width: 980px;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

.markdown-body diagram-div, .markdown-body div.uml-sequence-diagram, .markdown-body, div.uml-flowchart {
  overflow: auto;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#fff;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>network</title></head><body><article class="markdown-body"><h2 id="-network">- Network<a class="headerlink" href="#-network" title="Permanent link"></a></h2>
<h5 id="-p2p">网络通信有两种体系结构：客户-服务器体系结构、P2P体系结构<a class="headerlink" href="#-p2p" title="Permanent link"></a></h5>
<h5 id="message">无论那种体系结构，网络通信，实际上是进程间的通信，通过计算机网络交换message(报文)而相互通信<a class="headerlink" href="#message" title="Permanent link"></a></h5>
<h5 id="socketmessagemessage">进程通过socket的接口向网络发送message(报文)和从网络中接收message(报文)<a class="headerlink" href="#socketmessagemessage" title="Permanent link"></a></h5>
<ol>
<li>socket是程序进程与传输层之间的接口</li>
<li>开发者可以控制socket在应用端的everything，但是对socket的传输层几乎没有控制权</li>
</ol>
<h5 id="packet">packet会在计算机网络传输的过程中丢失<a class="headerlink" href="#packet" title="Permanent link"></a></h5>
<ol>
<li>packet造成路由器中的缓存溢出，或者packet某些比特损坏后会被丢弃，或者底层信道出现了丢包</li>
<li>我们呼唤一种可靠的数据传输(reliable data transfer)协议</li>
<li>我们呼唤在发送时，传输层协议能够加密由发送进程传输的所有数据，在接受主机中，传输层协议将数据解密交付给接收进程</li>
</ol>
<h5 id="_1">传输层协议是在端系统(操作系统)中实现的<a class="headerlink" href="#_1" title="Permanent link"></a></h5>
<ol>
<li>在网络模型的协议栈中，传输层位于网络层之上。网络层提供了<em>主机之间</em>的逻辑通信，而传输层为运行在不同主机上的<em>进程之间</em>提供了逻辑通信</li>
</ol>
<h5 id="messagesegment">传输层将从发送进程接受到的message(报文)转换为传输层的segment<a class="headerlink" href="#messagesegment" title="Permanent link"></a></h5>
<ol>
<li>实现方法是，将应用层的报文划分为小块，并未每块加上一个传输层首部生成传输层segment，然后在发送端系统中，传输层将这些segment传递给网络层，网络层(即路由器)再将其封装成网络层packet(分组)，即数据报，并向目的地发送。</li>
</ol>
<h5 id="tcpiptcpudp">TCP/IP网络(因特网)为提供了两种传输层协议TCP和UDP<a class="headerlink" href="#tcpiptcpudp" title="Permanent link"></a></h5>
<h5 id="tcp">TCP服务模型包括两个部分：面向连接的服务 和 可靠的数据传输服务<a class="headerlink" href="#tcp" title="Permanent link"></a></h5>
<ol>
<li>UDP是一种不可靠、无连接的服务</li>
</ol>
<h5 id="udptcpip">UDP和TCP最基本的责任是，将两个系统间的IP的交付服务扩展为运行在端系统上的进程之间的服务<a class="headerlink" href="#udptcpip" title="Permanent link"></a></h5>
<ol>
<li>进程到进程的数据交付（交付到IP层，也叫网络层）和差错检查是两种最低限度的传输层服务，也是UDP仅有的两个服务</li>
<li>在IP交付服务的实现上，UDP无非就是对网络层协议增加了多路复用和多路分解的功能而已。将传输层segment中的数据交付到对应socket的工作称为多路分解(demultiplex)，在源主机从不同的socket中收集数据块，并为每个数据块装上首部信息，生成segment，然后将segment传递到网络层，这个过程称为多路复用(multiplex)，多路复用和分解的具体实现可以看：<a href="/2023/06/12/network-io-multiplex/" title="&amp;lsquo;图解多路复用&amp;rsquo;">&amp;lsquo;图解多路复用&amp;rsquo;</a></li>
<li>除了UDP提供的两个服务之外，TCP为应用提供了几种附加服务，包括可靠的数据传输、拥堵控制(congestion control)</li>
</ol>
<h5 id="tcp_1">TCP是面向连接的服务<a class="headerlink" href="#tcp_1" title="Permanent link"></a></h5>
<ol>
<li>在message(报文)开始流动之前，TCP让客户端和服务器交换传输层的控制信息，这个被俗称为“握手”过程</li>
<li>握手结束后，一个TCP连接就在两个进程的socket之间建立了</li>
<li>这个连接数全双工的，即连接双方的进程可以在此连接上同时进行message(报文)的收发</li>
</ol>
<h5 id="tcp_2">TCP是可靠的数据传输服务<a class="headerlink" href="#tcp_2" title="Permanent link"></a></h5>
<ol>
<li>发送进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据</li>
<li>接受进程能够依靠TCP接受所有字节，没有字节丢失和冗余</li>
</ol>
<h5 id="ssltcptcp">用SSL加强后的TCP，不仅能够做传统的TCP所作的一切，而且提供了安全服务，包括加密，数据完整性和端点鉴别<a class="headerlink" href="#ssltcptcp" title="Permanent link"></a></h5>
<ol>
<li>TCP和UDP没有任何加密机制，就是说发送进程传进socket的数据与经网络传送到目的地的进程数据相同</li>
<li>这种强化是在应用层上实现的</li>
</ol></article></body></html>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/07/16/spring-property-sources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/16/spring-property-sources/" class="post-title-link" itemprop="url">spring 配置优先级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-16 20:26:43" itemprop="dateCreated datePublished" datetime="2023-07-16T20:26:43+08:00">2023-07-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Spring Boot获取配置参数有一个顺序, 这个顺序是特殊的:</p>
<ol>
<li>Default properties (specified by setting SpringApplication.setDefaultProperties).</li>
<li><code>@PropertySource</code> annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.</li>
<li>Config data (such as application.properties files)</li>
<li>A RandomValuePropertySource that has properties only in random.*.</li>
<li>OS environment variables.</li>
<li>Java System properties (System.getProperties()).</li>
<li>JNDI attributes from java:comp/env.</li>
<li>ServletContext init parameters.</li>
<li>ServletConfig init parameters.</li>
<li>Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li>properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.</li>
<li>@TestPropertySource annotations on your tests.</li>
<li>Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.<br>以上这些就是Spring Boot启动时, 默认读取Property的位置和顺序.<br>其中, 注解<code>@PropertySource</code>需要注意, 通过注解<code>@PropertySource</code>来定位配置文件<code>.properties</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:application.properties&quot;, ignoreResourceNotFound = true)</span></span><br></pre></td></tr></table></figure>
当你运行SpringBoot启动类的main方法, SpringBoot将会自动按顺序读取这14个PropertySource(低版本的可能是17个, 当前版本是2.5.6), 为的是将这些配置注入到项目中.</li>
</ol>
<blockquote>
<p>提示: Spring Boot将配置的值注入bean的属性有两种办法</p>
<ol>
<li>@Value</li>
<li>@ConfigurationProperties</li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/12/network-io-multiplex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/12/network-io-multiplex/" class="post-title-link" itemprop="url">图解 | 原来这就是 IO 多路复用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 20:15:48" itemprop="dateCreated datePublished" datetime="2023-06-12T20:15:48+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>进程创建和上下文切换，在Linux上是开销很大的，一次上下文切换就有好几个微妙，所以为了能够高效地对海量用户提供服务，必须让一个进程处理多个tcp连接。<br>如果某个进程保持了10000条连接，那么如何发现哪条连接有数据可读，或者有数据可写了呢？<br>我们当然可以将所有连接遍历一遍，但是太低级，我们希望，将很多连接中有IO事件发生的时候直接将其get出来，Linux给我们提供了系统调用，这就是IO多路复用，这里的复用指的是对进程的复用，一个进程就可以处理多个客户端连接。<br>Linux提供了多个IO多路复用的函数，select，poll，epoll，它们三个，epoll性能最好<br>从阻塞IO到IO多路服用的历史发展过程</p>
<h2 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h2><p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listenfd = socket();   <span class="comment">// 打开一个网络通信端口</span></span><br><span class="line">bind(listenfd);        <span class="comment">// 绑定</span></span><br><span class="line">listen(listenfd);      <span class="comment">// 监听</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 阻塞建立连接，一个socket连接对于操作系统来说就是最后就是一个文件，我们用文件描述符来标识它，那么操作系统就可以根据这个文件描述符来do something了</span></span><br><span class="line">  connfd = accept(listenfd);  </span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会执行得磕磕绊绊，就像这样。<br><img src="/blocking-io-1.image"></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p><img src="/blocking-io-2.image"></p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图。<br><img src="/blocking-io-3.image"></p>
<p>所以，如果这个连接的客户端一直不发数据，那么服务端线程将会一直阻塞在 read 函数上不返回，也无法接受其他客户端连接。</p>
<p>这肯定是不行的。</p>
<h2 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h2><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p>有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  pthread_create(doWork);  <span class="comment">// 创建一个新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。<br><img src="/no-blocking-io-1.image"></p>
<p>不过，<em>这不叫非阻塞 IO</em>，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</p>
<p>所以<em>真正的非阻塞 IO</em>，不能是通过我们用户层的小把戏，而是要恳请操作系统为我们提供一个非阻塞的 read 函数。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line"><span class="keyword">int</span> n = (read(connfd, buffer) != SUCCESS);</span><br></pre></td></tr></table></figure>
<p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。<br><img src="/no-blocking-io-2.image"></p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图。<br><img src="/no-blocking-io-3.image"></p>
<h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。<br><img src="/multiplexing-1.image"></p>
<p>当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</p>
<p><code>connfdList.add(connfd);</code><br>然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里涉及到，一边往connfdList中放置文件描述符connfd，一边又要遍历它</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- connfdList) &#123;</span><br><span class="line">    <span class="keyword">if</span>(read(fd) != <span class="number">-1</span>) &#123;</span><br><span class="line">      doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就成功用一个线程处理了多个客户端连接。 <em>一个线程去处理多个连接就是socket中的IO多路复用，就这么简单，其实代码写的很烂的</em><br><img src="/multiplexing-2.image"></p>
<p>你是不是觉得这有些多路复用的意思？</p>
<p>但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</p>
<p>在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：<br><img src="/multiplexing-3.image"></p>
<p>select系统调用的函数定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// nfds:监控的文件描述符集里最大文件描述符加1</span></span><br><span class="line"><span class="comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span></span><br><span class="line"><span class="comment">// timeout：定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">//  1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">//  2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br></pre></td></tr></table></figure>
<p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);</span><br><span class="line">  fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">  fdlist.add(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 把一堆文件描述符 list 传给 select 函数</span></span><br><span class="line">  <span class="comment">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span></span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  <span class="comment">// 用户层依然要遍历，只不过少了很多无效的系统调用</span></span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 只读已就绪的文件描述符</span></span><br><span class="line">      read(fd, buf);</span><br><span class="line">      <span class="comment">// 总共只有 nready 个已就绪描述符，不用过多遍历</span></span><br><span class="line">      <span class="keyword">if</span>(--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如刚刚的动图中所描述的，其直观效果如下。<br><img src="/multiplexing-3.image"></p>
<p>可以看出几个细节：</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p><em>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</em></p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>整个 select 的流程图如下。<br><img src="/multiplexing-4.image"></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 也是操作系统提供的系统调用函数。 polling在计算机中意思为：轮询</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, nfds_tnfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  intfd; <span class="comment">/*文件描述符*/</span></span><br><span class="line">  shortevents; <span class="comment">/*监控的事件*/</span></span><br><span class="line">  shortrevents; <span class="comment">/*监控事件中满足条件返回的事件*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。<em>epoll中的e代表的是event</em></p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。<em>由于计算机硬件芯片的发展，内存越来越大，可以用空间换时间了，在内存中有了一个cache map</em></p>
</li>
<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p>具体，操作系统提供了这三个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，创建一个 epoll 句柄(Handle)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 第二步，向内核添加、修改或删除要监控的文件描述符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// 第三步，类似发起了 select() 调用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> max events, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 使用起来，其内部原理就像如下一般丝滑。</span></span><br></pre></td></tr></table></figure>
<p><img src="/multiplexing-5.image"></p>
<p>如果你想继续深入了解 epoll 的底层原理，推荐阅读飞哥的《图解 深入揭秘 epoll 是如何实现 IO 多路复用的！》，从 linux 源码级别，一行一行非常硬核地解读 epoll 的实现原理，且配有大量方便理解的图片，非常适合源码控的小伙伴阅读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 阻塞 IO。</p>
<p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p>
<p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了<em>非阻塞的 read 函数</em>，这样程序员就可以在<em>一个线程内完成多个文件描述符的读取（就有点IO多路复用的意思了）</em>，这就是 非阻塞 IO。</p>
<p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p>
<p>于是又在操作系统层面提供了这样的遍历文件描述符的机制，表现为<em>单个进程可以处理多个客户端连接</em>，这就是 IO 多路复用。</p>
<p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 前两者 的三个不足：</p>
<ol>
<li>不需要把文件描述符数组从用户态拷贝到内核态，因为内核态已经存了一份。通过epoll_create会增删改文件描述符组成的红黑树</li>
<li>内核态不需要遍历整个文件描述符集合，而是通过传入事件参数event，event可以直接定位哪个文件描述符有数据到达，就是所谓的异步IO事件唤醒</li>
<li>返回有IO事件的文件描述符，不需要用户去遍历这个文件描述符集合</li>
</ol>
<p><em>所以，IO 模型的演进，其实就是时代的变化，倒逼着操作系统将更多的功能加到自己的内核而已。</em></p>
<p>如果你建立了这样的思维，很容易发现网上的一些错误。</p>
<p>比如好多文章说，多路复用之所以效率高，是因为用一个线程就可以监控多个文件描述符。</p>
<p>而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。</p>
<p>就好比我们平时写业务代码，把原来 while 循环里调 http 接口进行批量，改成了让对方提供一个批量添加的 http 接口，然后我们一次 rpc 请求就完成了批量添加，一个道理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/12/xzg-program-beauty-19/" class="post-title-link" itemprop="url">19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 18:47:57" itemprop="dateCreated datePublished" datetime="2023-06-12T18:47:57+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%8E%8B%E4%BA%89%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">编程之美（王争）</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>相对于其他Java基础知识，大部分程序员对Java I/O可能没那么了解，毕竟平时的工作很少会编写I/O相关的代码，比如读写文件、网络编程等。跟Java容器类似，java.io类库，也非常庞大，如此多类看得眼花缭乱，想要清晰的掌握，需要对其有个系统性的认识。本节，我就带你一块剖析一下java.io类库，给你构建一个java.io类库的全景图。</p>
<h2 id="一、io类库整体结构"><a href="#一、io类库整体结构" class="headerlink" title="一、io类库整体结构"></a>一、io类库整体结构</h2><p>I/O全称为Input/Output，中文为输入/输出。在计算机中，常用的I/O设备有硬盘、网络、键盘、显示器等，在操作系统层面，I/O系统有文件、网络、标准输入和输出（对应键盘和显示器）、管道等。Java提供的I/O类库就是用来读写这些I/O系统的。Java I/O类库主要有两个：java.io类库和java.nio类库。</p>
<p>在JDK1.4之前，Java引入了java.io类库。在JDK1.4中，<strong>Java引入了java.nio类库，支持非阻塞I/O模型的开发。在JDK7中，Java对java.nio类库进行了升级，引入了更多的类，支持异步I/O模型的开发。</strong>关于java.nio和I/O模型，我们下一节再讲。本节聚焦在java.io类库上。</p>
<p>java.io类库中包含的类非常多。在介绍Java容器时，我们画了一张比较复杂的类图，当时，我也提醒你说，一定要将它搞清楚。对于java.io类库，我们同样花了一张类图，如下图所示，也比较复杂，同理，你也要搞搞清楚。搞清楚了这张图，基本上也就掌握了java.io类库。</p>
<p><img src="/2023/06/12/xzg-program-beauty-19/1.png" alt="java.io.png"></p>
<p>上图包含的类比较多，我们分类讲解。从不同的维度，java.io类库有不同的分类方式。我们按照不同的分类方式，拆解整个java.io类库，并逐一讲解。</p>
<h2 id="二、输入流和输出流"><a href="#二、输入流和输出流" class="headerlink" title="二、输入流和输出流"></a>二、输入流和输出流</h2><p>按照<strong>数据流向</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）输入流：InputStream、Reader"><a href="#1）输入流：InputStream、Reader" class="headerlink" title="1）输入流：InputStream、Reader"></a>1）输入流：InputStream、Reader</h4><h4 id="2）输出流：OutputStream、Writer"><a href="#2）输出流：OutputStream、Writer" class="headerlink" title="2）输出流：OutputStream、Writer"></a>2）输出流：OutputStream、Writer</h4><p><strong>所谓输入流，指的是将文件、网络、标准输入（System.in）、管道中的数据，输入到内存中。所谓输出流，指的是将内存中的数据输出到文件、网络、标准输出（System.out、System.err）、管道中。</strong></p>
<p>输入流的读取方式，如下示例代码所示。<strong>我们通过try-catch-resources语句打开InputStream，这样在try代码块结束后，JVM会自动调用InputStream的close()函数关闭输入流。</strong>为了简化代码编写，本节后续示例代码均省略异常的捕获处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (in.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出流的写入方式，如下示例代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">new</span>  FileOutputStream(<span class="string">&quot;/Users/wangzheng/out.txt&quot;</span>)；</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line">out.write(data);</span><br></pre></td></tr></table></figure>


<h2 id="三、字节流和字符流"><a href="#三、字节流和字符流" class="headerlink" title="三、字节流和字符流"></a>三、字节流和字符流</h2><p>按照数据流的<strong>读写单位</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）字节流：InputStream、OutputStream"><a href="#1）字节流：InputStream、OutputStream" class="headerlink" title="1）字节流：InputStream、OutputStream"></a>1）字节流：InputStream、OutputStream</h4><h4 id="2）字符流：Reader、Writer"><a href="#2）字符流：Reader、Writer" class="headerlink" title="2）字符流：Reader、Writer"></a>2）字符流：Reader、Writer</h4><p>所谓字节流，指的是一个字节一个字节的从输入流中读取数据，或者将数据写入输出流。<strong>所谓字符流，指的是一个字符一个字符的从输入流中读取数据，或者将数据写入输出流。实际上，字符流比起字节流来说，只是多了一个字符编码转换的环节。</strong>我们拿文件读写来举例解释。</p>
<p>前面讲过，<strong>Java中的char类型数据使用UTF16编码，而文件的编码方式有可能是UTF8、GBK等，所以，当从文件中读取数据到Java内存中的char数组时，我们需要将其从文件的编码方式转换为UTF16编码方式，同理，当我们将Java内存中的字符串写入到文件时，需要将UTF16编码转化为文件的编码方式。</strong>示例代码如下所示。在写入完成之后，我们打开a.txt文件，查看文件内容的16进制格式，发现存储的是“王a争”这几个字符的UTF-8编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">String s = <span class="string">&quot;王a争&quot;</span>;</span><br><span class="line">writer.write(s);</span><br></pre></td></tr></table></figure>

<p>从java.io类图中，我们可以发现，Java分别为字符流和字节流设计了两套类。这两套类在代码实现上有些重复，毕竟I/O读写操作都是相同的，唯一的区别只是数据解析的方式不同。实际上，为了字节流和字符流设计两套类完全是没有必要的。java.nio利用“组合优于继承”的设计思想，引入Channel和Buffer的概念，对此设计进行了优化，关于这一点，我们在下节中会详细讲解。</p>
<h2 id="四、原始类和装饰器类"><a href="#四、原始类和装饰器类" class="headerlink" title="四、原始类和装饰器类"></a>四、原始类和装饰器类</h2><p><strong>java.io类库的设计用到了设计模式中的装饰器模式，从这个角度，我们可以将java.io类库中的类分为原始类和装饰器类。</strong>在《设计模式之美》一书中，我详细介绍了java.io类库如何使用装饰器模式简化类的设计，建议你去读一下。这里我们就不再赘述。装饰器类和原始类的区别在于，装饰器类是对原始类的功能增强，不能独立使用。<strong>比如，FileInputStream为原始类，可以独立使用，BufferedInputStream为装饰器类，支持缓存功能，不能独立使用，必须嵌套原始类或其他装饰器类。</strong>示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、原始类分类介绍"><a href="#五、原始类分类介绍" class="headerlink" title="五、原始类分类介绍"></a>五、原始类分类介绍</h2><p>对于原始类，我们还可以按照读写的I/O系统的不同，将其分为如下几类。注意这里不涉及装饰器类，因为装饰器类主要用于增强功能。</p>
<h4 id="1）文件"><a href="#1）文件" class="headerlink" title="1）文件"></a>1）文件</h4><p>跟文件读写相关的类有FileInputStream、FileOutputStream、FileReader、FileWriter。前面已经给出了一些文件读写的示例代码。这里就不再赘述。</p>
<h4 id="2）网络"><a href="#2）网络" class="headerlink" title="2）网络"></a>2）网络</h4><p>实际上，java.io类库并没有提供专门的类用于网络I/O的读写，而是直接复用InputStream类、OutputStream类进行网络I/O的读写。除此之外，单独使用java.io类库也并不能完成网络编程，需要借助java.net类库的配合。java.net类库用来管理网络连接，比如创建连接、关闭连接、监听连接等。java.io类库只负责读写已经建立的网络连接。示例代码如下所示。java.io类库在网络编程中的表现非常差劲，正因为如此，才有了java.nio类库的出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Socket类位于java.net包中</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.29.2.4&quot;</span>, <span class="number">8090</span>);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;hi~&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (in.read(data) != - <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，从java.io的类图中，我们也可以发现，InputStream、OutputStream是所有字节流类的父类，它既可以读写文件，也可以读写网络，还可以读写其他I/O。这充分体现了“抽象”的设计思想。尽管深入到硬件层面，各个I/O设备的读写方式各不相同，但是，上层应用开发并不关系底层实现细节，大部分I/O设备的访问都可以抽象为打开、读、写、关闭等这几个操作。因此，Java将所有的I/O设备都抽象为“Stream（流）”，并为不同I/O设备的读写设计了一套统一的接口。从而对于不同I/O设备的读写，我们可以使用同样的代码实现，代码更加统一、简洁。</p>
<h4 id="3）内存"><a href="#3）内存" class="headerlink" title="3）内存"></a>3）内存</h4><p>跟内存读写相关的类有：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、StringReader、StringWriter。我们将内存看做一种特殊的I/O系统，也可以像文件一样，当作Stream来读写。</p>
<p>在大部分情况下，我们都不需要这些内存读写类，直接对byte数组、char数组进行读写即可，没必要将它们封装成流来操作。这些类的主要作用是实现兼容。比如，我们使用第三方类库中的某个函数，来处理byte数组中的数据，但这个函数的输入参数是InputStream类型的，为了兼容这个函数的定义，我们就可以将待处理的byte数组，封装成ByteArrayInputStream对象，再传递给这个函数处理，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] source = <span class="string">&quot;学技术信小争哥就对了&quot;</span>.getBytes();</span><br><span class="line">InputStream in = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line"><span class="comment">// 接下来就可以跟处理其他InputStream一样处理source了</span></span><br></pre></td></tr></table></figure>


<p>在编写单元测试时，这些内存读写类也非常有用，可以替代文件或网络，将测试数据放置于内存，准备起来更加容易。如下代码所示，假设要为readFromFile()这个函数编写单元测试代码，我们需要创建文件，写入测试数据，并且放置到合适的地方，做一堆准备工作才能完成测试。如果使用ByteArrayInputStream，我们便可以在内存中构建测试数据，这样就方便了很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readFromFile</span><span class="params">(InputStream inputStream)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_readFromFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] testData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">  <span class="comment">//...构建测试数据，填入testData数组...</span></span><br><span class="line">  InputStream in = <span class="keyword">new</span> ByteIntputStream(testData);</span><br><span class="line">  <span class="keyword">int</span> res = readFromFile(in);</span><br><span class="line">  <span class="comment">//...assert...判断返回值是否符合预期...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4）管道"><a href="#4）管道" class="headerlink" title="4）管道"></a>4）管道</h4><p>跟管道读写相关的类有：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter。<strong>这里的管道跟Unix操作系统中的管道不同，Unix操作系统中的管道是进程间通信的工具，而这里的管道是Java提供的为同一个进程内两个线程之间通信的工具。一个线程通过PipedOutputStream写入的数据，另一个线程就可以通过PipedInputStream读取数据，示例代码如下所示。尽管Java已经提供了很多线程间通信的方式，比如常用的有共享变量，但是，一般来说，对于两个线程之间非对象的原始数据的传输，我们更倾向于使用管道来实现。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PipedOutputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">PipedInputStream in = <span class="keyword">new</span> PipedInputStream(out);</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      out.write(<span class="string">&quot;Hi wangzheng~&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in.read(buffer);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h4 id="5）标准输入输出"><a href="#5）标准输入输出" class="headerlink" title="5）标准输入输出"></a>5）标准输入输出</h4><p><strong>在操作系统中，一般会有三个标准I/O系统：标准输入、标准输出、标准错误输出。标准输入对应I/O设备中的键盘，标准输出和标准错误输出对应I/O设备中的屏幕。</strong>Java中的标准输入为System.in，它是一个定义在System类中的静态InputStream对象。Java中的标准输出和标准错误输出分别为System.out和System.err，它们都是定义在System类中的PrintStream对象。PrintStream为装饰器类，需要嵌套OutputStream来使用，支持按照格式输出数据，待会会讲到。System.in、System.out、System.err的使用示例如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br><span class="line"><span class="comment">//System.err显示的字符串为红色，以表示出错</span></span><br><span class="line">System.err.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br></pre></td></tr></table></figure>



<h2 id="六、装饰器类分类介绍"><a href="#六、装饰器类分类介绍" class="headerlink" title="六、装饰器类分类介绍"></a>六、装饰器类分类介绍</h2><p>装饰器类用于增强原始类的功能。我们按照功能的不同分类讲解装饰器类。</p>
<h4 id="1）支持读写缓存功能的装饰器类"><a href="#1）支持读写缓存功能的装饰器类" class="headerlink" title="1）支持读写缓存功能的装饰器类"></a>1）支持读写缓存功能的装饰器类</h4><p>支持读写缓存功能的装饰器类有：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。这4个类的作用非常相似，我们拿BufferedInputStream、BufferedOutputStream举例讲解。</p>
<p><strong>对比InputStream，BufferedInputStream会在内存中维护一个8192字节大小的缓存。如果缓存中没有足够的数据，那么read()函数会向操作系统内核请求数据</strong>（关于I/O读写的实现原理，我们在第21节中讲解），读取8192字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，不再请求操作系统。</p>
<p><strong>读取同样多的数据，利用BufferedInputStream，向操作系统内核请求数据的次数减少。我们知道，向操作系统内核请求数据，需要使用系统调用，引起用户态和内核态的切换，是非常耗时的，所以，尽量减少系统调用，会提高程序的性能</strong>（关于这一部分内容的详细介绍，我们留在第21节中讲解）。<strong>不过，如果read()函数每次请求的数据量都大于等于8192字节，那么BufferedInputStream就不起作用了。</strong></p>
<p>如下代码所示，如果文件中的数据大小是8192字节，那么，读取所有数据需要调用8次read()函数，但因为缓存的存在，所以仅需要向操作系统内核请求一次数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>));</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，针对OutputStream，java.io类库提供了BufferedOutputStream，用来缓存写入的数据，当积攒到一定量（默认为8192字节）时，再一次性将其写入操作系统内核缓冲区，减少系统调用次数，提高程序的性能。</p>
<h4 id="2）支持基本类型数据读写的装饰器类"><a href="#2）支持基本类型数据读写的装饰器类" class="headerlink" title="2）支持基本类型数据读写的装饰器类"></a>2）支持基本类型数据读写的装饰器类</h4><p>DataInputStream支持将从输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeInt(<span class="number">12</span>);</span><br><span class="line">out.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">out.writeFloat(<span class="number">12.12f</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">System.out.println(in.readInt());</span><br><span class="line">System.out.println(in.readChar());</span><br><span class="line">System.out.println(in.readFloat());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>调用DataOutputStream的readChar()、writeChar()函数，我们也可以按字符为单位读取、写入数据，但跟字符流类不同的地方是，DataOutputStream类一次只能处理一个字符，而字符流类可以处理char数组，并且字符流类提供的函数更多，功能更加丰富。</p>
<h4 id="3）支持对象读写的装饰器类"><a href="#3）支持对象读写的装饰器类" class="headerlink" title="3）支持对象读写的装饰器类"></a>3）支持对象读写的装饰器类</h4><p>ObjectInputStream支持将从输入流中读取的数据反序列化为对象，ObjectOutputStream支持将对象序列化之后写入到输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">&quot;wangzheng&quot;</span>));</span><br><span class="line"></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">Person p = (Person) in.readObject();</span><br><span class="line">System.out.println(p.getId());</span><br><span class="line">System.out.println(p.getName());</span><br></pre></td></tr></table></figure>


<h4 id="4）支持格式化打印数据的装饰器类"><a href="#4）支持格式化打印数据的装饰器类" class="headerlink" title="4）支持格式化打印数据的装饰器类"></a>4）支持格式化打印数据的装饰器类</h4><p>PrintStream和PrintWriter可以将数据按照一定的格式，转化为字符串，写入到输出流。前面讲到System.out、System.err就是PrintStream类型的。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PrintStream printStream =<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">printStream.print(<span class="number">124</span>); <span class="comment">//int-&gt;Integer-&gt;toString(), 写入字符串&quot;124&quot;</span></span><br><span class="line">printStream.printf(<span class="string">&quot;hello %d&quot;</span>, <span class="number">43</span>); <span class="comment">//写入字符串&quot;hello 43&quot;</span></span><br></pre></td></tr></table></figure>


<p>除了以上装饰器类之外，还有一组原始类，其功能非常类似装饰器类，那就是InputStreamReader、OutputStreamWriter。InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类。它们可以将字节流转化为字符流。示例代码如下所示。从这一点上，我们也可以看出，java.io类库的设计有很多不合理的地方，更晚开发的java.nio类库在设计上明显要合理很多，下节会详细讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(outStream, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;王a争&quot;</span>); <span class="comment">//按照gbk编码将字符串写入文件</span></span><br></pre></td></tr></table></figure>


<p>对于其他装饰器类，比如PushbackInputStream、PushbackReader、SequenceInputStream、LineNumberReader，因为使用的比较少，我们就不再介绍了，如果感兴趣，可以自行查阅。</p>
<p>七、课后思考题<br>在本节中，我们频繁提到“Stream（流）”这个字眼，比如输入流、输出流、字节流、字符流等，这里的“流”到底是什么意思？为什么把I/O看作“流”？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/12/xzg-program-beauty-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/12/xzg-program-beauty-20/" class="post-title-link" itemprop="url">20. nio类库：BIO、NIO、AIO三种Java I/O模型的实现原理和区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 18:30:10" itemprop="dateCreated datePublished" datetime="2023-06-12T18:30:10+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%8E%8B%E4%BA%89%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">编程之美（王争）</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这篇文章和<a href="#">Post not found: xzg-program-beauty-20-1 图解I/O多路复用</a>一起读</p>
<p>Java中的I/O类库除了java.io之外，还包括java.nio。既然已经有了java.io了，为什么还要再开发一个新的java.nio呢？java.nio跟java.io有何区别？在平时的开发中，什么时候使用java.io？什么时候使用java.nio？面试中常被问到的BIO、NIO、AIO又是什么东西？带着这些问题，我们来学习本节的内容：java.nio。</p>
<h2 id="一、java-nio类库"><a href="#一、java-nio类库" class="headerlink" title="一、java.nio类库"></a>一、java.nio类库</h2><p>java.nio类库在JDK1.4中引入，nio的全称为New I/O，不过，因为其相对于java.io来说，对I/O提供了非阻塞的访问方式（这个待会再讲），所以，很多人也把nio解读为Non-blocking I/O。除此之外，尽管从功能上java.nio可以完全替代java.io，但在平时的开发中，对于普通的文件读写，我们更倾向于使用简单的java.io，<strong>java.nio发挥作用的场合更多的是网络编程。</strong>所以，还有人把nio解读为Network I/O。</p>
<p>上一节中讲到，在java.io中，Stream是一个核心的概念，所有的I/O都抽象为Stream，读写Stream就等同于读写I/O。<strong>在java.nio中，已经没有了Stream，转而引入了Channel。Channel类似Stream，也是对I/O的抽象。除此之外，java.nio还引入了一个新的概念：Buffer，用来存储待写入或读取的数据。</strong></p>
<p>我们先拿一个比较简单的文件读写的例子，来看一下Channel和Buffer是如何使用的，让你对java.nio有个最初步的直观的认识。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileChannel channel = FileChannel.open(Paths.get(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>));</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">while</span> (channel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理buffer中的数据data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>除了上面提到的Buffer、Channel之外，java.nio中还有两个重要的概念：Selector和AsynchronousChannel，接下来，我们就详细介绍一下java.nio中的这4个核心概念。</p>
<h4 id="1）Buffer"><a href="#1）Buffer" class="headerlink" title="1）Buffer"></a>1）Buffer</h4><p>Buffer本质上就是一块内存，就相当于在使用java.io编程时申请的byte数组。常用到Buffer有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、MappedByteBuffer。这些Buffer的不同之处在于：解析数据的方式不同，比如CharBuffer按照字符来解析数据，有点类似java.io中的字符流。</p>
<p>上一节我们讲到，java.io的设计有诸多问题，而java.nio的设计要优于java.io。上一节讲到，java.io分别为字符流和字节流设计了不同的类库，在代码实现上有些重复，毕竟I/O读写操作都是相同的，唯一的区别只是数据的解析方式不同。字节流类按照字节解析数据。字符流类按照字符解析数据。java.nio将解析这部分功能抽取出来，独立到Buffer类中。不同的Channel跟不同的Buffer组合在一起，可以实现不同的IO读写需求。比如，将FileChannel跟ByteBuffer组合起来，就相当于java.io中的文件字节流类（FileInputStream、FileOutputStream），将FileChannel跟CharBuffer组合起来，就相当于java.io中的文件字符流类（FileReader、FileWriter）。</p>
<p>实际上，Channel和Buffer独立开发，组合起来使用，这种设计思路应用的就是面向对象中“组合优于继承”的设计思想，通过组合来替代继承，避免了继承带来的组合爆炸问题。正因如此，实现相同甚至更多功能的情况下，java.nio中的类的个数却比java.io中的类的个数少。关于“组合优于继承”这一设计思想的详细介绍，你可以阅读我的《设计模式之美》这本书。</p>
<h4 id="2）Channel"><a href="#2）Channel" class="headerlink" title="2）Channel"></a>2）Channel</h4><p>常用的Channel有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel用于文件读写。DatagramChannel、SocketChannel、ServerSocketChannel用于网络编程。DatagramChannel用来读写UDP数据，SocketChannel和ServerSocketChannel用来读写TCP数据。<strong>SocketChannel和ServerSocketChannel的区别在于，ServerSocketChannel用于服务器编程，可以使用accept()函数监听客户端（SocketChannel）的连接请求。</strong></p>
<p>java.nio中的Channel既可以读，也可以写，而java.io中的Stream要么只能读，要么只能写，这也是java.nio比java.io类少的另一个重要原因。除此之外，Channel的设计也利用了“组合优于继承”的设计思想。 java.nio中包含大量的Channel接口，每个接口定义了一种功能。每个Channel类通过实现不同的接口组合，来支持不同的功能组合。如下图所示。其中，FileChannel实现了3个接口，支持3种不同的功能。<br><img src="/2023/06/12/xzg-program-beauty-20/1.png" alt="java.nio.png"></p>
<p><strong>Channel有两种运行模式：阻塞模式和非阻塞模式。</strong>其中，FileChannel只支持阻塞模式。DatagramChannel、SocketChannel、ServerSocketChannel支持阻塞和非阻塞两种模式，默认为阻塞模式。我们可以调用configureBlocking(false)函数将其设置为非阻塞模式。<strong>非阻塞Channel一般会配合Selector，用于实现多路复用I/O模型。</strong></p>
<p>那么，到底什么是阻塞模式？什么是非阻塞模式呢？</p>
<p><strong>线程在调用read()或write()函数对I/O进行读写时，如果I/O不可读或者不可写（待会解释这两个的意思），那么，在阻塞模式下，read()或write()函数会等待，直到读取到数据或者写入完成时才会返回，在非阻塞模式下，read()或write()函数会直接返回，并报告读取或写入未成功。</strong></p>
<p>上一节，我们提到，<strong>在操作系统层面，主要的I/O有：文件、网络、标准输入输出、管道。文件是没有非阻塞模式的。毕竟文件不存在不可读和不可写的情况。网络、标准输入输出、管道都存在阻塞和非阻塞两种模式。</strong>我们拿最常用的网络来举例。</p>
<p><strong>一般来讲，应用程序调用read()或write()函数读取或写入数据，数据会在应用程序缓冲区、内核缓冲区、I/O设备这三者之间拷贝传递。</strong>如下图所示。关于这点，我们下一节详细介绍。<br><img src="/2023/06/12/xzg-program-beauty-20/2.png" alt="copy.png"></p>
<p><strong>当调用read()函数时，如果内核读缓冲区中没有数据可读，比如网络连接的对方此时并未发送数据过来，那么，在阻塞模式下，read()函数会等待，直到对方发送数据过来，内核读缓冲区中有数据可读时，才会将内核读缓冲区中的数据拷贝到应用程序缓存中，然后read()函数才返回，在非阻塞模式下，read()函数会直接返回，并报告读取情况。</strong></p>
<p><strong>当调用write()函数时，如果内核写缓冲区中没有足够空间承载应用程序缓存中的数据，比如网络不好，原来的数据还没来得及发送出去，那么，在阻塞模式下，write()函数会等待，直到内核写缓冲区中有足够空间，应用程序缓冲区中的数据全部写入内核写缓冲区，write()函数才会返回。在非阻塞模式下，write()函数会能写多少写多少，即便还有一部分未能写入内核写缓冲区，也不会等待，直接返回，并报告写入情况。</strong></p>
<p><strong>实际上，除了read()和write()函数有阻塞和非阻塞这两种模式之外，ServerSocketChannel中用于服务器接收客户端的连接的accpet()函数，也有阻塞和非阻塞两种模式。在阻塞模式下，调用accept()函数会等待，直到有客户端连接到来才返回。在非阻塞模式下，调用accept()函数，如果没有客户端连接到来，会直接返回。</strong></p>
<h4 id="3）Selector"><a href="#3）Selector" class="headerlink" title="3）Selector"></a>3）Selector</h4><p>在网络编程中，使用非阻塞模式，线程需要通过while循环，不停轮询调用read()、write()、accept()函数，查看是否有数据可读、是否可写、是否有客户端连接到来。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">SocketChannel clientChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (clientChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">  clientChannel = serverChannel.accept();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (clientChannel.read(buffer) == -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">buffer.flip(); <span class="comment">//将buffer从&quot;用于读&quot;变成&quot;用于写&quot;</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">  clientChannel.write(buffer); <span class="comment">// echo,读了啥就写啥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上述代码充斥着while轮询，显然不够优雅。多路复用I/O模型便用来解决这个问题。</p>
<p><strong>多路复用I/O模型是网络编程中非常经典的一种I/O模型。为了实现多路复用I/O模型，Unix提供了epoll库，Windows提供了iocp库，BSD提供了kequeue库…Java作为一种跨平台语言，对不同操作系统的实现方式进行了封装，提供了统一的Selector。</strong></p>
<p><strong>我们可以将需要监听的Channel，调用register()函数，注册到Selector中。Selector底层会通过轮询的方式，查看哪些Channel可读、可写、可连接等，并将其返回处理。</strong>关于Selector的使用示例代码，我们在接下来的「Java I/O模型」小节中给出。</p>
<h4 id="4）异步Channel"><a href="#4）异步Channel" class="headerlink" title="4）异步Channel"></a>4）异步Channel</h4><p>尽管使用Selector可以避免程序员自己手写轮询代码，但是Selector底层仍然依赖轮询来实现。在JDK7中，java.nio类库做了升级，引入了支持异步模式的Channel，主要包括：AsynchronousFileChannel、AsynchronousSocketChannel、AsynchronousServerSocketChannel。而前面讲到的Channel都是同步模式的。</p>
<blockquote>
<p>那么，什么是同步模式？什么是异步模式呢？同步和异步这两个概念，跟阻塞和非阻塞又是否有联系呢？我们通过一个生活中的例子来给你形象解释一下。<br>假设你去一家餐厅就餐，因为就餐的人太多，需要取号等位。取号之后，如果你站在餐厅门口一直等待被叫号，啥都不干，那么，这就是阻塞模式。如果你先去商场里逛一逛，一会回来看一下有没有轮到你，没有就继续再去逛，那么，这就是非阻塞模式。<br>如果你在取号时，登记了手机号码，那么你就可以放心去逛商场了，等叫到你的号时，服务员会打电话通知你，这就是异步模式。相反，如果需要自己去查看有没有轮到你，不管是阻塞模式还是非阻塞模式，都是同步模式。<br>实际上，异步模式下也可以有阻塞和非阻塞之分。如果在没有收到通知时，尽管你可以去干其他事情，但你偏偏就啥都不干，就站在门口等着被叫号，那么这就是阻塞异步模式，如果你选择享受通知服务，去干其他事情，那么这就是非阻塞异步模式。</p>
</blockquote>
<p>从上面的解释，我们可以发现，同步、异步跟阻塞、非阻塞没有直接关系。</p>
<p><strong>在异步模式下，Channel不再注册到Selector，而是注册到操作系统内核中，由内核来通知某个Channel可读、可写或可连接，java.nio收到通知之后，为了不阻塞主线程，会使用线程池去执行事先注册的回调函数。</strong>关于异步模式的用法，我们也是在「Java I/O模型」小节中展示。</p>
<h4 id="二、Java-IO模型"><a href="#二、Java-IO模型" class="headerlink" title="二、Java IO模型"></a>二、Java IO模型</h4><p><strong>在面试和工作中，我们经常听到“I/O模型”这个概念。I/O模型一般用于网络编程中，所以，“I/O模型”的全称是“网络I/O模型”。</strong>除此之外，I/O模型多数都用来指导服务器开发。相比服务器开发，客户端开发不需要处理多个并发连接的情况，往往会简单一些，也就不需要这些复杂的模型。</p>
<p>Java中常被提及的I/O模型有三个：阻塞I/O模型（BIO）、非阻塞I/O模型（NIO）、异步I/O模型（AIO）。我们依次看下这3种常见的I/O模型。</p>
<h4 id="1）阻塞I-O模型（BIO）"><a href="#1）阻塞I-O模型（BIO）" class="headerlink" title="1）阻塞I/O模型（BIO）"></a>1）阻塞I/O模型（BIO）</h4><p>前面讲过，I/O访问模式有两种：阻塞模式和非阻塞模式。阻塞I/O模型指的是利用阻塞模式来实现服务器。一般来说，这种模型需要配合多线程来实现。</p>
<p>一般来讲，服务器需要连接大量客户端，因为read()函数是阻塞函数，所以，为了实时接收客户端发来的数据，服务器需要创建大量线程，每个线程负责等待读取（调用read()函数）一个客户端的数据。因为java.io支持阻塞模式，java.nio既支持阻塞模式又支持非阻塞模式，所以，java.io和java.nio都可以实现阻塞I/O模型。我们使用java.io来编写示例代码，如下所示。注意，使用java.io进行网络编程，需要配合java.net类库。比如在下面代码中，Socket、ServerSocket都是java.net包中的类。java.net类库用于管理连接，java.io用于读写数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">    serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// accept()为阻塞函数，直到有连接到来才返回</span></span><br><span class="line">      Socket clientSocket = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 为了每个客户端单独创建一个线程处理</span></span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> ClientHandler(clientSocket)).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//持续接收客户端发来的数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// read()为阻塞函数，直到读取到数据再返回</span></span><br><span class="line">          socket.getInputStream().read(data);</span><br><span class="line">          <span class="comment">// write()为阻塞函数，全部写完成才会返回</span></span><br><span class="line">          socket.getOutputStream().write(data); <span class="comment">//echo</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// log and exit</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数。除此之外，因为accept()函数也是阻塞函数，所以也独占一个线程。当连接的客户端非常多时，服务器需要创建大量线程，而每个线程会分配一个线程栈，需要占用一定的内存空间。当线程比较多时，内存资源的消耗就会比较大。大量线程来回切换，也会导致服务器整体处理性能的下降。除此之外，大部分线程可能都阻塞在read()函数上，等待数据的到来，什么都不做但又要白白占用内存和线程资源，非常浪费。</strong></p>
<h4 id="2）非阻塞I-O模型（NIO）"><a href="#2）非阻塞I-O模型（NIO）" class="headerlink" title="2）非阻塞I/O模型（NIO）"></a>2）非阻塞I/O模型（NIO）</h4><p><strong>非阻塞I/O模型指的是利用非阻塞模式来开发服务器，一般需要配合Selector多路复用器，所以，这种模型也叫做多路复用I/O模型。</strong>不过，这两种叫法都有点以偏概全，所以，你不必太纠结于名称，知道这种模型具体是如何实现的即可。</p>
<p>因为java.io只支持阻塞模式，所以，这种模型只能通过java.nio来实现。非阻塞I/O模型的示例代码如下所示。利用java.nio进行网络编程，也像java.io那样，需要java.net类库的配合，比如代码中的InetSocketAddress就是java.net中的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Selector</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create serverChannel and register to selector</span></span><br><span class="line">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">    serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    serverChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> channelCount = selector.select();</span><br><span class="line">      <span class="keyword">if</span> (channelCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          SelectionKey key = iterator.next();</span><br><span class="line">          <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// create clientChannel and register to selector</span></span><br><span class="line">            SocketChannel clientChannel = serverChannel.accept();</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            SocketChannel clientChannel = (SocketChannel) key.channel();</span><br><span class="line">            clientChannel.read(buffer);</span><br><span class="line">            buffer.flip(); <span class="comment">//从&quot;用于读&quot;变为&quot;用于写&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.hasRemaining()) &#123; <span class="comment">//也可以注册到selector中</span></span><br><span class="line">              clientChannel.write(buffer); <span class="comment">//echo</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear(); <span class="comment">//重复利用</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>在NioEchoServer类中，如果有n个客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作。</strong></p>
<p>如上代码所示，大部分情况下，我们都不需要监听Channel是否可写，毕竟网络写入跟文件写入类似，大部分情况下都不需要等待。只有当写入出现问题时，比如write()函数返回0，表示网络拥塞，此时才需要如下代码所示，将Channel注册到Selector中，等待可写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientChannel.register(selector, SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，并不是所有的Channel都可以注册到Selector中被监听，只有实现了SelectableChannel接口的Channel才可以，比如DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel因为没有实现SelectableChannel，并且不支持非阻塞模式，所以，无法被Selector监听。</p>
<p><em><strong>多路复用I/O模型只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。不过，这种模型依然存在问题。如果某些clientChannel读写的数据量比较大，或者逻辑操作比较复杂，耗时比较久，因为所有的工作都在一个线程中完成，那么其他clientChannel便迟迟得不到处理，最终的效果就是，服务器响应客户端的延迟很大。</strong></em></p>
<p><strong>为了解决这个问题，我们可以引入线程池，对于Selector检测到有数据可读的clientChannel，我们从线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。我们知道，阻塞I/O模型也用到了多线程，跟这里的区别在于，不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高。</strong></p>
<h4 id="3）异步I-O模型（AIO）"><a href="#3）异步I-O模型（AIO）" class="headerlink" title="3）异步I/O模型（AIO）"></a>3）异步I/O模型（AIO）</h4><p>实际上，上述问题使用java.nio的异步Channel实现起来更加优雅。如下代码所示。通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioEchoServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();</span><br><span class="line">    serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1192</span>));</span><br><span class="line">    <span class="comment">// 异步accept()</span></span><br><span class="line">    serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span> AcceptCompletionHandler(serverChannel));</span><br><span class="line">    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptCompletionHandler</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcceptCompletionHandler</span><span class="params">(AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.serverChannel = serverChannel; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel clientChannel, Object attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// in order to accept other client&#x27;s connections</span></span><br><span class="line">      serverChannel.accept(attachment, <span class="keyword">this</span>);</span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 异步read()</span></span><br><span class="line">      clientChannel.read(buffer, buffer, <span class="keyword">new</span> ReadCompletionHandler(clientChannel)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// log exc exception</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCompletionHandler</span> </span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel clientChannel;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCompletionHandler</span><span class="params">(AsynchronousSocketChannel clientChannel)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.clientChannel = clientChannel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">      buffer.flip();</span><br><span class="line">      <span class="comment">// 异步write()。回调函数为null，写入完成就不用回调了</span></span><br><span class="line">      clientChannel.write(buffer, <span class="keyword">null</span>, <span class="keyword">null</span>); <span class="comment">// echo</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// log exc exception</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实际上，<strong>在平时的开发中，我们一般不会直接使用底层的java.nio类库，而是使用Netty等框架来进行网络编程，这些框架封装了网络编程的复杂性，使用起来更加简单，开发效率更高。</strong>除了以上三种常见的I/O模型之外，实际上，还有更多更加复杂的I/O模型，比如<strong>Netty框架提供的Reactor模型。</strong>关于Netty等网络编程知识，我们就不深入讲解了。毕竟专栏的重点不在这里。</p>
<p>你可能还听过其他I/O模型的分类，比如在《Unix网络编程》一书中，介绍了Unix操作系统的5种I/O模型：阻塞I/O模型、非阻塞I/O模型、多路复用I/O模型、信号驱动I/O模型、异步I/O模型。那么，Unix操作系统下的I/O模型跟Java I/O模型有什么联系呢？</p>
<p><strong>实际上，不同的操作系统会提供不同的I/O模型。Java是一种跨平台语言，为了屏蔽各个操作系统I/O模型的差异，设计了3种新的I/O模型：BIO（阻塞I/O）、NIO（非阻塞I/O）、AIO（异步I/O），并且提供了I/O类库来支持这3种I/O模型的代码实现。而Java的I/O类库底层需要依赖操作系统的I/O接口（专业名称为系统调用）来实现，因此，从本质上来讲，Java I/O模型只是对操作系统I/O模型的重新封装。</strong></p>
<h2 id="三、对比java-io与java-nio"><a href="#三、对比java-io与java-nio" class="headerlink" title="三、对比java.io与java.nio"></a>三、对比java.io与java.nio</h2><p>在功能上来看，java.nio完全可以替代java.io，那么，在平时开发中，我们是不是应该首选java.nio呢？在新开发的项目中，是不是就不应该使用老的java.io呢？</p>
<p>实际上，在某些情况下，我们确实必须使用java.nio，比如网络编程。尽管使用java.io，并配合java.net，也可以进行网络编程，但java.io只支持阻塞模式，只能实现阻塞I/O模型，对于大部分网络编程来说，都是不够的。而java.nio提供了非阻塞模式、Selector多路复用器、异步模式，能够实现更加高性能的网络模型，比如非阻塞I/O模型、异步I/O模型。相比java.io而言，在网络编程方面，java.nio的优势更加明显。</p>
<p>但是，在某些情况下，到底使用java.io还是java.nio，会有一些争论，比如文件读写。前面提到，文件读写只支持阻塞模式，因此，使用java.io或java.nio都可以。有些人认为，使用java.io进行文件读写，代码编写更加简单。有些人则认为，java.nio的文件读写功能更加丰富。我个人认为，既然有争论，就说明两者没有哪个更有绝对优势，不然也就不会有争论了。因此，对于使用java.io还是java.nio进行文件读写，按照你的喜好或者团队的编程习惯来选择就好。</p>
<p><strong>总结一下的话，对于网络编程，我们首选java.nio，对于文件读写，java.io和java.nio都可以。</strong></p>
<p>四、课后思考题<br>java.io提供了BufferedInputStream、BufferedOutputStream，用于支持缓存的文件读写，那么，类似功能，java.nio是如何实现的呢？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/11/xzg-program-beauty-24/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/11/xzg-program-beauty-24/" class="post-title-link" itemprop="url">24.反射：为什么通过反射创建对象要比new创建对象慢</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-11 20:36:45" itemprop="dateCreated datePublished" datetime="2023-06-11T20:36:45+08:00">2023-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%8E%8B%E4%BA%89%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">编程之美（王争）</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>尽管在平时的业务开发中，我们很少会用到反射、注解、动态代理这些比较高级的Java语法，但是，在框架开发中，它们却非常常用，可以说是支撑框架开发的核心技术。比如，我们常用的Spring框架，其中的IOC就是基于反射实现的，AOP就是基于动态代理实现的，配置就是基于注解实现的。<br>尽管在业务开发中，我们不常用到它们，但是，要想<br>阅读开源框架的源码，掌握这些技术是必不可少的。接下来，我们就来讲讲反射、注解、动态代理。本节我们重点讲下反射。</p>
<h2 id="一、反射的作用"><a href="#一、反射的作用" class="headerlink" title="一、反射的作用"></a>一、反射的作用</h2><p>反射的作用主要有3个：创建对象、执行方法、获取类信息。</p>
<h4 id="1）创建对象"><a href="#1）创建对象" class="headerlink" title="1）创建对象"></a>1）创建对象</h4><p>在编写代码的时候，我们通过new语句用来创建对象。代码中有多少条new语句，JVM就会创建多少个对象。但是，并不是所有的对象的创建，都是在编写代码时事先知道的。如果在代码的运行过程中，我们需要根据配置、输入、执行结果等，动态创建一些额外的对象，这个时候我们无法使用new语句了。<strong>我们需要有一种新的方法，在程序运行期间，动态地告知JVM去创建某个类的对象。这种方法就是反射。</strong><br>不管是new还是反射，对象的创建都是在运行时进行的，不过申请创建对象的时机却是不同的。通过new来创建对象，其创建对象的需求是在代码编写时确定的，<strong>而通过反射来创建对象，其创建对象的需求是在运行时是确定的。</strong>因此，我们把通过new语句的方式来创建对象叫做静态申请对象创建，我们把通过反射的方式来创建对象叫做动态申请对象创建。</p>
<h4 id="2）执行方法"><a href="#2）执行方法" class="headerlink" title="2）执行方法"></a>2）执行方法</h4><p><strong>除了在程序运行期间动态申请对象创建之外，程序还可以动态申请执行方法。跟创建对象类似，尽管执行方法总是发生在运行时，但是申请执行方法的时机却可以不同</strong>。一般来讲，程序会执行哪些方法，在代码编写时就确定了。但是，如果在运行时，额外申请新的要执行的方法，这个时候，就只能依靠反射来实现了。稍后讲到的动态代理，实际上，就是依赖反射可以动态执行方法来实现的。<br><strong>不管是反射创建对象，还是执行方法，实际上，跟普通的对象创建和方法执行，本质上没有太大区别。只不过是告知JVM的时机和方式不同而已。</strong></p>
<h4 id="3）获取类信息"><a href="#3）获取类信息" class="headerlink" title="3）获取类信息"></a>3）获取类信息</h4><p>除了创建对象、执行方法之外，反射还能够获取对象的类信息，包括类中的构造函数、方法、成员变量等信息。稍后要讲到的注解，实际上，就是依赖反射的这个作用。</p>
<h2 id="二、反射的用法"><a href="#二、反射的用法" class="headerlink" title="二、反射的用法"></a>二、反射的用法</h2><p>实现上述反射的这3个作用需要4个类：Class、Method、Constructor、Field，这也是反射所涉及的核心类，接下来，我们依次来介绍一下这4个类。</p>
<h4 id="1）Class"><a href="#1）Class" class="headerlink" title="1）Class"></a>1）Class</h4><p>Class跟关键字class容易混淆，Class实际上跟Person、String等一样，也是一个类，只是其比较特殊，存储的是类的信息。<br>Class类提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等。我们将重要的常用到方法罗列如下，当然，你也可以查看java.lang.Class源码来了解更多细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)；</span><br><span class="line"><span class="comment">// 获取类名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSimpleName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取package信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">getPackage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取接口信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class&lt;?&gt;[] <span class="title">getInterfaces</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员的变量，包含私有成员变量，不包含父类成员变量</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量，只包含公有成员变量，包含父类成员变量</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的方法，包括私有方法，不包含父类方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的方法，只包含公有方法，包含父类方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数，只包含公共构造函数</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getConstructors();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数，包含私有构造函数</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类上的注解</span></span><br><span class="line"><span class="keyword">public</span> Annotation[] getAnnotations();</span><br></pre></td></tr></table></figure>

<p>除了获取类信息的方法之外，Class类还提供了方法来创建对象，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>一般来讲，我们有以下3种方式来创建Class类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：使用forName()+类名全称</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Student&quot;</span>);</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">Class&lt;?&gt; clazz = Student.class;</span><br><span class="line">Class&lt;Student&gt; clazz = Student.class;</span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">Class&lt;?&gt; clazz = student.getClass();</span><br></pre></td></tr></table></figure>

<p>从上述代码，我们可以发现，<strong>实际上，Class类是一个<code>泛型类</code>。如果我们无法提前知道获取的类的信息是哪个类的，那么我们就可以使用<code>?</code>通配符来具体化泛型类。如果我们可以明确获取的是哪个类的信息，那么我们可以直接使用具体类型具体化泛型类。</strong>不过，方法一、方法三并不能像下面这样具体化Class类，因为forName()函数和getClass()函数在函数定义中的返回值本来就是Class<?>，Class<?>类型的返回值不能赋值给<code>Class&lt;Student&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不正确的使用方法</span></span><br><span class="line">Class&lt;Student&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Student&quot;</span>);</span><br><span class="line">Class&lt;Student&gt; clazz = student.getClass(); </span><br></pre></td></tr></table></figure>

<h4 id="2）Constructor"><a href="#2）Constructor" class="headerlink" title="2）Constructor"></a>2）Constructor</h4><p>Constructor用来存储构造函数的信息。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所包含的信息</span></span><br><span class="line"><span class="comment">// 在Constructor中，以下信息都有相应的方法来获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          exceptionTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String    signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConstructorRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              parameterAnnotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Constructor类也提供了一些方法来获取以上信息，这里我们就不一一列举了，你可以查看java.lang.reflect.Constructor类源码去自行了解。这里介绍一下Constructor类中常用的newInstance()方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过newInstance()方法，我们可以调用构造函数来创建对象。你应该也已经注意到，Class类中也包含newInstance()方法。区别在于，Class类上的newInstance()方法只能通过无参构造函数来创建对象，如果想要使用有参构造函数创建对象，我们需要先获取对应的Constructor类对象，然后再调用其上的newInstance()方法。稍后会有代码示例。</p>
<h4 id="3）Method"><a href="#3）Method" class="headerlink" title="3）Method"></a>3）Method</h4><p>Method存储的是方法的信息。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="comment">// This is guaranteed to be interned by the VM in the 1.4</span></span><br><span class="line">    <span class="comment">// reflection implementation</span></span><br><span class="line">    <span class="keyword">private</span> String              name;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            returnType;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[]          exceptionTypes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String              signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> MethodRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              parameterAnnotations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotationDefault;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MethodAccessor methodAccessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，Method类也提供了大量方法来获取以上信息，这里我们也不一一罗列了。感兴趣的话，你可以查看java.lang.reflect.Method类的源码。这里我们介绍一下常用的invoke()方法，如下所示，调用此方法可以执行对应方法。稍后会有代码示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="4）Field"><a href="#4）Field" class="headerlink" title="4）Field"></a>4）Field</h4><p>Filed用来存储成员变量的信息，如下所示。同样，<br>Field类也提供了大量方法来获取以下信息，这里我们也不一一罗列了。感兴趣的话，你可以查看java.lang.reflect.Field类的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">extends</span> <span class="title">AccessibleObject</span> <span class="keyword">implements</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            clazz;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 slot;</span><br><span class="line">    <span class="comment">// This is guaranteed to be interned by the VM in the 1.4</span></span><br><span class="line">    <span class="comment">// reflection implementation</span></span><br><span class="line">    <span class="keyword">private</span> String              name;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;            type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>                 modifiers;</span><br><span class="line">    <span class="comment">// Generics and annotations support</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String    signature;</span><br><span class="line">    <span class="comment">// generic info repository; lazily initialized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> FieldRepository genericInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[]              annotations;</span><br><span class="line">    <span class="comment">// Cached field accessor created without override</span></span><br><span class="line">    <span class="keyword">private</span> FieldAccessor fieldAccessor;</span><br><span class="line">    <span class="comment">// Cached field accessor created with override</span></span><br><span class="line">    <span class="keyword">private</span> FieldAccessor overrideFieldAccessor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、反射攻击"><a href="#三、反射攻击" class="headerlink" title="三、反射攻击"></a>三、反射攻击</h2><p>上面罗列了Class、Constructor、Method、Field中的常用方法，<strong>实际上，在Constructor、Method、Field类中，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限，</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>

<p>利用这个方法，我们可以将私有的构造函数、方法、成员变量设置为可访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.Demo$Person&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person pobj = (Person) constructor.newInstance();</span><br><span class="line">    Field field = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    field.set(pobj, <span class="number">10</span>);</span><br><span class="line">    Method method = clazz.getDeclaredMethod(<span class="string">&quot;print&quot;</span>);</span><br><span class="line">    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    method.invoke(pobj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在《设计模式之美》中，我们有讲到单例模式。单例模式只允许单例类实例化一个对象。单例模式有很多实现方式，其中一种实现方法如下所示，我们通过将构造函数设置为私有的，来禁止外部代码创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123; <span class="comment">//单例</span></span><br><span class="line">  <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，通过反射，我们仍然可以绕开代码中的访问权限控制，调用私有的构造函数，实例化新的对象，如下所示，<strong>这种打破单例类只能实例化一个对象的限制的情况，就叫做反射攻击。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.wz.demo.IdGenerator&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    IdGenerator idGenerator = (IdGenerator) constructor.newInstance();</span><br><span class="line">    System.out.println(idGenerator.getId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、反射的应用"><a href="#四、反射的应用" class="headerlink" title="四、反射的应用"></a>四、反射的应用</h2><p>在《设计模式之美》中，我们讲到，Spring可以作为一种IOC容器（也叫做DI容器，依赖注入容器），<strong>实际上，IOC容器就是一个大的工厂类，负责在程序启动时，根据配置，事先创建好对象。</strong>当应用程序需要使用某个对象时，直接从容器中获取即可。</p>
<p><strong>在普通的工厂模式中，工厂类要创建哪个对象是事先确定好的，并且是写死在工厂类代码中的。作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，IOC容器事先并不知道应用会创建哪些对象，不可能把某个应用要创建的对象写死在框架代码中。应用程序通过配置文件，定义好需要创建的对象。IOC容器读取配置文件，并将每个要创建的对象信息，解析为一定的内存结构：BeanDefinition，然后根据BeanDefinition中的信息，通过反射创建对象。</strong><br>对于IOC容器的完整实现，我们在《设计模式之美》中有详细介绍。这里，我们重点展示跟反射有关的部分，也就是根据BeanDefinition创建对象。代码如下所示。在下列代码中，我们使用Class.forName()来创建对象，对于无参构造，我们使用Class对象上的newInstance()来创建对象，对于有参构造，我们先获取对应的Constructor对象，然后调用Constructor对象上的newInstance()来创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects  = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="keyword">false</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">        createBean(beanDefinition);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span>&#123;</span><br><span class="line">    BeanDefinition beanDefinition = beanDefinitions.get(beanId);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">&quot;Bean is not defined: &quot;</span> + beanId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class beanClass = Class.forName(beanDefinition.getClassName());</span><br><span class="line">      List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">      <span class="keyword">if</span> (args.isEmpty()) &#123;</span><br><span class="line">        bean = beanClass.newInstance();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Class[] argClasses = <span class="keyword">new</span> Class[args.size()];</span><br><span class="line">        Object[] argObjects = <span class="keyword">new</span> Object[args.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.size(); ++i) &#123;</span><br><span class="line">          BeanDefinition.ConstructorArg arg = args.get(i);</span><br><span class="line">          <span class="keyword">if</span> (!arg.getIsRef()) &#123;</span><br><span class="line">            argClasses[i] = arg.getType();</span><br><span class="line">            argObjects[i] = arg.getArg();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());</span><br><span class="line">            <span class="keyword">if</span> (refBeanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(arg.getArg());</span><br><span class="line">            &#125;</span><br><span class="line">            argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">            argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationFailureException(<span class="string">&quot;Create Bean failed: &quot;</span> + beanDefinition.getId(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span> &amp;&amp; beanDefinition.isSingleton()) &#123;</span><br><span class="line">      singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">      <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、反射的原理"><a href="#五、反射的原理" class="headerlink" title="五、反射的原理"></a>五、反射的原理</h2><p>前面我们提到，使用反射来创建对象，跟使用new创建对象，大体的流程是一样，只不过向JVM申请创建对象的方式不同而已。但是，我们还经常听说，使用反射来创建对象，要比使用new创建对象，要慢很多。那这到底又是为什么呢？接下来，我们先做个实验来验证一下情况是否属实。测试代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用new创建对象</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      C c = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">    <span class="comment">// 使用反射创建对象</span></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = C.class;</span><br><span class="line">      Object obj = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行上述代码，得到结果为：通过new创建对象的耗时为3ms，通过反射创建对象的耗时为31ms，差不多10倍的差距。</strong>尽管耗时有10倍的差距，但从耗时的绝对值上来看，通过反射创建1000万个对象，耗时才只有31ms，对于大部分应用程序来说都是可以接受的，<strong>绝大部分情况下，通过反射创建对象都不会是应用程序的性能瓶颈，我们不需要为反射带来的一丢丢性能损耗而担忧。</strong></p>
<p>前面讲到，使用反射还可以动态的执行方法，那么，相比于直接执行方法，使用反射执行方法会不会也很慢呢？为了测试使用反射执行方法的性能，我们对上面的测试代码稍作修改，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24_1</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 普通方法调用</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      c.f();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">    <span class="comment">// 使用反射执行方法</span></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    Class&lt;?&gt; clazz = C.class;</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">      Method method = clazz.getMethod(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">      method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行上述代码，得到的结果为：普通方法调用的耗时为3ms，而使用反射执行方法的耗时为1259ms，有几百倍的差距。这个差距就比较大了。尽管性能差距如此大，但我们也不必为使用反射导致方法执行性能下降而担忧。这是为什么呢？</strong></p>
<p><strong>原因有二。其一是：使用反射执行方法，并不会让方法内部逻辑的执行速度变慢，只是增加了一些额外耗时而已，这部分额外的耗时是固定的，跟方法内部逻辑的复杂程度无关。其二是：1000万次方法调用才耗时1259ms，平均执行一次方法的增加的额外耗时为0.0001259ms，非常小，对于大部分方法来说，特别是一些包含IO操作的方法（比如访问数据库），方法本身内部逻辑执行的耗时远远大于使用反射而额外增加的耗时，因此，在大部分情况下，我们也并不需要担心使用反射执行方法导致的一丢丢性能下降。</strong></p>
<p>那么，相比普通的对象创建和执行，使用反射创建对象和执行方法，增加的额外耗时产生在哪里呢？</p>
<h4 id="1）安全性检查"><a href="#1）安全性检查" class="headerlink" title="1）安全性检查"></a>1）安全性检查</h4><p><strong>对于普通的对象创建和执行，大量的安全性检查，比如传入某个方法的数据类型必须与参数类型匹配、在某个对象上调用某个方法必须确保这个对象有这个方法，这些都是在编译时完成的，不占用运行时间，但是，对于反射，因为其是在运行时才确定创建什么对象、执行什么方法的，所以，安全性检查无法在编译时执行，只能在运行时真正创建创建、执行方法时再完成，那么这就会增加额外的运行时间。</strong></p>
<h4 id="2）类、方法查找"><a href="#2）类、方法查找" class="headerlink" title="2）类、方法查找"></a>2）类、方法查找</h4><p><strong>当我们使用反射创建对象或执行方法时，我们需要通过类名、方法名去查找对应的类或方法，而类名、方法名都是字符串，字符串匹配相对来说比较慢速。而正常情况下，代码经过编译之后，得到的字节码中，每个类和方法都会分配一个对应的编号，保存在常量池中，代码中所有出现类或方法的地方，都会被替换为编号。相比于通过类名、方法名字符串来查找类和方法，通过编号来查找对应的类或方法，显然要快得多。</strong><br>我们再通过一个简单的例子进一步解释一下，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">    f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码经过编译之后，得到的字节码如下所示，其中，常量池（Constant pool）中保存了各个类、方法的编号。类创建通过“new #编码”来实现，方法执行通过“invokespecial #编<br>号”来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">  <span class="title">minor</span> <span class="title">version</span>: 0</span></span><br><span class="line"><span class="class">  <span class="title">major</span> <span class="title">version</span>: 53</span></span><br><span class="line"><span class="class">  <span class="title">flags</span>: (0<span class="title">x0021</span>) <span class="title">ACC_PUBLIC</span>, <span class="title">ACC_SUPER</span></span></span><br><span class="line"><span class="class">  <span class="title">this_class</span>: #2                          // <span class="title">Demo</span></span></span><br><span class="line"><span class="class">  <span class="title">super_class</span>: #5                         // <span class="title">java</span>/<span class="title">lang</span>/<span class="title">Object</span></span></span><br><span class="line"><span class="class">  <span class="title">interfaces</span>: 0, <span class="title">fields</span>: 0, <span class="title">methods</span>: 3, <span class="title">attributes</span>: 1</span></span><br><span class="line"><span class="class"><span class="title">Constant</span> <span class="title">pool</span>:</span></span><br><span class="line"><span class="class">  #1 </span>= Methodref          #<span class="number">5.</span>#<span class="number">15</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">2</span> = Class              #<span class="number">16</span>            <span class="comment">// Demo</span></span><br><span class="line">  #<span class="number">3</span> = Methodref          #<span class="number">2.</span>#<span class="number">15</span>         <span class="comment">// Demo.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">4</span> = Methodref          #<span class="number">2.</span>#<span class="number">17</span>         <span class="comment">// Demo.f:()V</span></span><br><span class="line">  #<span class="number">5</span> = Class              #<span class="number">18</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">8</span> = Utf8               Code</span><br><span class="line">  #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               main</span><br><span class="line">  #<span class="number">11</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">12</span> = Utf8               f</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               Demo.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = Utf8               Demo</span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">12</span>:#<span class="number">7</span>         <span class="comment">// f:()V</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: invokespecial #<span class="number">1</span>     <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class Demo</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">7</span>: astore_1</span><br><span class="line">        <span class="number">8</span>: invokestatic  #<span class="number">4</span>                  <span class="comment">// Method f:()V</span></span><br><span class="line">        <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">11</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>六、课后思考题<br>单例模式有多种实现方式，其他实现方式是否也存在可能被反射攻击的问题呢？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/11/xzg-program-beauty-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/11/xzg-program-beauty-01/" class="post-title-link" itemprop="url">1.程序的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-11 19:44:56" itemprop="dateCreated datePublished" datetime="2023-06-11T19:44:56+08:00">2023-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%8E%8B%E4%BA%89%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">编程之美（王争）</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本节我们就来探究一下，代码是如何被执行的？在执行过程中，CPU、操作系统和虚拟机都起到了什么作用？</p>
<h2 id="一、解释型、编译型、混合型语言"><a href="#一、解释型、编译型、混合型语言" class="headerlink" title="一、解释型、编译型、混合型语言"></a>一、解释型、编译型、混合型语言</h2><p>要回答上述问题，要从基础开始讲起。</p>
<p>我们知道，CPU只认识机器指令（也叫做CPU指令、机器码），用像Python、C++、Java这样的高级语言编写的代码，需要编译（编译的意思实际上就是“翻译”）为机器指令之后，才能被CPU执行。而不同类型的语言，其编译过程也是不同的，据此我们将其分为三类。</p>
<h4 id="1）编译型语言"><a href="#1）编译型语言" class="headerlink" title="1）编译型语言"></a>1）编译型语言</h4><p><strong>对于类似C++这样的编译型语言，代码会事先被编译成机器指令（可执行文件），然后再一股脑儿交给CPU来执行。在执行时，CPU面对是已经编译好的机器指令，直接逐条执行即可，执行效率比较高。</strong>但因为每种类型的CPU（比如Intel、ARM等<br>）支持的CPU指令集不同，并且程序还有可能调用操作系统提供的API，所以，编译之后的可执行文件<strong>只能在特定的操作系统和机器上执行</strong>，换一种操作系统或机器，编译之后的可执行文件就无法执行了。</p>
<h4 id="2）解释型语言"><a href="#2）解释型语言" class="headerlink" title="2）解释型语言"></a>2）解释型语言</h4><p>对于类似Python这样的解释型语言，代码并不会被事先编译成机器指令，而是在执行的过程中，<strong>由Python虚拟机（也叫做解释器）逐条取出程序中的代码，编译成机器指令，交由CPU执行，完成之后，再取出下一条代码，重复上述的编译、执行过程。</strong>这种一边编译一边执行的过程，叫做解释执行。解释型语言相对于编译型语言，执行速度会慢一些。因为程序是在执行的过程中一边编译一边执行的，所以，程序整体的执行时间包含了程序编译的时间。不过，使用解释性语言编写的代码，可移植性更好。<br>程序在执行的过程中，虚拟机可以根据当前所在机器的CPU类型和操作系统类型，翻译成不同的CPU指令。这样，同一份代码就可以运行在不同类型的机器和不同类型的操作系统上。这就是常听到的“一次编写，多处运行”。</p>
<h4 id="3）混合型语言"><a href="#3）混合型语言" class="headerlink" title="3）混合型语言"></a>3）混合型语言</h4><p>Java语言比较特殊，它属于混合型语言，既包含编译执行也包含解释执行。<strong>Java编译器会先将代码（.java文件）编译成字节码（.class文件）而非机器码，字节码算是Java代码的一种中间状态，其跟平台无关，但又可以快速地被翻译成机器码。编译之后的字节码在执行时，仍然是解释执行的，也就是逐行读出字节码，然后翻译成机器码，再交给CPU执行。</strong>只不过，从字节码到机器码的翻译过程，比从高级语言到机器码的翻译过程，耗时要少。这样既保证了Java代码的可移植性（同一份代码可以运行在不同的CPU和操作系统上）又避免了解释执行效率低的问题。</p>
<p><strong>实际上，在解释执行时，也存在编译执行。Java虚拟机会将热点字节码（反复多次执行的代码，类似缓存中的热点数据），编译成机器码缓存起来，以供反复执行，这样就避免了热点<br>字节码反复编译，进一步节省了解释执行的时间。这就是著名的JIT编译（Just In Time Compile，即时编译），</strong>这部分内容会在专栏的第三部分中详细讲解，这里就暂不展开。</p>
<h2 id="二、CPU、操作系统、虚拟机"><a href="#二、CPU、操作系统、虚拟机" class="headerlink" title="二、CPU、操作系统、虚拟机"></a>二、CPU、操作系统、虚拟机</h2><p>上面反复提到了CPU、操作系统、虚拟机，现在，我们就来看下它们在程序的执行过程中，扮演了什么角色。CPU的工作非常明确，用来执行编译好的机器指令，我们重点看下操作系统和虚拟机。</p>
<h4 id="1）操作系统在程序执行中的作用"><a href="#1）操作系统在程序执行中的作用" class="headerlink" title="1）操作系统在程序执行中的作用"></a>1）操作系统在程序执行中的作用</h4><p>早期的计算机还没有高级语言和操作系统，程序员用机器指令编写的代码，通过纸带打卡方式记录下来，传输给计算机（可以理解为CPU）直接执行。</p>
<p>随着硬件资源越来越丰富，计算机中开始集成各种硬件设备，比如内存、硬盘、各种输入输出（键盘、鼠标、显示器等），并且，人们希望多个程序能在计算机中并发执行（比如听歌的同时还能打字），于是，操作系统就诞生了。</p>
<p>操作系统用来管理硬件资源和调度程序的执行。打个比如，CPU等硬件就好比车间中的机器，工人就像操作系统，一个个程序就像一个个待执行的任务。工人（操作系统）调度机器（CPU等硬件）来执行各个任务（程序）。</p>
<p>除此之外，操作系统还担当了类库的作用。对于通用的功能代码，比如读写硬盘等，没必要在每个程序中都从零编写一遍。操作系统将这些通用的功能代码，封装成API（专业名称叫做系统调用），供我们在编写应用程序时直接调用。也就是说，在应用程序的执行过程中，CPU可能会跳转去执行操作系统中的某段代码。当然，这段代码肯定是已经编译好的机器指令。</p>
<h4 id="2）虚拟机在程序执行中的作用"><a href="#2）虚拟机在程序执行中的作用" class="headerlink" title="2）虚拟机在程序执行中的作用"></a>2）虚拟机在程序执行中的作用</h4><p>我们先下来对比一下，C++代码、Python代码、Java代码编译和执行的命令。如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// C++</span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ helloword.cpp -o helloworld</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./helloword</span></span><br><span class="line"></span><br><span class="line">// Python</span><br><span class="line"><span class="meta">$</span><span class="bash"> python helloworld.py</span></span><br><span class="line"></span><br><span class="line">// Java</span><br><span class="line"><span class="meta">$</span><span class="bash"> javac HelloWorld.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java HelloWorld</span></span><br></pre></td></tr></table></figure>
<p>仔细观察上述命令行的区别，我们可以看出，C++编译之后的代码直接就可以执行，而Python和Java代码的执行，需要依赖其他程序，也就是虚拟机，表现在命令行中就是前面有python、java字样。</p>
<p>使用解释型和混合型语言编写的代码，执行过程都需要虚拟机的参与。实际上，虚拟机本身也可以看做一个程序，而且它已经是CPU可以执行的机器指令了。程序员编写的代码相当于嵌套在虚拟机程序中一个插件（或者功能模块），只不过，它跟虚拟机本身的代码有点不同，无法直接交给CPU执行。虚拟机将字节码翻译成CPU指令，放到固定的内存位置，再通过修改CPU寄存器中存储的地址的方式，引导CPU执行这块内存中存储的CPU指令（关于这一部分，我们待会会详细讲解）。</p>
<p>如果你是一名经验丰富的Java工程师，不知道你有没有感觉到，虚拟机的这套解释执行的机制，跟Java的反射语法异曲同工，反射是在代码的执行过程中，将字符串（类名、方法名等）转化成代码之后再被执行。而虚拟机的解释执行是将字节码（也可以看做是字符串）转化成CPU指令再执行。</p>
<p>站在操作系统和CPU的角度，<strong>Java程序编译之后的字节码跟虚拟机合并在一起，才算是一个完整的程序，才相当于C++编译之后的可执行文件。CPU在执行程序员编写的代码的同时，也在执行虚拟机代码。而且是先执行虚拟机代码，然后才是引导执行程序员编写的代码。</strong></p>
<h2 id="三、CPU指令、汇编语言、字节码"><a href="#三、CPU指令、汇编语言、字节码" class="headerlink" title="三、CPU指令、汇编语言、字节码"></a>三、CPU指令、汇编语言、字节码</h2><p>前面反复提到CPU指令、字节码，估计你对此会很好奇，它们到底长什么样子。现在，我们就来具体看下。不过，提到CPU指令，免不了要讲一下汇编语言，所以，接下来，我们也会一并讲一下汇编语言。</p>
<h4 id="1）CPU指令"><a href="#1）CPU指令" class="headerlink" title="1）CPU指令"></a>1）CPU指令</h4><p>前面提到，我们经常说的CPU指令、机器码、机器指令，实际上都是一个东西，就是CPU可以完成的操作。一条CPU指令包含的信息主要有：操作码、地址、数据三种，指明所要执行的操作、数据来源、操作结果去向。</p>
<p>CPU可以完成的所有的操作，叫做指令集。常见的指令集有X86、X86-64、ARM、MIPS等。不同的CPU支持的指令集可能不同（Intel CPU支持的X86指令集，ARM CPU支持指令集ARM）。当然，不同的CPU支持的指令集也可以相同（比如Intel和AMD的CPU都支持X86和X86-64指令集）。同一个CPU也可以支持多种指令集（Intel CPU支持的指令集有X86、X86-64以及其他扩展指令集）。CPU支持的指令集一般都非常庞大，例如Intel CPU支持2000多条指令，可以完成诸多不同类型的操作。</p>
<h4 id="2）汇编语言"><a href="#2）汇编语言" class="headerlink" title="2）汇编语言"></a>2）汇编语言</h4><p>前面提到，在计算机发展的早期，程序员直接使用机器码来编写程序。但是，因为机器码是二进制码，所以，编写起来复杂、可读性也不好。为了解决这个问题，汇编语言就被发明出来了。汇编语言由一组汇编指令构成，汇编指令跟CPU指令一一对应，但汇编指令采用字符串而非二进制数来表示指令，所以，可读性好很多。实际上，CPU指令和汇编指令之间的关系，就类似IP地址和域名之间的关系，IP地址和域名一一对应，域名的可读性比IP地址好。</p>
<p>程序员使用汇编语言编写的代码，需要经过编译，翻译成机器码才能被CPU执行。这个编译过程有个特殊的名称，叫做“汇编”。C/C++语言的编译过程，实际上就包含汇编这一步骤。编译器先将C/C++代码编译成汇编代码，然后再汇编成机器码。</p>
<p>我们拿一段C语言代码来举例，如下所示，看看编译之后的汇编代码长什么样子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// hello.c</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">  int a = 1;</span><br><span class="line">  int b = 2;</span><br><span class="line">  int c = a + b;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码编译成汇编代码，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.s</span></span><br><span class="line"></span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># %bb.0:</span></span></span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp,%rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	movl	$0,-4(%rbp)</span><br><span class="line">	movl	$1,-8(%rbp)</span><br><span class="line">	movl	$2, -12(%rbp)</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	addl	-12(%rbp), %eax</span><br><span class="line">	movl	%eax, -16(%rbp)</span><br><span class="line">	movl	-16(%rbp), %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br></pre></td></tr></table></figure>

<p>有同学可能有疑问，这个汇编代码跟他见过的不大一样，实际上，汇编指令跟CPU指令一一对应，相同指令集对应的汇编指令集都是一样的（比如上面的代码是Intel的CPU支持的X86指令集对应的汇编代码）<br>，只不过语法格式<br>有可能不同。汇编语言主要有两种语法格式，一种是Intel风格的，一种是AT&amp;T风格的。上述汇编代码是AT&amp;T风格，对应的Intel风格如下所示。对比上下两段汇编<br>代码，唯一的区别就是格式不同而已。注意下面这段代码添加了部分注释，汇编中的注释以分号开头。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S -masm=intel hello.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.s</span></span><br><span class="line">_main:                                  ## @main</span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># %bb.0:</span></span></span><br><span class="line">	push	rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset rbp, -16</span><br><span class="line">	mov	rbp, rsp</span><br><span class="line">	.cfi_def_cfa_register rbp</span><br><span class="line">	mov	dword ptr [rbp - 4], 0  ;安全word，没有实际意义</span><br><span class="line">	mov	dword ptr [rbp - 8], 1  ;int a = 1; 存储在栈中rbp-8的位置</span><br><span class="line">	mov	dword ptr [rbp - 12], 2 ;int b = 2; 存储在栈中rpb-12的位置</span><br><span class="line">	mov	eax, dword ptr [rbp - 8] ;a的值累加在寄存器eax上</span><br><span class="line">	add	eax, dword ptr [rbp - 12] ;b的值累加在寄存器eax上</span><br><span class="line">	mov	dword ptr [rbp - 16], eax ;int c = a+b</span><br><span class="line">	mov	eax, dword ptr [rbp - 16] ;return c。返回值通过eax返回给上层。</span><br><span class="line">        ;所以，把c值赋值给eax。因为上一句指令结束之后，</span><br><span class="line">        ;有可能还有其他运算还会用到eax（本程序比较简单，没有其他运算了），</span><br><span class="line">        ;所以eax中的值有可能会被改变，所以程序返回时重新将c值重新赋值给eax。</span><br><span class="line">	pop	rbp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>对于没学习过汇编语言的同学，完全理解上述汇编代码可能比较困难。不过，这里，我们只需要简单了解汇编代码长什么样子，有个直观的认识即可。关于以上汇编代码的具体解释，我们在下一节会讲到。</p>
<h4 id="3）字节码"><a href="#3）字节码" class="headerlink" title="3）字节码"></a>3）字节码</h4><p>我们常说，Java语言是跨平台的，”write once, run anywhere”（一次编写，多处运行）。程序员编写的代码，在不需要任何修改的情况下，就可以运行在不同的平台上（不同的操作系统和CPU）。</p>
<p><strong>有人认为，Java语言之所以能跨平台，是字节码的功劳。因为字节码跟平台无关，我们在一个平台上编译得到的字节码，可以运行在其他平台上。实际上，这样的观点是不确切的。毕竟没有字节码的解释型语言也可以跨平台。字节码诞生的目的是，克服解释型语言解释执行速度慢的缺点（字节码是介于高级语言和机器码之间的形态，比高级语言解释执行更快）。字节码跟平台无关，是为了让Java语言保留解释型语言跨平台的优点，而不是促使Java语言跨平台的最根本原因。这一点要搞清楚。之所以Java语言能做到跨平台，最根本原是有虚拟机的存在。</strong></p>
<p><strong>Java代码跟平台无关，字节码跟平台无关，在编译执行过程中，总要有一个环节跟平台有关，不然，跟平台有关的、最终可以被CPU执行的机器码从何而来。</strong>俗话说的好，哪有什么岁月静好，只是有人帮你负重前行。跟平台有关的环节就是解释执行环节，而这个环节的主导者就是虚拟机。</p>
<p>虚拟机是已经编译好的可以被CPU执行的机器码，而机器码又是跟平台有关的，因此虚拟机必须跟平台有关。这也是为什么在不同的平台（操作系统和CPU）上，我们需要下载不同的Java虚拟机的原因。</p>
<p>明确了字节码的作用之后，我们通过一个简单的例子，来看下字节码到底长什么样子？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">222222</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，我们使用javac命令编译之后，会得到一个后缀为.class的文件HelloWorld.class，这个文件里保存的一堆二进制码就是字节码。为了方便查看，我们用vi打开转化成16进制格式之后，如下所示：<br><img src="/2023/06/11/xzg-program-beauty-01/1.jpeg"><br>这堆二进制码看似天书，实则有固定格式。下图是class文件的大体格式。例如，前4个字节为魔数（Magic Number），为固定值：0xCAFEBABE，用以表示此文件为字节码文件。紧跟着的4个字节表示编译器的JDK版本（major version和minor version）。当然，还有很多细节无法展示在下图中，在本节中，我们不展开介绍，在后面的内容中，慢慢学习。<br><img src="/2023/06/11/xzg-program-beauty-01/2.png"></p>
<p>显然，这样的二进制文件是交给虚拟机解析的，人类阅读起来非常费劲。我们可以使用javap工具，将class文件解析成适合人类阅读的格式，如下所示。这个过程被叫做反编译。为啥叫做反编译呢？我们可以跟“编译”对比着理解。编译是将贴近人阅读的内容，翻译成贴近机器阅读的内容的过程。对应地，反编译就是将贴近机器阅读的内容，翻译成贴近人阅读的内容的<br>过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ javap -verbose HelloWorld </span><br><span class="line">Classfile /Users/wangzheng/Desktop/HelloWorld.class</span><br><span class="line">  Last modified 2022-3-20; size 291 bytes</span><br><span class="line">  MD5 checksum ea48b76348ad4f0c07a2bf96840e8e00</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class HelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  #1 = Methodref          #4.#13         // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">  #2 = Integer            222222</span><br><span class="line">  #3 = Class              #14            // HelloWorld</span><br><span class="line">  #4 = Class              #15            // java/lang/Object</span><br><span class="line">  #5 = Utf8               &amp;lt;init&amp;gt;</span><br><span class="line">  #6 = Utf8               ()V</span><br><span class="line">  #7 = Utf8               Code</span><br><span class="line">  #8 = Utf8               LineNumberTable</span><br><span class="line">  #9 = Utf8               main</span><br><span class="line">  #10 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #11 = Utf8               SourceFile</span><br><span class="line">  #12 = Utf8               HelloWorld.java</span><br><span class="line">  #13 = NameAndType        #5:#6          // &quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">  #14 = Utf8               HelloWorld</span><br><span class="line">  #15 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1   // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V</span><br><span class="line">        4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">        0: iconst_1</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: ldc           #2     // int 222222</span><br><span class="line">        4: istore_2</span><br><span class="line">        5: iload_1</span><br><span class="line">        6: iload_2</span><br><span class="line">        7: iadd</span><br><span class="line">        8: istore_3</span><br><span class="line">        9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 2</span><br><span class="line">        line 5: 5</span><br><span class="line">        line 6: 9</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure>
<p>不过，你有没有产生过这样的好奇，class文件为什么叫字节码？跟字节（byte）有什么关系呢？实际上，class文件里包含了很多类的信息，而其中main()函数中的代码对应的字节码指令（字节码指令是二进制的，下面的是反编译之后的助记符）<br>只有下面这几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: iconst_1  //把int型1入栈</span><br><span class="line">1: istore_1  //把栈顶int型数值存入第一个变量，也就是a</span><br><span class="line">2: ldc #2    //将常量池中的#2号常量222222入栈</span><br><span class="line">4: istore_2  //把栈顶int型数值存入第二个变量，也就是b</span><br><span class="line">5: iload_1   //把第一个变量的值入栈</span><br><span class="line">6: iload_2   //把第二个变量的值入栈</span><br><span class="line">7: iadd      //将栈顶的两个int型数据相加，结果压入栈</span><br><span class="line">8: istore_3  //将栈顶int型数值存入第三个变量，也就是c</span><br><span class="line">9: return    //程序返回</span><br></pre></td></tr></table></figure>

<p>一条字节码指令有些包含操作码和操作数两部分，有些只包含操作码这一部分。因为操作码长度为一个字节，所以，这种指令格式被叫做字节码。从另一个角度，我们也可以得知，字节码的操作码类型不超过256个（2^8）。相对于CPU指令和汇编指令，字节码指令少很多。这是因为字节码指令相对于CPU指令来说，抽象程度更高。一条字节码指令完成的逻辑，比一条CPU指令完成的逻辑，更加复杂。</p>
<p>Java8的字节码指令集点击此处查看。</p>
<p>顺道提一句，在上述字节码中，a、b两个变量要先入栈中再计算，计算的结果也会放到栈中。为什么Java将c=a+b代码翻译成基于栈来运算的几条字节码呢？关于这一点，我们今天不展开讲解，在本专栏的JVM部分的基于栈的执行引擎中会给出答案。</p>
<h2 id="四、代码是如何被CPU执行的？"><a href="#四、代码是如何被CPU执行的？" class="headerlink" title="四、代码是如何被CPU执行的？"></a>四、代码是如何被CPU执行的？</h2><p>有了以上铺垫，我们最后讲解一下：“代码是如何被CPU执行的”。</p>
<p>不管是使用哪种类型的编程语言（编译型、解释型、混合型）编写的代码，不管经历什么样的编译、解释过程，最终交给CPU执行的都是机器码。</p>
<p><strong>提到CPU，就不得不提寄存器。</strong></p>
<p><strong>我们知道，内存的读写速度比起CPU指令的执行速度要慢很多。从内存中读取32位二进制数据所耗费的时间，相当于CPU执行上百条指令所耗费的时间。所以，CPU在执行指令时，如果依赖内存来存储计算过程中的中间数据，那么，CPU总是在等待读写内存操作的完成，势必非常会影响CPU的计算速度。为了解决这个问题，寄存器就被发明出来了。</strong></p>
<p>寄存器读写速度非常快，能够跟CPU指令执行速度相匹配。所以，数据会先读取到寄存器中再参与计算。<strong>不过，你可能会说了，数据在计算前需要先从内存读取到寄存器，计算之后存储在寄存器中的结果也要写入到内存，寄存器的存在并没有避免掉内存的读写，使用寄存器是不是多此一举呢？实际上，尽管最初数据来源于内存，最后计算结果也要写入内存，但中间的计算过程涉及到一些临时结果的存取，都可以在寄存器中完成，不用跟非常慢速的内存进行交互。顺便说一句，计算机为了提高CPU读写内存的速度，还引入了L1、L2、L3这三级缓存。</strong></p>
<p>寄存器为了做到能让CPU高速访问，硬件设计比较特殊（高成本、高能耗），且与CPU距离很近（相对于内存来说，寄存器直接跟CPU集成在一起），这些也决定了寄存器的个数不会很多。不同的CPU包含的寄存器会有所不同。常见的寄存器有以下几类。</p>
<h4 id="1）通用寄存器：AX，BX，CX，DX"><a href="#1）通用寄存器：AX，BX，CX，DX" class="headerlink" title="1）通用寄存器：AX，BX，CX，DX"></a>1）通用寄存器：AX，BX，CX，DX</h4><p>通用寄存器区别于下面要讲到的特殊寄存器，它们一般用来存储普通数据。AX，BX，CX，DX这四种通用寄存器的用途又有所区别，比如AX是累加器，这些细节我们就不展开讲解了。</p>
<h4 id="2）指针寄存器：BP，SP，SI，DI，IP"><a href="#2）指针寄存器：BP，SP，SI，DI，IP" class="headerlink" title="2）指针寄存器：BP，SP，SI，DI，IP"></a>2）指针寄存器：BP，SP，SI，DI，IP</h4><p>BP（Base Pointer Register）和SP（Stack Pointer Register）是用于存储栈空间地址的寄存器，SP存储栈顶地址，BP比较特殊，一般存储栈中一个栈帧的栈底地址。这一部分在下一节讲解函数的执行过程时再详细讲解。</p>
<p>SI（Source Index Register）源地址寄存器和DI（Destination Index Register）目的地址寄存器，分别用来存储读取和写入数据的内存地址。</p>
<p>IP（Instruction Pointer Register）指令指针寄存器存储下一条将要执行的指令的内存地址（此处的描述不够准确，下文解释）。</p>
<h3 id="3）段寄存器：CS，DS，SS"><a href="#3）段寄存器：CS，DS，SS" class="headerlink" title="3）段寄存器：CS，DS，SS"></a>3）段寄存器：CS，DS，SS</h3><p>程序由一组指令和一堆数据组成。指令存储在某块内存中（这块内存被称为代码段），由CPU逐一读取执行。数据也存储在某块内存中（这块内存被称为数据段）。指令执行的过程中，会操作<br>（读取或写入）这块内存中的数据。</p>
<p>CS（Code Segment Register）代码段地址寄存器存储了代码段的起始地址。上文中讲到，IP寄存器中存储的是下一条将要执行的指令的内存地址，实际上，这样的说法是不准确的。CS和IP两个寄存器中存储的内容如下计算，才能得到一个真正的物理内存地址。<br><code>物理内存地址 = 段地址（如CS） * 16 + 偏移地址（如IP）</code></p>
<p>我们拿8086 CPU（早期16位的X86 CPU）举例解释。8086CPU具有20位地址总线，支持1MB内存的寻址能力。对于16位的IP寄存器，只能存储64K（2^16）个内存地址，一个字节占一个地址，那么只能支持64KB大小内存的寻址。为了扩大寻址能力，计算机使用段地址和偏移地址相结合的方式来确定一个物理内存地址。</p>
<p>对于存储下一条将要执行的指令的地址的寄存器，你或许还听到过PC寄存器（Program Counter egister）这种叫法。实际上，PC寄存器是一个抽象概念，CS寄存器和IP寄存器是具体寄存器的名称。我们可以简单理解为PC寄存器就是CS寄存器和IP寄存器的抽象统称。</p>
<p>DS（Data Segment Register）数据段地址寄存器存储了数据段的起始地址，同理，它跟DI或SI结合才能确定一个数据段中的内存地址。</p>
<p>SS（Stack Segment Register）栈寄存器存储的是栈的起始地址，同理，它跟SP结合才能确定栈顶的内存地址，跟BP结合才能确定栈中某个中间位置的内存地址。有些同学看到这里可能会有疑问，数据段是存储数据的，栈也是存储数据，这两者有什么联系呢？关于这个问题，我们在下一节文章中会讲到。</p>
<h4 id="4）指令寄存器：IR"><a href="#4）指令寄存器：IR" class="headerlink" title="4）指令寄存器：IR"></a>4）指令寄存器：IR</h4><p>IR（Instruction Register）指令寄存器用来存放当前正在执行的指令。指令为一串二进制码，指令译码器需要从指令中解析出操作码和操作地址或操作数。所以，指令需要暂存在指令寄存器中等待译码处理。</p>
<h4 id="5）标志寄存器"><a href="#5）标志寄存器" class="headerlink" title="5）标志寄存器"></a>5）标志寄存器</h4><p>FR（Flag Register）标志寄存器，也叫做程序状态字寄存器（Program Status Word，PSW）,在这个寄存器中的每一个二进制位记录一类状态。比如cmp比较大小指令的运算结果会存储在ZF零标志位或CF进位标志位中。关于更多细节，我们不展开讲解。</p>
<p>以上寄存器都是用来辅助完成CPU的各种指令。注意，以上是16位的寄存器，32位的寄存器名称在对应的16位寄存器名称前加E（例如EAX，EBP，ESP，EIP），64位的寄存器名称在对应的16位寄存器名称前加R（例如RAX，RBP，RSP，RIP）。在下一节中，在讲解编程语言基本语法的底层实现原理时，我们还会提到更多寄存器的使用细节。</p>
<p><strong>了解了CPU指令执行的重要部件寄存器之后，我们来看下CPU执行指令的流程。</strong></p>
<p>对于编译型语言，操作系统会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据放入内存中的数据段，并且设置好各个寄存器的初始值，如DS、CS等。IP寄存器中存储代码段中第一条指令的内存地址相对于CS的偏移地址。</p>
<p>CPU根据PC寄存器（CS寄存器和IP寄存器的总称）存储的内存地址，从对应的内存单元中取出一条CPU指令，放到IR指令寄存器中，然后将IP寄存器中的地址+4（也就是下一条指令在代码段中的偏移地址。内存中的每一个字节都对应一个地址。对于32位CPU，一条指令长度为4字节，下一条指令地址=当前指令地址+4。对于64位CPU，一条指令长度是8字节，下一条指令地址=当前指令地址+8）。一条指令执行完成之后，再通过PC寄存器中的地址，取下一条指令继续执行。循环往复，直到所有的指令都执行完成。</p>
<p>对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段，然后一条一条地被CPU执行。这部分被执行的指令对应的功能，就包括把程序员编写的程序解释成机器码这一功能。虚拟机把解释好的机器码会放到某段内存中，然后将PC寄存器的地址设置为这段内存的首地址，于是，CPU就被虚拟机引导去执行程序员编写的代码了。</p>
<p>在本节中，我们把程序用到的内存，粗略地分为代码段和数据段，对于Java语言来说，其虚拟机对内存还做了更加细致的划分，这部分内容我们在专栏的JVM部分讲解。</p>
<p>五、课后思考题<br>1）在你熟悉的语言中，有哪些是解释型语言？哪些是编译型语言？哪些是混合型语言？<br>2）本节中提到，C/C++代码会先编译成汇编代码，再汇编成机器码，才能被执行。按理来说，汇编代码跟机器码一一对应，为什么C/C++代码不直接编译成机器码呢？先编译成汇编代码不是多此一举吗？<br>注：对于课后思考题，你都可以在专栏中找到答案，比如今天的第二道题目，在本专栏的JVM部分的第一篇文章中就会讲解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/05/16/problems-in-project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/16/problems-in-project/" class="post-title-link" itemprop="url">项目中遇到的问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-05-16 22:11:28" itemprop="dateCreated datePublished" datetime="2023-05-16T22:11:28+08:00">2023-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>问题1：交易记录的表，交易id，日期，金额，买卖方向，债券代码，债券类型。但是某个债券可能会从属于多个债券类型。这时，如何进行分组统计每种债券类型的交易量？比如，我要查询2023-02-23日期，PFB、CGB和RVB对应的交易量分别是多少，由于债券类型之间有交集，所以我们不能简单的<code>select sum(qty) from table1 where biz_date = &#39;2023-02-03&#39; group by bond_type</code>。那么我在设计表的时候就要注意了，多个债券类型如何存储，使用多个字段还是，用MySQL的json还是别的？<br>首先，我们存储的时候，债券类型字段，采用逗号分隔即可，比如：”PFB,CGB,RVB”<br>|order_id|biz_date  |bond_code|qty |bond_type|<br>|1       |2023-02-23|2012.IB  |100 |PFB,CGB,RVB|<br>|2       |2023-02-23|2013.IB  |103 |GB,CGB|<br>|3       |2023-02-23|2023.IB  |190 |LGB,CGB|<br>|4       |2023-02-23|2079.IB  |212 |PFB,RVB|<br>使用sql查询时，查询多个债券类型时，无法使用<code>bond_type in (&#39;PFB&#39;, &#39;RVB&#39;)</code>可以使用MySQL中的<code>find_is_set</code>函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1 <span class="keyword">where</span> (find_in_set(<span class="string">&#x27;PFB&#x27;</span>, bond_type) <span class="keyword">or</span> find_in_set(<span class="string">&#x27;RVB&#x27;</span>, bond_type))</span><br></pre></td></tr></table></figure>
<p>接下来我们需要借助代码，在程序里，将多个债券类型的同一个订单计算多次，准确地计算出每种类型的交易金额</p>
<p>问题2：文本框模糊检索，输入名称的同时，给出提示，比如输入当前的债券发行人，比如输入“银行”，会检索出“上海银行”，“工商银行股份有限公司”等，不能检索出“银河车行”。<br>MySQL中对应的表字段建立全文索引，MySQL5.7支持中文的全文索引，使用全文索引的语法进行查询 <code>MATCH(issuer_name) AGAINST( &#39;银行&#39; IN BOOLEAN MODE)</code></p>
<p>问题3：MySQL的一个表有20个字段，上百万的数据，存储的是交易数据，包括：交易id，日期，金额，买卖方向，债券代码，债券类型，剩余期限。如何在几百毫秒内，计算出最近15天，各种债券类型，各种剩余期限的净成交序列。</p>
<ol>
<li>按照某种类型拆分表</li>
<li>使用MySQL分区表</li>
<li>使用覆盖索引，将所需要查询的字段都罗列出来，一起建立索引，查询时只能包含覆盖索引中的字段，这样索引中的值就可以满足查询要求，不用根据主键回表</li>
</ol>
<p>问题4：40万条数据，进行for循环，耗时10ms以内，如果在里边加上<code>LocalDate.format(DateTimeFormatter.ISO_DATE)</code>，为什么耗时飙升到了2000ms？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 耗时2000+ms</span></span><br><span class="line"><span class="keyword">for</span> (Object obj: objList) &#123;</span><br><span class="line">	LocalDate now = LocalDate.now()</span><br><span class="line">	now.format(DateTimeFormatter.ISO_DATE)</span><br><span class="line">	<span class="comment">// nothing ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要使用<code>LocalDate.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))</code>就大幅提高了效率，结果就成了100+ms</p>
<p>问题5：<code>@KafkaLinstner</code>监听并消费消息，经过计算发送websocket消息到客户端页面。后端有两个实例，同一个账户两个浏览器登录，为什么两个客户端收到的消息不一致？</p>
<ol>
<li>接受到新的消息，经过一些列逻辑判断（是否是新订单，是否旧的订单新发生了变化），将变化更新到Redis集群中，并发送通知。</li>
<li>发送通知时，会遍历当前服务器的所有的session发送通知，并不是广播</li>
<li>两台服务器都收到了kafka消息，但是必然有先后顺序，就会导致先收到消息的一台服务器，进行了Redis集群中订单的update，第二台服务器收到消息后查询Redis发现订单无变化，那么第二台服务器就不会对当前服务器上的建立websocket连接的用户发送通知，然而第一台服务器上的用户却收到了变化，所以两个客户端上显示数据不一致<br>解决方案是：同时使用本地缓存来存储订单信息，同时也在Redis中存储订单信息，如果服务器重启，在重启过程中，读取Redis并更新本地缓存。<br>技术点：</li>
</ol>
<ul>
<li>对每台服务器配置不同的消费者组ID</li>
<li>服务器启动过程中，运行更新本地缓存的代码</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">The Rings</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
