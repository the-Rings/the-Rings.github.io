<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"the-rings.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相对于其他Java基础知识，大部分程序员对Java I&#x2F;O可能没那么了解，毕竟平时的工作很少会编写I&#x2F;O相关的代码，比如读写文件、网络编程等。跟Java容器类似，java.io类库，也非常庞大，如此多类看得眼花缭乱，想要清晰的掌握，需要对其有个系统性的认识。本节，我就带你一块剖析一下java.io类库，给你构建一个java.io类库的全景图。 一、io类库整体结构I&#x2F;O全称为Input&#x2F;Outpu">
<meta property="og:type" content="article">
<meta property="og:title" content="19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？">
<meta property="og:url" content="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/index.html">
<meta property="og:site_name" content="免逸">
<meta property="og:description" content="相对于其他Java基础知识，大部分程序员对Java I&#x2F;O可能没那么了解，毕竟平时的工作很少会编写I&#x2F;O相关的代码，比如读写文件、网络编程等。跟Java容器类似，java.io类库，也非常庞大，如此多类看得眼花缭乱，想要清晰的掌握，需要对其有个系统性的认识。本节，我就带你一块剖析一下java.io类库，给你构建一个java.io类库的全景图。 一、io类库整体结构I&#x2F;O全称为Input&#x2F;Outpu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/1.png">
<meta property="article:published_time" content="2023-06-12T10:47:57.000Z">
<meta property="article:modified_time" content="2023-06-12T11:59:43.564Z">
<meta property="article:author" content="The Rings">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/1.png">


<link rel="canonical" href="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/","path":"2023/06/12/xzg-program-beauty-19/","title":"19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？ | 免逸</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">免逸</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">下一代web开发是什么样的？下一代类报表系统是什么样的？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81io%E7%B1%BB%E5%BA%93%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">一、io类库整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">二、输入流和输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%9AInputStream%E3%80%81Reader"><span class="nav-number">2.0.1.</span> <span class="nav-text">1）输入流：InputStream、Reader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%9AOutputStream%E3%80%81Writer"><span class="nav-number">2.0.2.</span> <span class="nav-text">2）输出流：OutputStream、Writer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">3.</span> <span class="nav-text">三、字节流和字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%9AInputStream%E3%80%81OutputStream"><span class="nav-number">3.0.1.</span> <span class="nav-text">1）字节流：InputStream、OutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%9AReader%E3%80%81Writer"><span class="nav-number">3.0.2.</span> <span class="nav-text">2）字符流：Reader、Writer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">四、原始类和装饰器类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.</span> <span class="nav-text">五、原始类分类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E6%96%87%E4%BB%B6"><span class="nav-number">5.0.1.</span> <span class="nav-text">1）文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E7%BD%91%E7%BB%9C"><span class="nav-number">5.0.2.</span> <span class="nav-text">2）网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E5%86%85%E5%AD%98"><span class="nav-number">5.0.3.</span> <span class="nav-text">3）内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E7%AE%A1%E9%81%93"><span class="nav-number">5.0.4.</span> <span class="nav-text">4）管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%EF%BC%89%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">5.0.5.</span> <span class="nav-text">5）标准输入输出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.</span> <span class="nav-text">六、装饰器类分类介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%89%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB"><span class="nav-number">6.0.1.</span> <span class="nav-text">1）支持读写缓存功能的装饰器类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%89%E6%94%AF%E6%8C%81%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB"><span class="nav-number">6.0.2.</span> <span class="nav-text">2）支持基本类型数据读写的装饰器类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%89%E6%94%AF%E6%8C%81%E5%AF%B9%E8%B1%A1%E8%AF%BB%E5%86%99%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB"><span class="nav-number">6.0.3.</span> <span class="nav-text">3）支持对象读写的装饰器类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%EF%BC%89%E6%94%AF%E6%8C%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%89%93%E5%8D%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB"><span class="nav-number">6.0.4.</span> <span class="nav-text">4）支持格式化打印数据的装饰器类</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">The Rings</p>
  <div class="site-description" itemprop="description">软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://www.xzgedu.com/" title="https:&#x2F;&#x2F;www.xzgedu.com&#x2F;" rel="noopener" target="_blank">XZG</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://the-rings.github.io/2023/06/12/xzg-program-beauty-19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="The Rings">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="免逸">
      <meta itemprop="description" content="软件开发一直追求更加高效, 更加已维护甚至更易扩展的方式">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？ | 免逸">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          19. io类库：java.io类库如此庞大，怎么才能全面系统的掌握它？
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-06-12 18:47:57" itemprop="dateCreated datePublished" datetime="2023-06-12T18:47:57+08:00">2023-06-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%EF%BC%88%E7%8E%8B%E4%BA%89%EF%BC%89/" itemprop="url" rel="index"><span itemprop="name">编程之美（王争）</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>相对于其他Java基础知识，大部分程序员对Java I/O可能没那么了解，毕竟平时的工作很少会编写I/O相关的代码，比如读写文件、网络编程等。跟Java容器类似，java.io类库，也非常庞大，如此多类看得眼花缭乱，想要清晰的掌握，需要对其有个系统性的认识。本节，我就带你一块剖析一下java.io类库，给你构建一个java.io类库的全景图。</p>
<h2 id="一、io类库整体结构"><a href="#一、io类库整体结构" class="headerlink" title="一、io类库整体结构"></a>一、io类库整体结构</h2><p>I/O全称为Input/Output，中文为输入/输出。在计算机中，常用的I/O设备有硬盘、网络、键盘、显示器等，在操作系统层面，I/O系统有文件、网络、标准输入和输出（对应键盘和显示器）、管道等。Java提供的I/O类库就是用来读写这些I/O系统的。Java I/O类库主要有两个：java.io类库和java.nio类库。</p>
<p>在JDK1.4之前，Java引入了java.io类库。在JDK1.4中，<strong>Java引入了java.nio类库，支持非阻塞I/O模型的开发。在JDK7中，Java对java.nio类库进行了升级，引入了更多的类，支持异步I/O模型的开发。</strong>关于java.nio和I/O模型，我们下一节再讲。本节聚焦在java.io类库上。</p>
<p>java.io类库中包含的类非常多。在介绍Java容器时，我们画了一张比较复杂的类图，当时，我也提醒你说，一定要将它搞清楚。对于java.io类库，我们同样花了一张类图，如下图所示，也比较复杂，同理，你也要搞搞清楚。搞清楚了这张图，基本上也就掌握了java.io类库。</p>
<p><img src="/2023/06/12/xzg-program-beauty-19/1.png" alt="java.io.png"></p>
<p>上图包含的类比较多，我们分类讲解。从不同的维度，java.io类库有不同的分类方式。我们按照不同的分类方式，拆解整个java.io类库，并逐一讲解。</p>
<h2 id="二、输入流和输出流"><a href="#二、输入流和输出流" class="headerlink" title="二、输入流和输出流"></a>二、输入流和输出流</h2><p>按照<strong>数据流向</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）输入流：InputStream、Reader"><a href="#1）输入流：InputStream、Reader" class="headerlink" title="1）输入流：InputStream、Reader"></a>1）输入流：InputStream、Reader</h4><h4 id="2）输出流：OutputStream、Writer"><a href="#2）输出流：OutputStream、Writer" class="headerlink" title="2）输出流：OutputStream、Writer"></a>2）输出流：OutputStream、Writer</h4><p><strong>所谓输入流，指的是将文件、网络、标准输入（System.in）、管道中的数据，输入到内存中。所谓输出流，指的是将内存中的数据输出到文件、网络、标准输出（System.out、System.err）、管道中。</strong></p>
<p>输入流的读取方式，如下示例代码所示。<strong>我们通过try-catch-resources语句打开InputStream，这样在try代码块结束后，JVM会自动调用InputStream的close()函数关闭输入流。</strong>为了简化代码编写，本节后续示例代码均省略异常的捕获处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> (in.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出流的写入方式，如下示例代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out = <span class="keyword">new</span>  FileOutputStream(<span class="string">&quot;/Users/wangzheng/out.txt&quot;</span>)；</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line">out.write(data);</span><br></pre></td></tr></table></figure>


<h2 id="三、字节流和字符流"><a href="#三、字节流和字符流" class="headerlink" title="三、字节流和字符流"></a>三、字节流和字符流</h2><p>按照数据流的<strong>读写单位</strong>来分类，java.io类库中类可以分为以下两类。</p>
<h4 id="1）字节流：InputStream、OutputStream"><a href="#1）字节流：InputStream、OutputStream" class="headerlink" title="1）字节流：InputStream、OutputStream"></a>1）字节流：InputStream、OutputStream</h4><h4 id="2）字符流：Reader、Writer"><a href="#2）字符流：Reader、Writer" class="headerlink" title="2）字符流：Reader、Writer"></a>2）字符流：Reader、Writer</h4><p>所谓字节流，指的是一个字节一个字节的从输入流中读取数据，或者将数据写入输出流。<strong>所谓字符流，指的是一个字符一个字符的从输入流中读取数据，或者将数据写入输出流。实际上，字符流比起字节流来说，只是多了一个字符编码转换的环节。</strong>我们拿文件读写来举例解释。</p>
<p>前面讲过，<strong>Java中的char类型数据使用UTF16编码，而文件的编码方式有可能是UTF8、GBK等，所以，当从文件中读取数据到Java内存中的char数组时，我们需要将其从文件的编码方式转换为UTF16编码方式，同理，当我们将Java内存中的字符串写入到文件时，需要将UTF16编码转化为文件的编码方式。</strong>示例代码如下所示。在写入完成之后，我们打开a.txt文件，查看文件内容的16进制格式，发现存储的是“王a争”这几个字符的UTF-8编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">String s = <span class="string">&quot;王a争&quot;</span>;</span><br><span class="line">writer.write(s);</span><br></pre></td></tr></table></figure>

<p>从java.io类图中，我们可以发现，Java分别为字符流和字节流设计了两套类。这两套类在代码实现上有些重复，毕竟I/O读写操作都是相同的，唯一的区别只是数据解析的方式不同。实际上，为了字节流和字符流设计两套类完全是没有必要的。java.nio利用“组合优于继承”的设计思想，引入Channel和Buffer的概念，对此设计进行了优化，关于这一点，我们在下节中会详细讲解。</p>
<h2 id="四、原始类和装饰器类"><a href="#四、原始类和装饰器类" class="headerlink" title="四、原始类和装饰器类"></a>四、原始类和装饰器类</h2><p><strong>java.io类库的设计用到了设计模式中的装饰器模式，从这个角度，我们可以将java.io类库中的类分为原始类和装饰器类。</strong>在《设计模式之美》一书中，我详细介绍了java.io类库如何使用装饰器模式简化类的设计，建议你去读一下。这里我们就不再赘述。装饰器类和原始类的区别在于，装饰器类是对原始类的功能增强，不能独立使用。<strong>比如，FileInputStream为原始类，可以独立使用，BufferedInputStream为装饰器类，支持缓存功能，不能独立使用，必须嵌套原始类或其他装饰器类。</strong>示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、原始类分类介绍"><a href="#五、原始类分类介绍" class="headerlink" title="五、原始类分类介绍"></a>五、原始类分类介绍</h2><p>对于原始类，我们还可以按照读写的I/O系统的不同，将其分为如下几类。注意这里不涉及装饰器类，因为装饰器类主要用于增强功能。</p>
<h4 id="1）文件"><a href="#1）文件" class="headerlink" title="1）文件"></a>1）文件</h4><p>跟文件读写相关的类有FileInputStream、FileOutputStream、FileReader、FileWriter。前面已经给出了一些文件读写的示例代码。这里就不再赘述。</p>
<h4 id="2）网络"><a href="#2）网络" class="headerlink" title="2）网络"></a>2）网络</h4><p>实际上，java.io类库并没有提供专门的类用于网络I/O的读写，而是直接复用InputStream类、OutputStream类进行网络I/O的读写。除此之外，单独使用java.io类库也并不能完成网络编程，需要借助java.net类库的配合。java.net类库用来管理网络连接，比如创建连接、关闭连接、监听连接等。java.io类库只负责读写已经建立的网络连接。示例代码如下所示。java.io类库在网络编程中的表现非常差劲，正因为如此，才有了java.nio类库的出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Socket类位于java.net包中</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.29.2.4&quot;</span>, <span class="number">8090</span>);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;hi~&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (in.read(data) != - <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，从java.io的类图中，我们也可以发现，InputStream、OutputStream是所有字节流类的父类，它既可以读写文件，也可以读写网络，还可以读写其他I/O。这充分体现了“抽象”的设计思想。尽管深入到硬件层面，各个I/O设备的读写方式各不相同，但是，上层应用开发并不关系底层实现细节，大部分I/O设备的访问都可以抽象为打开、读、写、关闭等这几个操作。因此，Java将所有的I/O设备都抽象为“Stream（流）”，并为不同I/O设备的读写设计了一套统一的接口。从而对于不同I/O设备的读写，我们可以使用同样的代码实现，代码更加统一、简洁。</p>
<h4 id="3）内存"><a href="#3）内存" class="headerlink" title="3）内存"></a>3）内存</h4><p>跟内存读写相关的类有：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、StringReader、StringWriter。我们将内存看做一种特殊的I/O系统，也可以像文件一样，当作Stream来读写。</p>
<p>在大部分情况下，我们都不需要这些内存读写类，直接对byte数组、char数组进行读写即可，没必要将它们封装成流来操作。这些类的主要作用是实现兼容。比如，我们使用第三方类库中的某个函数，来处理byte数组中的数据，但这个函数的输入参数是InputStream类型的，为了兼容这个函数的定义，我们就可以将待处理的byte数组，封装成ByteArrayInputStream对象，再传递给这个函数处理，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] source = <span class="string">&quot;学技术信小争哥就对了&quot;</span>.getBytes();</span><br><span class="line">InputStream in = <span class="keyword">new</span> ByteArrayInputStream(source);</span><br><span class="line"><span class="comment">// 接下来就可以跟处理其他InputStream一样处理source了</span></span><br></pre></td></tr></table></figure>


<p>在编写单元测试时，这些内存读写类也非常有用，可以替代文件或网络，将测试数据放置于内存，准备起来更加容易。如下代码所示，假设要为readFromFile()这个函数编写单元测试代码，我们需要创建文件，写入测试数据，并且放置到合适的地方，做一堆准备工作才能完成测试。如果使用ByteArrayInputStream，我们便可以在内存中构建测试数据，这样就方便了很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readFromFile</span><span class="params">(InputStream inputStream)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_readFromFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] testData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">  <span class="comment">//...构建测试数据，填入testData数组...</span></span><br><span class="line">  InputStream in = <span class="keyword">new</span> ByteIntputStream(testData);</span><br><span class="line">  <span class="keyword">int</span> res = readFromFile(in);</span><br><span class="line">  <span class="comment">//...assert...判断返回值是否符合预期...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4）管道"><a href="#4）管道" class="headerlink" title="4）管道"></a>4）管道</h4><p>跟管道读写相关的类有：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter。<strong>这里的管道跟Unix操作系统中的管道不同，Unix操作系统中的管道是进程间通信的工具，而这里的管道是Java提供的为同一个进程内两个线程之间通信的工具。一个线程通过PipedOutputStream写入的数据，另一个线程就可以通过PipedInputStream读取数据，示例代码如下所示。尽管Java已经提供了很多线程间通信的方式，比如常用的有共享变量，但是，一般来说，对于两个线程之间非对象的原始数据的传输，我们更倾向于使用管道来实现。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PipedOutputStream out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">PipedInputStream in = <span class="keyword">new</span> PipedInputStream(out);</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      out.write(<span class="string">&quot;Hi wangzheng~&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      in.read(buffer);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h4 id="5）标准输入输出"><a href="#5）标准输入输出" class="headerlink" title="5）标准输入输出"></a>5）标准输入输出</h4><p><strong>在操作系统中，一般会有三个标准I/O系统：标准输入、标准输出、标准错误输出。标准输入对应I/O设备中的键盘，标准输出和标准错误输出对应I/O设备中的屏幕。</strong>Java中的标准输入为System.in，它是一个定义在System类中的静态InputStream对象。Java中的标准输出和标准错误输出分别为System.out和System.err，它们都是定义在System类中的PrintStream对象。PrintStream为装饰器类，需要嵌套OutputStream来使用，支持按照格式输出数据，待会会讲到。System.in、System.out、System.err的使用示例如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br><span class="line"><span class="comment">//System.err显示的字符串为红色，以表示出错</span></span><br><span class="line">System.err.println(<span class="string">&quot;echo: &quot;</span> + s.nextLine());</span><br></pre></td></tr></table></figure>



<h2 id="六、装饰器类分类介绍"><a href="#六、装饰器类分类介绍" class="headerlink" title="六、装饰器类分类介绍"></a>六、装饰器类分类介绍</h2><p>装饰器类用于增强原始类的功能。我们按照功能的不同分类讲解装饰器类。</p>
<h4 id="1）支持读写缓存功能的装饰器类"><a href="#1）支持读写缓存功能的装饰器类" class="headerlink" title="1）支持读写缓存功能的装饰器类"></a>1）支持读写缓存功能的装饰器类</h4><p>支持读写缓存功能的装饰器类有：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。这4个类的作用非常相似，我们拿BufferedInputStream、BufferedOutputStream举例讲解。</p>
<p><strong>对比InputStream，BufferedInputStream会在内存中维护一个8192字节大小的缓存。如果缓存中没有足够的数据，那么read()函数会向操作系统内核请求数据</strong>（关于I/O读写的实现原理，我们在第21节中讲解），读取8192字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，不再请求操作系统。</p>
<p><strong>读取同样多的数据，利用BufferedInputStream，向操作系统内核请求数据的次数减少。我们知道，向操作系统内核请求数据，需要使用系统调用，引起用户态和内核态的切换，是非常耗时的，所以，尽量减少系统调用，会提高程序的性能</strong>（关于这一部分内容的详细介绍，我们留在第21节中讲解）。<strong>不过，如果read()函数每次请求的数据量都大于等于8192字节，那么BufferedInputStream就不起作用了。</strong></p>
<p>如下代码所示，如果文件中的数据大小是8192字节，那么，读取所有数据需要调用8次read()函数，但因为缓存的存在，所以仅需要向操作系统内核请求一次数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/in.txt&quot;</span>));</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//处理data数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，针对OutputStream，java.io类库提供了BufferedOutputStream，用来缓存写入的数据，当积攒到一定量（默认为8192字节）时，再一次性将其写入操作系统内核缓冲区，减少系统调用次数，提高程序的性能。</p>
<h4 id="2）支持基本类型数据读写的装饰器类"><a href="#2）支持基本类型数据读写的装饰器类" class="headerlink" title="2）支持基本类型数据读写的装饰器类"></a>2）支持基本类型数据读写的装饰器类</h4><p>DataInputStream支持将从输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeInt(<span class="number">12</span>);</span><br><span class="line">out.writeChar(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">out.writeFloat(<span class="number">12.12f</span>);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">System.out.println(in.readInt());</span><br><span class="line">System.out.println(in.readChar());</span><br><span class="line">System.out.println(in.readFloat());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<p>调用DataOutputStream的readChar()、writeChar()函数，我们也可以按字符为单位读取、写入数据，但跟字符流类不同的地方是，DataOutputStream类一次只能处理一个字符，而字符流类可以处理char数组，并且字符流类提供的函数更多，功能更加丰富。</p>
<h4 id="3）支持对象读写的装饰器类"><a href="#3）支持对象读写的装饰器类" class="headerlink" title="3）支持对象读写的装饰器类"></a>3）支持对象读写的装饰器类</h4><p>ObjectInputStream支持将从输入流中读取的数据反序列化为对象，ObjectOutputStream支持将对象序列化之后写入到输出流。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">out.writeObject(<span class="keyword">new</span> Person(<span class="number">12</span>, <span class="string">&quot;wangzheng&quot;</span>));</span><br><span class="line"></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">Person p = (Person) in.readObject();</span><br><span class="line">System.out.println(p.getId());</span><br><span class="line">System.out.println(p.getName());</span><br></pre></td></tr></table></figure>


<h4 id="4）支持格式化打印数据的装饰器类"><a href="#4）支持格式化打印数据的装饰器类" class="headerlink" title="4）支持格式化打印数据的装饰器类"></a>4）支持格式化打印数据的装饰器类</h4><p>PrintStream和PrintWriter可以将数据按照一定的格式，转化为字符串，写入到输出流。前面讲到System.out、System.err就是PrintStream类型的。示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PrintStream printStream =<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>));</span><br><span class="line">printStream.print(<span class="number">124</span>); <span class="comment">//int-&gt;Integer-&gt;toString(), 写入字符串&quot;124&quot;</span></span><br><span class="line">printStream.printf(<span class="string">&quot;hello %d&quot;</span>, <span class="number">43</span>); <span class="comment">//写入字符串&quot;hello 43&quot;</span></span><br></pre></td></tr></table></figure>


<p>除了以上装饰器类之外，还有一组原始类，其功能非常类似装饰器类，那就是InputStreamReader、OutputStreamWriter。InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类。它们可以将字节流转化为字符流。示例代码如下所示。从这一点上，我们也可以看出，java.io类库的设计有很多不合理的地方，更晚开发的java.nio类库在设计上明显要合理很多，下节会详细讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;/Users/wangzheng/a.txt&quot;</span>);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(outStream, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;王a争&quot;</span>); <span class="comment">//按照gbk编码将字符串写入文件</span></span><br></pre></td></tr></table></figure>


<p>对于其他装饰器类，比如PushbackInputStream、PushbackReader、SequenceInputStream、LineNumberReader，因为使用的比较少，我们就不再介绍了，如果感兴趣，可以自行查阅。</p>
<p>七、课后思考题<br>在本节中，我们频繁提到“Stream（流）”这个字眼，比如输入流、输出流、字节流、字符流等，这里的“流”到底是什么意思？为什么把I/O看作“流”？</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/12/xzg-program-beauty-20/" rel="prev" title="20. nio类库：BIO、NIO、AIO三种Java I/O模型的实现原理和区别">
                  <i class="fa fa-angle-left"></i> 20. nio类库：BIO、NIO、AIO三种Java I/O模型的实现原理和区别
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/06/12/network-io-multiplex/" rel="next" title="图解 | 原来这就是 IO 多路复用">
                  图解 | 原来这就是 IO 多路复用 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 - 2029 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">The Rings</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
